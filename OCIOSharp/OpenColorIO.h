// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma once

#include "CppSharp.h"
#include <OpenColorIO.h>

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        enum class Allocation;
        enum class BitDepth;
        enum class ChannelOrdering;
        enum class ColorSpaceDirection;
        enum class ColorSpaceVisibility;
        enum class DynamicPropertyType;
        enum class EnvironmentMode;
        enum class GpuLanguage;
        enum class Interpolation;
        enum class LoggingLevel;
        enum class NamedTransformVisibility;
        enum class OptimizationFlags : unsigned long;
        enum class ProcessorCacheFlags : unsigned int;
        enum class ReferenceSpaceType;
        enum class SearchReferenceSpaceType;
        enum class TransformDirection;
        enum class UniformDataType;
        enum class ViewTransformDirection;
        enum class ViewType;
        ref class Baker;
        ref class BuiltinConfigRegistry;
        ref class BuiltinTransformRegistry;
        ref class CPUProcessor;
        ref class ColorSpace;
        ref class ColorSpaceSet;
        ref class Config;
        ref class ConfigIOProxy;
        ref class Context;
        ref class Exception;
        ref class ExceptionMissingFile;
        ref class FileRules;
        ref class FormatMetadata;
        ref class GPUProcessor;
        ref class GpuShaderCreator;
        ref class GpuShaderDesc;
        ref class ImageDesc;
        ref class Look;
        ref class NamedTransform;
        ref class PackedImageDesc;
        ref class PlanarImageDesc;
        ref class Processor;
        ref class ProcessorMetadata;
        ref class SystemMonitors;
        ref class ViewTransform;
        ref class ViewingRules;
    }
}

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        /// <summary>An exception class to throw for errors detected at runtime.</summary>
        /// <remarks>All functions in the Config class can potentially throw this exception.</remarks>
        public ref class Exception : ::Std::RuntimeError
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr(::System::IntPtr __instance);

            Exception(class ::OpenColorIO_v2_4::Exception* native);
            Exception(class ::OpenColorIO_v2_4::Exception* native, bool ownNativeInstance);
            static Exception^ __CreateInstance(::System::IntPtr native);
            static Exception^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            Exception();

            /// <summary>Constructor that takes a string as the exception message.</summary>
            Exception(::System::String^ _0);

            ~Exception();
        };

        /// <summary>An exception class for errors detected at runtime.</summary>
        /// <remarks>
        /// <para>Thrown when OCIO cannot find a file that is expected to exist. This is provided as a custom</para>
        /// <para>type to distinguish cases where one wants to continue looking for missing files, but wants</para>
        /// <para>to properly fail for other error conditions.</para>
        /// </remarks>
        public ref class ExceptionMissingFile : OpenColorIO::OpenColorIO_v2_4::Exception
        {
        public:

            ExceptionMissingFile(class ::OpenColorIO_v2_4::ExceptionMissingFile* native);
            ExceptionMissingFile(class ::OpenColorIO_v2_4::ExceptionMissingFile* native, bool ownNativeInstance);
            static ExceptionMissingFile^ __CreateInstance(::System::IntPtr native);
            static ExceptionMissingFile^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ExceptionMissingFile();

            /// <summary>Constructor that takes a string as the exception message.</summary>
            ExceptionMissingFile(::System::String^ _0);

            ~ExceptionMissingFile();
        };

        /// <summary>A config defines all the color spaces to be available at runtime.</summary>
        /// <remarks>
        /// <para>The color configuration (Config) is the main object for interacting with this library. It</para>
        /// <para>encapsulates all of the information necessary to use customized ColorSpaceTransform and</para>
        /// <para>DisplayViewTransform operations.</para>
        /// <para>See thefor more information on selecting, creating, and working with custom</para>
        /// <para>color configurations.</para>
        /// <para>For applications interested in using only one color config at a time (this is the vast majority</para>
        /// <para>of apps), their API would traditionally get the global configuration and use that, as opposed</para>
        /// <para>to creating a new one. This simplifies the use case for plugins and bindings, as it alleviates</para>
        /// <para>the need to pass around configuration handles.</para>
        /// <para>An example of an application where this would not be sufficient would be a multi-threaded image</para>
        /// <para>proxy server (daemon), which wished to handle multiple show configurations in a single process</para>
        /// <para>concurrently. This app would need to keep multiple configurations alive, and to manage them</para>
        /// <para>appropriately.</para>
        /// <para>Roughly speaking, a novice user should select a default configuration that most closely</para>
        /// <para>approximates the use case (animation, visual effects, etc.), and set the :envvar:`OCIO`</para>
        /// <para>environment variable to point at the root of that configuration.</para>
        /// <para>Initialization using environment variables is typically preferable in</para>
        /// <para>a multi-app ecosystem, as it allows all applications to be</para>
        /// <para>consistently configured.</para>
        /// <para>See</para>
        /// </remarks>
        public ref class Config : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::Config* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Config(class ::OpenColorIO_v2_4::Config* native);
            Config(class ::OpenColorIO_v2_4::Config* native, bool ownNativeInstance);
            static Config^ __CreateInstance(::System::IntPtr native);
            static Config^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Config();

            /// <summary>Get the configuration major version.</summary>
            /// <remarks>
            /// <para>Set the configuration major version.</para>
            /// <para>Throws if it is not supported. Resets minor to the most recent minor for the given major.</para>
            /// </remarks>
            property unsigned int MajorVersion
            {
                unsigned int get();
                void set(unsigned int);
            }

            /// <summary>Get the configuration minor version.</summary>
            /// <remarks>Set the configuration minor version. Throws if it is not supported for the current major.</remarks>
            property unsigned int MinorVersion
            {
                unsigned int get();
                void set(unsigned int);
            }

            /// <summary>Get/set a name string for the config.</summary>
            /// <remarks>
            /// <para>The name string may be used to communicate config update details or similar information</para>
            /// <para>to workflows external to OCIO in cases where the config path/filename itself does not</para>
            /// <para>provide adequate information.</para>
            /// </remarks>
            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Get the family separator</summary>
            /// <remarks>
            /// <para>A single character used to separate the family string into tokens for use in hierarchical</para>
            /// <para>menus.  Defaults to '/'.</para>
            /// <para>Set the family separator</para>
            /// <para>Succeeds if the characters is null or a valid character from the ASCII table i.e. from</para>
            /// <para>value 32 (i.e. space) to 126 (i.e. '~'); otherwise, it throws an exception.</para>
            /// </remarks>
            property char FamilySeparator
            {
                char get();
                void set(char);
            }

            /// <summary>Get the default family separator i.e. '/' .</summary>
            static property char DefaultFamilySeparator
            {
                char get();
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>
            /// <para>This will produce a hash of the all colorspace definitions, etc. All external references,</para>
            /// <para>such as files used in FileTransforms, etc., will be incorporated into the cacheID. While</para>
            /// <para>the contents of the files are not read, the file system is queried for relevant information</para>
            /// <para>(mtime, inode) so that the config's cacheID will change when the underlying luts are updated.</para>
            /// </summary>
            /// <remarks>
            /// <para>If a context is not provided, the current Context will be used.</para>
            /// <para>If a null context is provided, file references will not be taken into</para>
            /// <para>account (this is essentially a hash of Config::serialize).</para>
            /// </remarks>
            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

            property int NumEnvironmentVars
            {
                int get();
            }

            property OpenColorIO::OpenColorIO_v2_4::EnvironmentMode EnvironmentMode
            {
                OpenColorIO::OpenColorIO_v2_4::EnvironmentMode get();
                void set(OpenColorIO::OpenColorIO_v2_4::EnvironmentMode);
            }

            property ::System::String^ SearchPath
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property int NumSearchPaths
            {
                int get();
            }

            property ::System::String^ WorkingDir
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ InactiveColorSpaces
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property int NumRoles
            {
                int get();
            }

            property ::System::String^ DefaultDisplay
            {
                ::System::String^ get();
            }

            property int NumDisplays
            {
                int get();
            }

            property ::System::String^ ActiveDisplays
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ ActiveViews
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Get all displays in the config, ignoring the active_displays list.</summary>
            property int NumDisplaysAll
            {
                int get();
            }

            property int NumLooks
            {
                int get();
            }

            property int NumViewTransforms
            {
                int get();
            }

            /// <summary>Get or set the default_view_transform string from the config.</summary>
            /// <remarks>
            /// <para>Note that if this is not the name of a valid view transform from the scene-referred</para>
            /// <para>connection space, it will be ignored.</para>
            /// </remarks>
            property ::System::String^ DefaultViewTransformName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property bool StrictParsingEnabled
            {
                bool get();
                void set(bool);
            }

            /// <summary>Get the Processor Cache flags.</summary>
            /// <remarks>
            /// <para>Control the caching of processors in the config instance.  By default, caching is on.</para>
            /// <para>The flags allow turning caching off entirely or only turning it off if dynamic</para>
            /// <para>properties are being used by the processor.</para>
            /// </remarks>
            property OpenColorIO::OpenColorIO_v2_4::ProcessorCacheFlags ProcessorCacheFlags
            {
                OpenColorIO::OpenColorIO_v2_4::ProcessorCacheFlags get();
                void set(OpenColorIO::OpenColorIO_v2_4::ProcessorCacheFlags);
            }

            /// <summary>Verify if the config is archivable.</summary>
            /// <returns>bool Archivable if true.</returns>
            /// <remarks>
            /// <para>A config is not archivable if any of the following are true:</para>
            /// <para>-- The working directory is not set</para>
            /// <para>-- It contains FileTransforms with a src outside the working directory</para>
            /// <para>-- The search path contains paths outside the working directory</para>
            /// <para>-- The search path contains paths that start with a context variable</para>
            /// <para>Context variables are allowed but the intent is that they may only resolve to paths that</para>
            /// <para>are within or below the working directory.  This is because the archiving function will</para>
            /// <para>only archive files that are within the working directory in order to ensure that if it is</para>
            /// <para>later expanded, that it will not create any files outside this directory.</para>
            /// <para>For example, a context variable on the search path intended to contain the name of a</para>
            /// <para>sub-directory under the working directory must have the form &quot;./$DIR_NAME&quot; rather than just</para>
            /// <para>&quot;$DIR_NAME&quot; to be considered archivable.  This is imperfect since there is no way to</para>
            /// <para>prevent the context variable from creating a path outside the working dir, but it should</para>
            /// <para>at least draw attention to the fact that the archive would fail if used with context vars</para>
            /// <para>that try to abuse the intended functionality.</para>
            /// </remarks>
            property bool IsArchivable
            {
                bool get();
            }

            /// <summary>Set the configuration major and minor versions. Throws if version is not supported.</summary>
            void SetVersion(unsigned int major, unsigned int minor);

            /// <summary>Allows an older config to be serialized as the current version.</summary>
            void UpgradeToLatestVersion();

            /// <summary>Performs a thorough validation for the most common user errors.</summary>
            /// <remarks>
            /// <para>This will throw an exception if the config is malformed. The most</para>
            /// <para>common error occurs when references are made to colorspaces that do not</para>
            /// <para>exist.</para>
            /// </remarks>
            void Validate();

            /// <summary>Returns the string representation of the Config in YAML text form.</summary>
            /// <remarks>
            /// <para>This is typically stored on disk in a file with the extension .ocio.</para>
            /// <para>NB: This does not validate the config.  Applications should validate before serializing.</para>
            /// </remarks>
            void Serialize(::System::IO::TextWriter^ os);

            /// <summary>
            /// <para>Add (or update) an environment variable with a default value.</para>
            /// <para>But it removes it if the default value is null.</para>
            /// </summary>
            void AddEnvironmentVar(::System::String^ name, ::System::String^ defaultValue);

            ::System::String^ GetEnvironmentVarNameByIndex(int index);

            ::System::String^ GetEnvironmentVarDefault(::System::String^ name);

            void ClearEnvironmentVars();

            /// <summary>Initialize the environment/context variables in the Config's Context.</summary>
            void LoadEnvironment();

            /// <summary>Get a search path from the list.</summary>
            /// <remarks>
            /// <para>The paths are in the order they will be searched (that is, highest to</para>
            /// <para>lowest priority).</para>
            /// </remarks>
            ::System::String^ GetSearchPath(int index);

            void ClearSearchPaths();

            /// <summary>Add a single search path to the end of the list.</summary>
            /// <remarks>
            /// <para>Paths may be either absolute or relative. Relative paths are</para>
            /// <para>relative to the working directory. Forward slashes will be</para>
            /// <para>normalized to reverse for Windows. Environment (context) variables</para>
            /// <para>may be used in paths.</para>
            /// </remarks>
            void AddSearchPath(::System::String^ path);

            /// <summary>
            /// <para>Work on the color spaces selected by the reference color space type</para>
            /// <para>and visibility.</para>
            /// </summary>
            int GetNumColorSpaces(OpenColorIO::OpenColorIO_v2_4::SearchReferenceSpaceType searchReferenceType, OpenColorIO::OpenColorIO_v2_4::ColorSpaceVisibility visibility);

            /// <summary>
            /// <para>Work on the color spaces selected by the reference color space</para>
            /// <para>type and visibility (active or inactive).</para>
            /// </summary>
            /// <remarks>Return empty for invalid index.</remarks>
            ::System::String^ GetColorSpaceNameByIndex(OpenColorIO::OpenColorIO_v2_4::SearchReferenceSpaceType searchReferenceType, OpenColorIO::OpenColorIO_v2_4::ColorSpaceVisibility visibility, int index);

            /// <summary>Work on the active color spaces only.</summary>
            /// <remarks>Only works from the list of active color spaces.</remarks>
            int GetNumColorSpaces();

            /// <summary>Work on the active color spaces only and return null for invalid index.</summary>
            /// <remarks>Only works from the list of active color spaces.</remarks>
            ::System::String^ GetColorSpaceNameByIndex(int index);

            /// <summary>
            /// <para>Get an index from the active color spaces only</para>
            /// <para>and return -1 if the name is not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>The fcn accepts either a color space name, role name, or alias.</para>
            /// <para>(Color space names take precedence over roles.)</para>
            /// </remarks>
            int GetIndexForColorSpace(::System::String^ name);

            /// <summary>
            /// <para>Accepts an alias, role name, named transform name, or color space name and returns the</para>
            /// <para>color space name or the named transform name.</para>
            /// </summary>
            ::System::String^ GetCanonicalName(::System::String^ name);

            /// <summary>Remove a color space from the configuration.</summary>
            /// <remarks>
            /// <para>It does not throw an exception.  Name must be the canonical name.  If a role name or</para>
            /// <para>alias is provided or if the name is not in the config, nothing is done.</para>
            /// <para>Removing a color space from adoes not affect any</para>
            /// <para>sets that have already been created.</para>
            /// </remarks>
            void RemoveColorSpace(::System::String^ name);

            /// <summary>Return true if the color space is used by a transform, a role, or a look.</summary>
            /// <remarks>Name must be the canonical name.</remarks>
            bool IsColorSpaceUsed(::System::String^ name);

            /// <summary>Remove all the color spaces from the configuration.</summary>
            /// <remarks>
            /// <para>Removing color spaces from adoes not affect</para>
            /// <para>anysets that have already been created.</para>
            /// </remarks>
            void ClearColorSpaces();

            /// <summary>Return true if the color space name is present in the inactive_colorspaces list.</summary>
            bool IsInactiveColorSpace(::System::String^ colorspace);

            /// <summary>Return true if the specified color space is linear.</summary>
            /// <param name="colorSpace">Color space to evaluate.</param>
            /// <param name="referenceSpaceType">
            /// <para>Evaluate linearity with respect to the specified reference space</para>
            /// <para>(either scene-referred or display-referred).</para>
            /// </param>
            /// <remarks>
            /// <para>The determination of linearity is made with respect to one of the two reference spaces</para>
            /// <para>(i.e., either the scene-referred one or the display-referred one). If the reference space</para>
            /// <para>type of the color space is the opposite of the requested reference space type, false is</para>
            /// <para>returned immediately rather than trying to invoke the default view transform to convert</para>
            /// <para>between the reference spaces.</para>
            /// <para>Note: This function relies on heuristics that may sometimes give an incorrect result.</para>
            /// <para>For example, if the encoding attribute is not set appropriately or the sampled values fail</para>
            /// <para>to detect non-linearity.</para>
            /// <para>The algorithm proceeds as follows:</para>
            /// <para>-- If the color space isdata attribute is true, return false.</para>
            /// <para>-- If the reference space type of the color space differs from the requested reference</para>
            /// <para>space type, return false.</para>
            /// <para>-- If the color space's encoding attribute is present, return true if it matches the</para>
            /// <para>expected reference space type (i.e., &quot;scene-linear&quot; for REFERENCE_SPACE_SCENE or</para>
            /// <para>&quot;display-linear&quot; for REFERENCE_SPACE_DISPLAY) and false otherwise.</para>
            /// <para>-- If the color space has no to_reference or from_reference transform, return true.</para>
            /// <para>-- Evaluate several points through the color space's transform and check if the output only</para>
            /// <para>differs by a scale factor (which may be different per channel, e.g. allowing an arbitrary</para>
            /// <para>matrix transform, with no offset).</para>
            /// <para>Note that the encoding test happens before the sampled value test to give config authors</para>
            /// <para>ultimate control over the linearity determination. For example, they could set the encoding</para>
            /// <para>attribute to indicate linearity if they want to ignore some areas of non-linearity</para>
            /// <para>(e.g., at extreme values). Or they could set it to indicate that a color space should not</para>
            /// <para>be considered linear, even if it is, in a mathematical sense.</para>
            /// </remarks>
            bool IsColorSpaceLinear(::System::String^ colorSpace, OpenColorIO::OpenColorIO_v2_4::ReferenceSpaceType referenceSpaceType);

            /// <remarks>Setting the ``colorSpaceName`` name to a null string unsets it.</remarks>
            void SetRole(::System::String^ role, ::System::String^ colorSpaceName);

            /// <summary>Return true if the role has been defined.</summary>
            bool HasRole(::System::String^ role);

            /// <summary>
            /// <para>Get the role name at index, this will return values</para>
            /// <para>like 'scene_linear', 'compositing_log'.</para>
            /// </summary>
            /// <remarks>Return empty string if index is out of range.</remarks>
            ::System::String^ GetRoleName(int index);

            /// <summary>Get the role color space at index.</summary>
            /// <remarks>Return empty string if index is out of range.</remarks>
            ::System::String^ GetRoleColorSpace(int index);

            /// <summary>Get the color space name used for the specified role.</summary>
            /// <remarks>Return an empty string if the role is not present</remarks>
            ::System::String^ GetRoleColorSpace(::System::String^ roleName);

            /// <summary>Methods related to displays and views.</summary>
            /// <remarks>
            /// <para>The following methods only manipulate active displays and views. Active</para>
            /// <para>displays and views are defined from an env. variable or from the config file.</para>
            /// <para>Looks is a potentially comma (or colon) delimited list of lookNames,</para>
            /// <para>Where +/- prefixes are optionally allowed to denote forward/inverse</para>
            /// <para>look specification. (And forward is assumed in the absence of either)</para>
            /// <para>Add shared view (or replace existing one with same name).</para>
            /// <para>Shared views are defined at config level and can be referenced by several</para>
            /// <para>displays. Either provide a view transform and a display color space or</para>
            /// <para>just a color space (and a null view transform).  Looks, rule and description</para>
            /// <para>are optional, they can be null or empty.</para>
            /// <para>Shared views using a view transform may use the token_DISPLAY_NAME&gt;</para>
            /// <para>for the color space (see :c:var:`OCIO_VIEW_USE_DISPLAY_NAME`).  In that</para>
            /// <para>case, when the view is referenced in a display, the display color space</para>
            /// <para>that is used will be the one matching the display name.  In other words,</para>
            /// <para>the view will be customized based on the display it is used in.</para>
            /// <para>will throw if the config does not contain</para>
            /// <para>the matching display color space.</para>
            /// <para>Will throw if view or colorSpaceName are null or empty.</para>
            /// </remarks>
            void AddSharedView(::System::String^ view, ::System::String^ viewTransformName, ::System::String^ colorSpaceName, ::System::String^ looks, ::System::String^ ruleName, ::System::String^ description);

            /// <summary>Remove a shared view.  Will throw if the view does not exist.</summary>
            void RemoveSharedView(::System::String^ view);

            /// <summary>Will return &quot;&quot; if the index is invalid.</summary>
            ::System::String^ GetDisplay(int index);

            ::System::String^ GetDefaultView(::System::String^ display);

            ::System::String^ GetDefaultView(::System::String^ display, ::System::String^ colorspaceName);

            /// <summary>
            /// <para>Return the number of views attached to the display including the number of</para>
            /// <para>shared views if any. Return 0 if display does not exist.</para>
            /// </summary>
            int GetNumViews(::System::String^ display);

            ::System::String^ GetView(::System::String^ display, int index);

            /// <summary>
            /// <para>If the config has ViewingRules, get the number of active Views for this</para>
            /// <para>colorspace. (If there are no rules, it returns all of them.)</para>
            /// </summary>
            int GetNumViews(::System::String^ display, ::System::String^ colorspaceName);

            ::System::String^ GetView(::System::String^ display, ::System::String^ colorspaceName, int index);

            /// <summary>
            /// <para>Returns the view_transform attribute of the (display, view) pair. View can</para>
            /// <para>be a shared view of the display. If display is null or empty, config shared views are used.</para>
            /// </summary>
            ::System::String^ GetDisplayViewTransformName(::System::String^ display, ::System::String^ view);

            /// <summary>
            /// <para>Returns the colorspace attribute of the (display, view) pair.</para>
            /// <para>(Note that this may be either a color space or a display color space.)</para>
            /// </summary>
            ::System::String^ GetDisplayViewColorSpaceName(::System::String^ display, ::System::String^ view);

            /// <summary>Returns the looks attribute of a (display, view) pair.</summary>
            ::System::String^ GetDisplayViewLooks(::System::String^ display, ::System::String^ view);

            /// <summary>Returns the rule attribute of a (display, view) pair.</summary>
            ::System::String^ GetDisplayViewRule(::System::String^ display, ::System::String^ view);

            /// <summary>Returns the description attribute of a (display, view) pair.</summary>
            ::System::String^ GetDisplayViewDescription(::System::String^ display, ::System::String^ view);

            /// <summary>
            /// <para>For the (display, view) pair, specify which color space and look to use.</para>
            /// <para>If a look is not desired, then just pass a null or empty string.</para>
            /// </summary>
            void AddDisplayView(::System::String^ display, ::System::String^ view, ::System::String^ colorSpaceName, ::System::String^ looks);

            /// <summary>
            /// <para>For the (display, view) pair, specify the color space or alternatively</para>
            /// <para>specify the view transform and display color space.  The looks, viewing rule, and</para>
            /// <para>description are optional.  Pass a null or empty string for any optional arguments.</para>
            /// <para>If the view already exists, it is replaced.</para>
            /// </summary>
            /// <remarks>
            /// <para>Will throw if:</para>
            /// <para>* Display, view or colorSpace are null or empty.</para>
            /// <para>* Display already has a shared view with the same name.</para>
            /// </remarks>
            void AddDisplayView(::System::String^ display, ::System::String^ view, ::System::String^ viewTransformName, ::System::String^ colorSpaceName, ::System::String^ looks, ::System::String^ ruleName, ::System::String^ description);

            /// <summary>Add a (reference to a) shared view to a display.</summary>
            /// <remarks>
            /// <para>The shared view must be part of the config. See</para>
            /// <para>This will throw if:</para>
            /// <para>* Display or view are null or empty.</para>
            /// <para>* Display already has a view (shared or not) with the same name.</para>
            /// </remarks>
            void AddDisplaySharedView(::System::String^ display, ::System::String^ sharedView);

            /// <summary>Remove the view and the display if no more views.</summary>
            /// <remarks>
            /// <para>It does not remove the associated color space. If the view name is a</para>
            /// <para>shared view, it only removes the reference to the view from the display</para>
            /// <para>but the shared view, remains in the config.</para>
            /// <para>Will throw if the view does not exist.</para>
            /// </remarks>
            void RemoveDisplayView(::System::String^ display, ::System::String^ view);

            /// <summary>Clear all the displays.</summary>
            void ClearDisplays();

            /// <summary>Methods related to the Virtual Display.</summary>
            /// <remarks>
            /// <para>...  (See descriptions for the non-virtual methods above.)</para>
            /// <para>The virtual display is the way to incorporate the ICC monitor profile for a user's display</para>
            /// <para>into OCIO. The views that are defined for the virtual display are the views that are used to</para>
            /// <para>create a new display for an ICC profile. They serve as a kind of template that lets OCIO</para>
            /// <para>know how to build the new display.</para>
            /// <para>Typically the views will define a View Transform and set the colorSpaceName to</para>
            /// <para>&quot;&lt;USE_DISPLAY_NAME&gt;&quot; so that it will use the display color space with the same name as the</para>
            /// <para>display, in this case corresponding to the ICC profile.</para>
            /// </remarks>
            void AddVirtualDisplayView(::System::String^ view, ::System::String^ viewTransformName, ::System::String^ colorSpaceName, ::System::String^ looks, ::System::String^ ruleName, ::System::String^ description);

            void AddVirtualDisplaySharedView(::System::String^ sharedView);

            /// <summary>Get the number of views associated to the virtual display.</summary>
            int GetVirtualDisplayNumViews(OpenColorIO::OpenColorIO_v2_4::ViewType type);

            /// <summary>Get the view name at a specific index.</summary>
            ::System::String^ GetVirtualDisplayView(OpenColorIO::OpenColorIO_v2_4::ViewType type, int index);

            ::System::String^ GetVirtualDisplayViewTransformName(::System::String^ view);

            ::System::String^ GetVirtualDisplayViewColorSpaceName(::System::String^ view);

            ::System::String^ GetVirtualDisplayViewLooks(::System::String^ view);

            ::System::String^ GetVirtualDisplayViewRule(::System::String^ view);

            ::System::String^ GetVirtualDisplayViewDescription(::System::String^ view);

            /// <summary>Remove the view from the virtual display.</summary>
            void RemoveVirtualDisplayView(::System::String^ view);

            /// <summary>Clear the virtual display.</summary>
            void ClearVirtualDisplay();

            /// <summary>Instantiate a new display from a virtual display, using the monitor name.</summary>
            /// <remarks>
            /// <para>This method uses the virtual display to create an actual display for the given monitorName.</para>
            /// <para>The new display will receive the views from the virtual display.</para>
            /// <para>After the ICC profile is read, a display name will be created by combining the description</para>
            /// <para>text from the profile with the monitorName obtained from the OS. Use the SystemMonitors class</para>
            /// <para>to obtain the list of monitorName strings for the displays connected to the computer.</para>
            /// <para>A new display color space will also be created using the display name. It will have a</para>
            /// <para>from_display_reference transform that is a FileTransform pointing to the ICC profile.</para>
            /// <para>Any instantiated display color spaces for a virtual display are intended to be temporary</para>
            /// <para>(i.e. last as long as the current session). By default, they are not saved when writing a</para>
            /// <para>config file. If there is a need to make it a permanent color space, it may be desirable to</para>
            /// <para>copy the ICC profile somewhere under the config search_path.</para>
            /// <para>Will throw if the config does not have a virtual display or if the monitorName does not exist.</para>
            /// <para>If there is already a display or a display color space with the name monitorName, it will be</para>
            /// <para>replaced/updated.</para>
            /// <para>Returns the index of the display.</para>
            /// </remarks>
            int InstantiateDisplayFromMonitorName(::System::String^ monitorName);

            /// <summary>Instantiate a new display from a virtual display, using an ICC profile.</summary>
            /// <remarks>
            /// <para>On platforms such as Linux, where the SystemMonitors class is not able to obtain a list of</para>
            /// <para>ICC profiles from the OS, this method may be used to manually specify a path to an ICC profile.</para>
            /// <para>Will throw if the virtual display definition is missing from the config.</para>
            /// <para>Returns the index of the display.</para>
            /// </remarks>
            int InstantiateDisplayFromICCProfile(::System::String^ ICCProfileFilepath);

            ::System::String^ GetDisplayAll(int index);

            int GetDisplayAllByName(::System::String^ _0);

            /// <summary>
            /// <para>Will be true for a display that was instantiated from a virtual display. These displays are</para>
            /// <para>intended to be temporary (i.e. for the current session) and are not saved to a config file.</para>
            /// </summary>
            bool IsDisplayTemporary(int index);

            /// <summary>
            /// <para>Get either the shared or display-defined views for a display. The</para>
            /// <para>active_views list is ignored.  Passing a null or empty display (with type=VIEW_SHARED)</para>
            /// <para>returns the contents of the shared_views section of the config. Return 0 if display</para>
            /// <para>does not exist.</para>
            /// </summary>
            int GetNumViews(OpenColorIO::OpenColorIO_v2_4::ViewType type, ::System::String^ display);

            ::System::String^ GetView(OpenColorIO::OpenColorIO_v2_4::ViewType type, ::System::String^ display, int index);

            /// <summary>Get the default coefficients for computing luma.</summary>
            /// <remarks>
            /// <para>There is no &quot;1 size fits all&quot; set of luma coefficients. (The</para>
            /// <para>values are typically different for each colorspace, and the</para>
            /// <para>application of them may be nonsensical depending on the</para>
            /// <para>intensity coding anyways). Thus, the 'right' answer is to make</para>
            /// <para>these functions on the ColorSpace class. However, it's</para>
            /// <para>often useful to have a config-wide default so here it is. We will</para>
            /// <para>add the colorspace specific luma call if/when another client is</para>
            /// <para>interesting in using it.</para>
            /// </remarks>
            void GetDefaultLumaCoefs([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            /// <summary>These should be normalized (sum to 1.0 exactly).</summary>
            void SetDefaultLumaCoefs([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            ::System::String^ GetLookNameByIndex(int index);

            void ClearLooks();

            ::System::String^ GetViewTransformNameByIndex(int i);

            void ClearViewTransforms();

            /// <summary>Work on the named transforms selected by visibility.</summary>
            int GetNumNamedTransforms(OpenColorIO::OpenColorIO_v2_4::NamedTransformVisibility visibility);

            /// <summary>Work on the named transforms selected by visibility (active or inactive).</summary>
            /// <remarks>Return an empty string for invalid index.</remarks>
            ::System::String^ GetNamedTransformNameByIndex(OpenColorIO::OpenColorIO_v2_4::NamedTransformVisibility visibility, int index);

            /// <summary>Work on the active named transforms only.</summary>
            int GetNumNamedTransforms();

            /// <summary>Work on the active named transforms only and return an empty string for invalid index.</summary>
            ::System::String^ GetNamedTransformNameByIndex(int index);

            /// <summary>Get an index from the active named transforms only and return -1 if the name is not found.</summary>
            int GetIndexForNamedTransform(::System::String^ name);

            /// <summary>Clear all named transforms.</summary>
            void ClearNamedTransforms();

            /// <summary>
            /// <para>Get the color space of the first rule that matched filePath. (For v1 configs, this is</para>
            /// <para>equivalent to calling parseColorSpaceFromString with strictparsing set to false.)</para>
            /// </summary>
            ::System::String^ GetColorSpaceFromFilepath(::System::String^ filePath);

            /// <summary>
            /// <para>Most applications will use the preceding method, but this method may be</para>
            /// <para>used for applications that want to know which was the highest priority rule to match</para>
            /// <para>filePath.and custom keys methods</para>
            /// <para>may then be used to get additional information about the matching rule.</para>
            /// </summary>
            ::System::String^ GetColorSpaceFromFilepath(::System::String^ filePath, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned long long% ruleIndex);

            /// <summary>
            /// <para>Returns true if the only rule matched by filePath is the default rule.</para>
            /// <para>This is a convenience method for applications that want to require the user to manually</para>
            /// <para>choose a color space when strictParsing is true and no other rules match.</para>
            /// </summary>
            bool FilepathOnlyMatchesDefaultRule(::System::String^ filePath);

            /// <summary>
            /// <para>Given the specified string, get the longest, right-most, colorspace substring that</para>
            /// <para>appears.</para>
            /// </summary>
            /// <remarks>
            /// <para>* If strict parsing is enabled, and no color space is found, return</para>
            /// <para>an empty string.</para>
            /// <para>* If strict parsing is disabled, return ROLE_DEFAULT (if defined).</para>
            /// <para>* If the default role is not defined, return an empty string.</para>
            /// </remarks>
            ::System::String^ ParseColorSpaceFromString(::System::String^ str);

            /// <summary>Clears this config's cache of Processor, CPUProcessor, and GPUProcessor instances.</summary>
            /// <remarks>
            /// <para>This must be done if any of the LUT files used by these Processors have been modified.</para>
            /// <para>Note that setProcessorCacheFlags(PROCESSOR_CACHE_OFF) turns off caching but does not clear</para>
            /// <para>any existing cache.</para>
            /// </remarks>
            void ClearProcessorCache();

            /// <summary>Archive the config and its LUTs into the specified output stream.</summary>
            /// <param name="ostream">The output stream to write to.</param>
            /// <remarks>
            /// <para>The config is archived by serializing the Config object into a file named &quot;config.ocio&quot; and</para>
            /// <para>then walking through the current working directory and any sub-directories.  Any files that</para>
            /// <para>have an extension matching a supported LUT file format are added to the archive.  Any files</para>
            /// <para>that do not have an extension (or have some unsupported LUT extension, including .ocio),</para>
            /// <para>will not be added to the archive. To reiterate, it is the in-memory Config object that is</para>
            /// <para>archived, and not any .ocio file in the current working directory.  The directory structure</para>
            /// <para>relative to the working directory is preserved.  No files outside the working directory are</para>
            /// <para>archived so that if it is later expanded, no files will be created outside the working dir.</para>
            /// <para>The reason the archive is created using all supported LUT file extensions rather than by</para>
            /// <para>trying to resolve all the FileTransforms in the Config to specific files is because of the</para>
            /// <para>goal to allow context variables to continue to work.</para>
            /// <para>If a Config is created with CreateFromStream, CreateFromFile with an OCIOZ archive, or</para>
            /// <para>CreateFromConfigIOProxy, it cannot be archived unless the working directory is manually set</para>
            /// <para>to a directory that contains any necessary LUT files.</para>
            /// <para>The provided output stream must be closed by the caller, if necessary (e.g., an ofstream).</para>
            /// </remarks>
            void Archive(::System::IO::TextWriter^ ostream);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The File Rules are a set of filepath to color space mappings that are evaluated</para>
        /// <para>from first to last. The first rule to match is what determines which color space is</para>
        /// <para>returned. There are four types of rules available. Each rule type has a name key that may</para>
        /// <para>be used by applications to refer to that rule. Name values must be unique i.e. using a</para>
        /// <para>case insensitive comparison. The other keys depend on the rule type:</para>
        /// </summary>
        /// <remarks>
        /// <para>* *Basic Rule*: This is the basic rule type that uses Unix glob style pattern matching and</para>
        /// <para>is thus very easy to use. It contains the keys:</para>
        /// <para>* name: Name of the rule</para>
        /// <para>* colorspace: Color space name to be returned.</para>
        /// <para>* pattern: Glob pattern to be used for the main part of the name/path.</para>
        /// <para>* extension: Glob pattern to be used for the file extension. Note that if glob tokens</para>
        /// <para>are not used, the extension will be used in a non-case-sensitive way by default.</para>
        /// <para>* *Regex Rule*: This is similar to the basic rule but allows additional capabilities for</para>
        /// <para>power-users. It contains the keys:</para>
        /// <para>* name: Name of the rule</para>
        /// <para>* colorspace: Color space name to be returned.</para>
        /// <para>* regex: Regular expression to be evaluated.</para>
        /// <para>* *OCIO v1 style Rule*: This rule allows the use of the OCIO v1 style, where the string</para>
        /// <para>is searched for color space names from the config. This rule may occur 0 or 1 times</para>
        /// <para>in the list. The position in the list prioritizes it with respect to the other rules.</para>
        /// <para>StrictParsing is not used. If no color space is found in the path, the rule will not</para>
        /// <para>match and the next rule will be considered.</para>
        /// <para>seeIt has the key:</para>
        /// <para>* name: Must be &quot;ColorSpaceNamePathSearch&quot;.</para>
        /// <para>* *Default Rule*: The file_rules must always end with this rule. If no prior rules match,</para>
        /// <para>this rule specifies the color space applications will use.</para>
        /// <para>seeIt has the keys:</para>
        /// <para>* name: must be &quot;Default&quot;.</para>
        /// <para>* colorspace : Color space name to be returned.</para>
        /// <para>Custom string keys and associated string values may be used to convey app or</para>
        /// <para>workflow-specific information, e.g. whether the color space should be left as is</para>
        /// <para>or converted into a working space.</para>
        /// <para>Getters and setters are using the rule position, they will throw if the position is not</para>
        /// <para>valid. If the rule at the specified position does not implement the requested property</para>
        /// <para>getter will return NULL and setter will throw.</para>
        /// <para>When loading a v1 config, a set of FileRules are created with ColorSpaceNamePathSearch followed</para>
        /// <para>by the Default rule pointing to the default role. This allows getColorSpaceFromFilepath to emulate</para>
        /// <para>OCIO v1 code that used parseColorSpaceFromString with strictparsing set to false.</para>
        /// </remarks>
        public ref class FileRules : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::FileRules* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            FileRules(class ::OpenColorIO_v2_4::FileRules* native);
            FileRules(class ::OpenColorIO_v2_4::FileRules* native, bool ownNativeInstance);
            static FileRules^ __CreateInstance(::System::IntPtr native);
            static FileRules^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~FileRules();

            /// <summary>Does include default rule. Result will be at least 1.</summary>
            property unsigned long long NumEntries
            {
                unsigned long long get();
            }

            /// <summary>
            /// <para>Check if there is only the default rule using default role and no custom key. This is the</para>
            /// <para>default FileRules state when creating a new config.</para>
            /// </summary>
            property bool IsDefault
            {
                bool get();
            }

            /// <summary>Get the index from the rule name.</summary>
            unsigned long long GetIndexForRule(::System::String^ ruleName);

            /// <summary>Get name of the rule.</summary>
            ::System::String^ GetName(unsigned long long ruleIndex);

            /// <summary>Setting pattern will erase regex.</summary>
            ::System::String^ GetPattern(unsigned long long ruleIndex);

            void SetPattern(unsigned long long ruleIndex, ::System::String^ pattern);

            /// <summary>Setting extension will erase regex.</summary>
            ::System::String^ GetExtension(unsigned long long ruleIndex);

            void SetExtension(unsigned long long ruleIndex, ::System::String^ extension);

            /// <summary>Setting a regex will erase pattern&amp;extension.</summary>
            ::System::String^ GetRegex(unsigned long long ruleIndex);

            void SetRegex(unsigned long long ruleIndex, ::System::String^ regex);

            /// <summary>Set the rule's color space (may also be a role).</summary>
            ::System::String^ GetColorSpace(unsigned long long ruleIndex);

            void SetColorSpace(unsigned long long ruleIndex, ::System::String^ colorSpace);

            /// <summary>Get number of key/value pairs.</summary>
            unsigned long long GetNumCustomKeys(unsigned long long ruleIndex);

            /// <summary>Get name of key.</summary>
            ::System::String^ GetCustomKeyName(unsigned long long ruleIndex, unsigned long long key);

            /// <summary>Get value for the key.</summary>
            ::System::String^ GetCustomKeyValue(unsigned long long ruleIndex, unsigned long long key);

            /// <summary>
            /// <para>Adds a key/value or replace value if key exists. Setting a NULL or an</para>
            /// <para>empty value will erase the key.</para>
            /// </summary>
            void SetCustomKey(unsigned long long ruleIndex, ::System::String^ key, ::System::String^ value);

            /// <summary>Insert a rule at a given ruleIndex.</summary>
            /// <remarks>
            /// <para>Rule currently at ruleIndex will be pushed to index: ruleIndex + 1.</para>
            /// <para>Name must be unique.</para>
            /// <para>- &quot;Default&quot; is a reserved name for the default rule. The default rule is automatically</para>
            /// <para>added and can't be removed. (see).</para>
            /// <para>- &quot;ColorSpaceNamePathSearch&quot; is also a reserved name</para>
            /// <para>(see).</para>
            /// <para>Will throw if pattern, extension or regex is a null or empty string.</para>
            /// <para>Will throw if ruleIndex is not less than.</para>
            /// </remarks>
            void InsertRule(unsigned long long ruleIndex, ::System::String^ name, ::System::String^ colorSpace, ::System::String^ pattern, ::System::String^ extension);

            void InsertRule(unsigned long long ruleIndex, ::System::String^ name, ::System::String^ colorSpace, ::System::String^ regex);

            /// <summary>Helper function to insert a rule.</summary>
            /// <remarks>
            /// <para>Usesto search the path for any of</para>
            /// <para>the color spaces named in the config (as per OCIO v1).</para>
            /// </remarks>
            void InsertPathSearchRule(unsigned long long ruleIndex);

            /// <summary>Helper function to set the color space for the default rule.</summary>
            void SetDefaultRuleColorSpace(::System::String^ colorSpace);

            /// <remarks>
            /// <para>Default rule can't be removed.</para>
            /// <para>Will throw if ruleIndex + 1 is not less than.</para>
            /// </remarks>
            void RemoveRule(unsigned long long ruleIndex);

            /// <summary>Move a rule closer to the start of the list by one position.</summary>
            void IncreaseRulePriority(unsigned long long ruleIndex);

            /// <summary>Move a rule closer to the end of the list by one position.</summary>
            void DecreaseRulePriority(unsigned long long ruleIndex);

            static property ::System::String^ DefaultRuleName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            static property ::System::String^ FilePathSearchRuleName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>ViewingRules</summary>
        /// <remarks>
        /// <para>Viewing Rules allow config authors to filter the list of views an application should offer</para>
        /// <para>based on the color space of an image.  For example, a config may define a large number of</para>
        /// <para>views but not all of them may be appropriate for use with all color spaces.  E.g., some views</para>
        /// <para>may be intended for use with scene-linear color space encodings and others with video color</para>
        /// <para>space encodings.</para>
        /// <para>Each rule has a name key for applications to refer to the rule.  Name values must be unique</para>
        /// <para>(using case insensitive comparison). Viewing Rules may also have the following keys:</para>
        /// <para>* colorspaces: Either a single colorspace name or a list of names.</para>
        /// <para>* encodings: One or more strings to be found in the colorspace's encoding attribute.</para>
        /// <para>Either this attribute or colorspaces must be present, but not both.</para>
        /// <para>* custom : Allows arbitrary key / value string pairs, similar to FileRules.</para>
        /// <para>Getters and setters are using the rule position, they will throw if the position is not</para>
        /// <para>valid.</para>
        /// </remarks>
        public ref class ViewingRules : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::ViewingRules* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ViewingRules(class ::OpenColorIO_v2_4::ViewingRules* native);
            ViewingRules(class ::OpenColorIO_v2_4::ViewingRules* native, bool ownNativeInstance);
            static ViewingRules^ __CreateInstance(::System::IntPtr native);
            static ViewingRules^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ViewingRules();

            property unsigned long long NumEntries
            {
                unsigned long long get();
            }

            /// <summary>
            /// <para>Get the index from the rule name. Will throw if there is no rule named</para>
            /// <para>ruleName.</para>
            /// </summary>
            unsigned long long GetIndexForRule(::System::String^ ruleName);

            /// <summary>Get name of the rule. Will throw if ruleIndex is invalid.</summary>
            ::System::String^ GetName(unsigned long long ruleIndex);

            /// <summary>Get number of colorspaces. Will throw if ruleIndex is invalid.</summary>
            unsigned long long GetNumColorSpaces(unsigned long long ruleIndex);

            /// <summary>Get colorspace name. Will throw if ruleIndex or colorSpaceIndex is invalid.</summary>
            ::System::String^ GetColorSpace(unsigned long long ruleIndex, unsigned long long colorSpaceIndex);

            /// <summary>
            /// <para>Add colorspace name. Will throw if:</para>
            /// <para>* RuleIndex is invalid.</para>
            /// <para>*is not 0.</para>
            /// </summary>
            void AddColorSpace(unsigned long long ruleIndex, ::System::String^ colorSpace);

            /// <summary>Remove colorspace. Will throw if ruleIndex or colorSpaceIndex is invalid.</summary>
            void RemoveColorSpace(unsigned long long ruleIndex, unsigned long long colorSpaceIndex);

            /// <summary>Get number of encodings. Will throw if ruleIndex is invalid.</summary>
            unsigned long long GetNumEncodings(unsigned long long ruleIndex);

            /// <summary>Get encoding name. Will throw if ruleIndex or encodingIndex is invalid.</summary>
            ::System::String^ GetEncoding(unsigned long long ruleIndex, unsigned long long encodingIndex);

            /// <summary>
            /// <para>Add encoding name. Will throw if:</para>
            /// <para>* RuleIndex is invalid.</para>
            /// <para>*is not 0.</para>
            /// </summary>
            void AddEncoding(unsigned long long ruleIndex, ::System::String^ encoding);

            /// <summary>Remove encoding. Will throw if ruleIndex or encodingIndex is invalid.</summary>
            void RemoveEncoding(unsigned long long ruleIndex, unsigned long long encodingIndex);

            /// <summary>Get number of key/value pairs. Will throw if ruleIndex is invalid.</summary>
            unsigned long long GetNumCustomKeys(unsigned long long ruleIndex);

            /// <summary>Get name of key. Will throw if ruleIndex or keyIndex is invalid.</summary>
            ::System::String^ GetCustomKeyName(unsigned long long ruleIndex, unsigned long long keyIndex);

            /// <summary>Get value for the key. Will throw if ruleIndex or keyIndex is invalid.</summary>
            ::System::String^ GetCustomKeyValue(unsigned long long ruleIndex, unsigned long long keyIndex);

            /// <summary>
            /// <para>Adds a key/value or replace value if key exists. Setting a NULL or an</para>
            /// <para>empty value will erase the key. Will throw if ruleIndex is invalid.</para>
            /// </summary>
            void SetCustomKey(unsigned long long ruleIndex, ::System::String^ key, ::System::String^ value);

            /// <summary>Insert a rule at a given ruleIndex.</summary>
            /// <remarks>
            /// <para>Rule currently at ruleIndex will be pushed to index: ruleIndex + 1. If ruleIndex is</para>
            /// <para>a new rule will be added at the end. Will throw if:</para>
            /// <para>* RuleIndex is invalid (must be less than or equal to</para>
            /// <para>* RuleName already exists.</para>
            /// </remarks>
            void InsertRule(unsigned long long ruleIndex, ::System::String^ ruleName);

            /// <summary>Remove a rule. Throws if ruleIndex is not valid.</summary>
            void RemoveRule(unsigned long long ruleIndex);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The *ColorSpace* is the state of an image with respect to colorimetry</para>
        /// <para>and color encoding. Transforming images between different</para>
        /// <para>*ColorSpaces* is the primary motivation for this library.</para>
        /// </summary>
        /// <remarks>
        /// <para>While a complete discussion of color spaces is beyond the scope of</para>
        /// <para>header documentation, traditional uses would be to have *ColorSpaces*</para>
        /// <para>corresponding to: physical capture devices (known cameras, scanners),</para>
        /// <para>and internal 'convenience' spaces (such as scene linear, logarithmic).</para>
        /// </remarks>
        public ref class ColorSpace : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::ColorSpace* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ColorSpace(class ::OpenColorIO_v2_4::ColorSpace* native);
            ColorSpace(class ::OpenColorIO_v2_4::ColorSpace* native, bool ownNativeInstance);
            static ColorSpace^ __CreateInstance(::System::IntPtr native);
            static ColorSpace^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ColorSpace();

            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property unsigned long long NumAliases
            {
                unsigned long long get();
            }

            /// <summary>
            /// <para>Get the family, for use in user interfaces (optional)</para>
            /// <para>The family string could use a '/' separator to indicate levels to be used</para>
            /// <para>by hierarchical menus.</para>
            /// </summary>
            /// <remarks>Set the family, for use in user interfaces (optional)</remarks>
            property ::System::String^ Family
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>
            /// <para>Get the ColorSpace group name (used for equality comparisons)</para>
            /// <para>This allows no-op transforms between different colorspaces.</para>
            /// <para>If an equalityGroup is not defined (an empty string), it will be considered</para>
            /// <para>unique (i.e., it will not compare as equal to other ColorSpaces with an</para>
            /// <para>empty equality group).</para>
            /// </summary>
            property ::System::String^ EqualityGroup
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property OpenColorIO::OpenColorIO_v2_4::BitDepth BitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            /// <summary>A display color space will use the display-referred reference space.</summary>
            property OpenColorIO::OpenColorIO_v2_4::ReferenceSpaceType ReferenceSpaceType
            {
                OpenColorIO::OpenColorIO_v2_4::ReferenceSpaceType get();
            }

            /// <summary>Get the number of categories.</summary>
            property int NumCategories
            {
                int get();
            }

            /// <summary>*Encodings*</summary>
            /// <remarks>
            /// <para>It is sometimes useful for applications to group color spaces based on how the color values</para>
            /// <para>are digitally encoded.  For example, images in scene-linear, logarithmic, video, and data</para>
            /// <para>color spaces could have different default views.  Unlike the Family and EqualityGroup</para>
            /// <para>attributes of a color space, the list of Encodings is predefined in the OCIO documentation</para>
            /// <para>(rather than being config-specific) to make it easier for applications to utilize.</para>
            /// <para>Here is an example config entry that could appear under a ColorSpace:</para>
            /// <para>Encoding strings are not case-sensitive. Although users may add their own encodings, the</para>
            /// <para>strings will typically come from a fixed set listed in the documentation (similar to roles).</para>
            /// </remarks>
            property ::System::String^ Encoding
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>*Data*</summary>
            /// <remarks>
            /// <para>ColorSpaces that are data are treated a bit special. Basically, any colorspace transforms</para>
            /// <para>you try to apply to them are ignored. (Think of applying a gamut mapping transform to an</para>
            /// <para>ID pass). However, the setDataBypass method on ColorSpaceTransform and DisplayViewTransform</para>
            /// <para>allow applications to process data when necessary.  (Think of sending mattes to an HDR</para>
            /// <para>monitor.)</para>
            /// <para>This is traditionally used for pixel data that represents non-color</para>
            /// <para>pixel data, such as normals, point positions, ID information, etc.</para>
            /// </remarks>
            property bool IsData
            {
                bool get();
                void set(bool);
            }

            /// <summary>*Allocation*</summary>
            /// <remarks>
            /// <para>If this colorspace needs to be transferred to a limited dynamic</para>
            /// <para>range coding space (such as during display with a GPU path), use this</para>
            /// <para>allocation to maximize bit efficiency.</para>
            /// </remarks>
            property OpenColorIO::OpenColorIO_v2_4::Allocation Allocation
            {
                OpenColorIO::OpenColorIO_v2_4::Allocation get();
                void set(OpenColorIO::OpenColorIO_v2_4::Allocation);
            }

            /// <summary>
            /// <para>Specify the optional variable values to configure the allocation.</para>
            /// <para>If no variables are specified, the defaults are used.</para>
            /// </summary>
            /// <remarks>
            /// <para>ALLOCATION_UNIFORM::</para>
            /// <para>2 vars: [min, max]</para>
            /// <para>ALLOCATION_LG2::</para>
            /// <para>2 vars: [lg2min, lg2max]</para>
            /// <para>3 vars: [lg2min, lg2max, linear_offset]</para>
            /// </remarks>
            property int AllocationNumVars
            {
                int get();
            }

            /// <summary>Return empty string if idx is out of range.</summary>
            ::System::String^ GetAlias(unsigned long long idx);

            /// <summary>Return true if alias exists.</summary>
            bool HasAlias(::System::String^ alias);

            /// <summary>
            /// <para>Add an alias for the color space name (the aliases may be used as a synonym for the</para>
            /// <para>name).  Nothing will be added if the alias is already the color space name, one of its</para>
            /// <para>aliases, or the argument is null.  The aliases must not conflict with existing roles,</para>
            /// <para>color space names, named transform names, or other aliases.  This is verified when</para>
            /// <para>adding the color space to the config.</para>
            /// </summary>
            void AddAlias(::System::String^ alias);

            /// <summary>Does nothing if alias is not present.</summary>
            void RemoveAlias(::System::String^ alias);

            void ClearAliases();

            /// <summary>
            /// <para>A category is used to allow applications to filter the list of color spaces</para>
            /// <para>they display in menus based on what that color space is used for.</para>
            /// </summary>
            /// <remarks>
            /// <para>Here is an example config entry that could appear under a ColorSpace:</para>
            /// <para></para>
            /// <para>The example contains three categories: 'file-io', 'working-space' and 'basic-3d'.</para>
            /// <para>Category strings are not case-sensitive and the order is not significant.</para>
            /// <para>There is no limit imposed on length or number. Although users may add their own categories,</para>
            /// <para>the strings will typically come from a fixed set listed in the documentation (similar to</para>
            /// <para>roles).</para>
            /// <para>Return true if the category is present.</para>
            /// </remarks>
            bool HasCategory(::System::String^ category);

            /// <summary>Add a single category.</summary>
            /// <remarks>Will do nothing if the category already exists.</remarks>
            void AddCategory(::System::String^ category);

            /// <summary>Remove a category.</summary>
            /// <remarks>Will do nothing if the category is missing.</remarks>
            void RemoveCategory(::System::String^ category);

            /// <summary>Return the category name using its index</summary>
            /// <remarks>Will be null if the index is invalid.</remarks>
            ::System::String^ GetCategory(int index);

            /// <summary>Clear all the categories.</summary>
            void ClearCategories();

            void GetAllocationVars([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% vars);

            void SetAllocationVars(int numvars, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% vars);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The *ColorSpaceSet* is a set of color spaces (i.e. no color space duplication)</para>
        /// <para>which could be the result ofor built from scratch.</para>
        /// </summary>
        /// <remarks>
        /// <para>The color spaces are decoupled from the config ones, i.e., any</para>
        /// <para>changes to the set itself or to its color spaces do not affect the</para>
        /// <para>original color spaces from the configuration.  If needed,</para>
        /// <para>useto update the configuration.</para>
        /// </remarks>
        public ref class ColorSpaceSet : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::ColorSpaceSet* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ColorSpaceSet(class ::OpenColorIO_v2_4::ColorSpaceSet* native);
            ColorSpaceSet(class ::OpenColorIO_v2_4::ColorSpaceSet* native, bool ownNativeInstance);
            static ColorSpaceSet^ __CreateInstance(::System::IntPtr native);
            static ColorSpaceSet^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ColorSpaceSet();

            /// <summary>Return the number of color spaces.</summary>
            property int NumColorSpaces
            {
                int get();
            }

            /// <summary>Return true if the two sets are equal.</summary>
            /// <remarks>The comparison is done on the color space names (not a deep comparison).</remarks>
            static bool operator==(OpenColorIO::OpenColorIO_v2_4::ColorSpaceSet^ __op, OpenColorIO::OpenColorIO_v2_4::ColorSpaceSet^ css);

            virtual bool Equals(::System::Object^ obj) override;

            /// <summary>Return true if the two sets are different.</summary>
            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::ColorSpaceSet^ __op, OpenColorIO::OpenColorIO_v2_4::ColorSpaceSet^ css);

            /// <summary>
            /// <para>Return the color space name using its index.</para>
            /// <para>This will be null if an invalid index is specified.</para>
            /// </summary>
            ::System::String^ GetColorSpaceNameByIndex(int index);

            /// <summary>Will return -1 if the name is not found.</summary>
            /// <remarks>Only accepts color space names (i.e. no role name).</remarks>
            int GetColorSpaceIndex(::System::String^ name);

            /// <returns>true</returns>
            /// <returns>false</returns>
            /// <remarks>Only accepts color space names (i.e. no role name)</remarks>
            bool HasColorSpace(::System::String^ name);

            /// <summary>Remove color space(s) using color space names (i.e. no role name).</summary>
            /// <remarks>The removal of a missing color space does nothing.</remarks>
            void RemoveColorSpace(::System::String^ name);

            /// <summary>Clear all color spaces.</summary>
            void ClearColorSpaces();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The *Look* is an 'artistic' image modification, in a specified image</para>
        /// <para>state.</para>
        /// <para>The processSpace defines the ColorSpace the image is required to be</para>
        /// <para>in, for the math to apply correctly.</para>
        /// </summary>
        public ref class Look : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::Look* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Look(class ::OpenColorIO_v2_4::Look* native);
            Look(class ::OpenColorIO_v2_4::Look* native, bool ownNativeInstance);
            static Look^ __CreateInstance(::System::IntPtr native);
            static Look^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Look();

            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ ProcessSpace
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
                void set(::System::String^);
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>NamedTransform.</summary>
        /// <remarks>
        /// <para>A NamedTransform provides a way for config authors to include a set of color</para>
        /// <para>transforms that are independent of the color space being processed.  For example a &quot;utility</para>
        /// <para>curve&quot; transform where there is no need to convert to or from a reference space.</para>
        /// </remarks>
        public ref class NamedTransform : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func___IntPtr___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_string8(::System::IntPtr __instance, ::System::String^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate unsigned long long Func_ulong___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func___IntPtr___IntPtr_ulong(::System::IntPtr __instance, unsigned long long arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr_string8(::System::IntPtr __instance, ::System::String^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate int Func_int___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func___IntPtr___IntPtr_int(::System::IntPtr __instance, int arg1);

            property class ::OpenColorIO_v2_4::NamedTransform* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            NamedTransform(class ::OpenColorIO_v2_4::NamedTransform* native);
            NamedTransform(class ::OpenColorIO_v2_4::NamedTransform* native, bool ownNativeInstance);
            static NamedTransform^ __CreateInstance(::System::IntPtr native);
            static NamedTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~NamedTransform();

            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Aliases can be used instead of the name. They must be unique within the config.</summary>
            property unsigned long long NumAliases
            {
                unsigned long long get();
            }

            /// <remarks>
            /// <para>ColorSpace::getFamily</para>
            /// <para>ColorSpace::setFamily</para>
            /// </remarks>
            property ::System::String^ Family
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <remarks>ColorSpace::getNumCategories</remarks>
            property int NumCategories
            {
                int get();
            }

            /// <summary>
            /// <para>A NamedTransform is not a color space and does not have an encoding in the same sense.</para>
            /// <para>However, it may be useful to associate a color space encoding that the transform is intended</para>
            /// <para>to be used with, for organizational purposes.</para>
            /// </summary>
            property ::System::String^ Encoding
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Return empty string if idx is  out of range.</summary>
            virtual ::System::String^ GetAlias(unsigned long long idx);

            /// <summary>Return true if alias exists.</summary>
            virtual bool HasAlias(::System::String^ alias);

            /// <summary>
            /// <para>Nothing is done if alias is NULL or empty, if it is already there, or if it is already</para>
            /// <para>the named transform name.</para>
            /// </summary>
            virtual void AddAlias(::System::String^ alias);

            /// <summary>Does nothing if alias is not present.</summary>
            virtual void RemoveAlias(::System::String^ alias);

            virtual void ClearAliases();

            /// <remarks>ColorSpace::hasCategory</remarks>
            virtual bool HasCategory(::System::String^ category);

            /// <remarks>ColorSpace::addCategory</remarks>
            virtual void AddCategory(::System::String^ category);

            /// <remarks>ColorSpace::removeCategory</remarks>
            virtual void RemoveCategory(::System::String^ category);

            /// <remarks>ColorSpace::getCategory</remarks>
            virtual ::System::String^ GetCategory(int index);

            /// <remarks>ColorSpace::clearCategories</remarks>
            virtual void ClearCategories();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>A *ViewTransform* provides a conversion from the main (usually scene-referred) reference space</para>
        /// <para>to the display-referred reference space.  This allows splitting the conversion from the main</para>
        /// <para>reference space to a display into two parts: the ViewTransform plus a display color space.</para>
        /// </summary>
        /// <remarks>
        /// <para>It is also possible to provide a ViewTransform that converts from the display-referred</para>
        /// <para>reference space back to that space.  This is useful in cases when a ViewTransform is needed</para>
        /// <para>when converting between displays (such as HDR to SDR).</para>
        /// <para>The ReferenceSpaceType indicates whether the ViewTransform converts from scene-to-display</para>
        /// <para>reference or display-to-display reference.</para>
        /// <para>The from_reference transform direction is the one that is used when going out towards a display.</para>
        /// </remarks>
        public ref class ViewTransform : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::ViewTransform* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ViewTransform(class ::OpenColorIO_v2_4::ViewTransform* native);
            ViewTransform(class ::OpenColorIO_v2_4::ViewTransform* native, bool ownNativeInstance);
            static ViewTransform^ __CreateInstance(::System::IntPtr native);
            static ViewTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ViewTransform();

            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <remarks>
            /// <para>ColorSpace::getFamily</para>
            /// <para>ColorSpace::setFamily</para>
            /// </remarks>
            property ::System::String^ Family
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <remarks>ColorSpace::getNumCategories</remarks>
            property int NumCategories
            {
                int get();
            }

            property OpenColorIO::OpenColorIO_v2_4::ReferenceSpaceType ReferenceSpaceType
            {
                OpenColorIO::OpenColorIO_v2_4::ReferenceSpaceType get();
            }

            /// <remarks>ColorSpace::hasCategory</remarks>
            bool HasCategory(::System::String^ category);

            /// <remarks>ColorSpace::addCategory</remarks>
            void AddCategory(::System::String^ category);

            /// <remarks>ColorSpace::removeCategory</remarks>
            void RemoveCategory(::System::String^ category);

            /// <remarks>ColorSpace::getCategory</remarks>
            ::System::String^ GetCategory(int index);

            /// <remarks>ColorSpace::clearCategories</remarks>
            void ClearCategories();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The *Processor* represents a specific color transformation which is</para>
        /// <para>the result of</para>
        /// </summary>
        public ref class Processor : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::Processor* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Processor(class ::OpenColorIO_v2_4::Processor* native);
            Processor(class ::OpenColorIO_v2_4::Processor* native, bool ownNativeInstance);
            static Processor^ __CreateInstance(::System::IntPtr native);
            static Processor^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Processor();

            property bool IsNoOp
            {
                bool get();
            }

            /// <summary>
            /// <para>True if the image transformation is non-separable.</para>
            /// <para>For example, if a change in red may also cause a change in green or blue.</para>
            /// </summary>
            property bool HasChannelCrosstalk
            {
                bool get();
            }

            /// <summary>
            /// <para>Returns a hash string generated by hashing the cachedIDs of the (unoptimized) list of ops</para>
            /// <para>contained in the Processor. (This forms part of the key used by the config's processor cache.)</para>
            /// </summary>
            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

            /// <summary>
            /// <para>Get a FormatMetadata containing the top level metadata</para>
            /// <para>for the processor.  For a processor from a CLF file, this corresponds to</para>
            /// <para>the ProcessList metadata.</para>
            /// </summary>
            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>
            /// <para>Get the number of transforms that comprise the processor.</para>
            /// <para>Each transform has a (potentially empty) FormatMetadata.</para>
            /// </summary>
            property int NumTransforms
            {
                int get();
            }

            /// <summary>True if at least one dynamic property of any type exists and is dynamic.</summary>
            property bool IsDynamic
            {
                bool get();
            }

            /// <summary>
            /// <para>Get a FormatMetadata containing the metadata for a</para>
            /// <para>transform within the processor. For a processor from a CLF file, this</para>
            /// <para>corresponds to the metadata associated with an individual process node.</para>
            /// </summary>
            OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ GetTransformFormatMetadata(int index);

            /// <summary>True if at least one dynamic property of that type exists.</summary>
            bool HasDynamicProperty(OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType type);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>////////////////////////////////////////////////////////////////////////</summary>
        public ref class CPUProcessor : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::CPUProcessor* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            CPUProcessor(class ::OpenColorIO_v2_4::CPUProcessor* native);
            CPUProcessor(class ::OpenColorIO_v2_4::CPUProcessor* native, bool ownNativeInstance);
            static CPUProcessor^ __CreateInstance(::System::IntPtr native);
            static CPUProcessor^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~CPUProcessor();

            /// <summary>The in and out bit-depths must be equal for isNoOp to be true.</summary>
            property bool IsNoOp
            {
                bool get();
            }

            /// <summary>
            /// <para>Equivalent to isNoOp from the underlying Processor, i.e., it ignores</para>
            /// <para>in/out bit-depth differences.</para>
            /// </summary>
            property bool IsIdentity
            {
                bool get();
            }

            property bool HasChannelCrosstalk
            {
                bool get();
            }

            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

            /// <summary>Bit-depth of the input pixel buffer.</summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth InputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
            }

            /// <summary>Bit-depth of the output pixel buffer.</summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth OutputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
            }

            /// <summary>True if at least one dynamic property of any type exists and is dynamic.</summary>
            property bool IsDynamic
            {
                bool get();
            }

            /// <summary>True if at least one dynamic property of that type exists.</summary>
            bool HasDynamicProperty(OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType type);

            /// <summary>
            /// <para>Apply to an image with any kind of channel ordering while</para>
            /// <para>respecting the input and output bit-depths.</para>
            /// </summary>
            void Apply(OpenColorIO::OpenColorIO_v2_4::ImageDesc^ imgDesc);

            void Apply(OpenColorIO::OpenColorIO_v2_4::ImageDesc^ srcImgDesc, OpenColorIO::OpenColorIO_v2_4::ImageDesc^ dstImgDesc);

            /// <summary>
            /// <para>Apply to a single pixel respecting that the input and output bit-depths</para>
            /// <para>be 32-bit float and the image buffer be packed RGB/RGBA.</para>
            /// </summary>
            /// <remarks>
            /// <para>This is not as efficient as applying to an entire image at once.</para>
            /// <para>If you are processing multiple pixels, and have the flexibility,</para>
            /// <para>use the above function instead.</para>
            /// </remarks>
            void ApplyRGB([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% pixel);

            void ApplyRGBA([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% pixel);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>////////////////////////////////////////////////////////////////////////</summary>
        public ref class GPUProcessor : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::GPUProcessor* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GPUProcessor(class ::OpenColorIO_v2_4::GPUProcessor* native);
            GPUProcessor(class ::OpenColorIO_v2_4::GPUProcessor* native, bool ownNativeInstance);
            static GPUProcessor^ __CreateInstance(::System::IntPtr native);
            static GPUProcessor^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GPUProcessor();

            property bool IsNoOp
            {
                bool get();
            }

            property bool HasChannelCrosstalk
            {
                bool get();
            }

            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>This class contains meta information about the process that generated</para>
        /// <para>this processor.  The results of these functions do not</para>
        /// <para>impact the pixel processing.</para>
        /// </summary>
        public ref class ProcessorMetadata : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::ProcessorMetadata* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ProcessorMetadata(class ::OpenColorIO_v2_4::ProcessorMetadata* native);
            ProcessorMetadata(class ::OpenColorIO_v2_4::ProcessorMetadata* native, bool ownNativeInstance);
            static ProcessorMetadata^ __CreateInstance(::System::IntPtr native);
            static ProcessorMetadata^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ProcessorMetadata();

            property int NumFiles
            {
                int get();
            }

            property int NumLooks
            {
                int get();
            }

            ::System::String^ GetFile(int index);

            ::System::String^ GetLook(int index);

            void AddFile(::System::String^ fname);

            void AddLook(::System::String^ look);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>In certain situations it is necessary to serialize transforms into a variety</para>
        /// <para>of application specific LUT formats. Note that not all file formats that may</para>
        /// <para>be read also support baking.</para>
        /// </summary>
        /// <remarks>**Usage Example:** *Bake a CSP sRGB viewer LUT*</remarks>
        public ref class Baker : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::Baker* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Baker(class ::OpenColorIO_v2_4::Baker* native);
            Baker(class ::OpenColorIO_v2_4::Baker* native, bool ownNativeInstance);
            static Baker^ __CreateInstance(::System::IntPtr native);
            static Baker^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Baker();

            property ::System::String^ Format
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>
            /// <para>Get editable *optional* format metadata. The metadata that will be used</para>
            /// <para>varies based on the capability of the given file format.  Formats such as CSP,</para>
            /// <para>IridasCube, and ResolveCube will create comments in the file header using the value of</para>
            /// <para>any first-level children elements of the formatMetadata.  The CLF/CTF formats will make</para>
            /// <para>use of the top-level &quot;id&quot; and &quot;name&quot; attributes and children elements &quot;Description&quot;,</para>
            /// <para>&quot;InputDescriptor&quot;, &quot;OutputDescriptor&quot;, and &quot;Info&quot;.</para>
            /// </summary>
            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property ::System::String^ InputSpace
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ ShaperSpace
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Looks
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ TargetSpace
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Display
            {
                ::System::String^ get();
            }

            property ::System::String^ View
            {
                ::System::String^ get();
            }

            property int ShaperSize
            {
                int get();
                void set(int);
            }

            property int CubeSize
            {
                int get();
                void set(int);
            }

            /// <summary>Get the number of LUT bakers.</summary>
            static property int NumFormats
            {
                int get();
            }

            /// <summary>Set the display and view to apply during the baking. Must not be used if setTargetSpace is used.</summary>
            void SetDisplayView(::System::String^ display, ::System::String^ view);

            /// <summary>Bake the LUT into the output stream.</summary>
            void Bake(::System::IO::TextWriter^ os);

            /// <summary>
            /// <para>Get the LUT baker format name at index, return empty string if an invalid</para>
            /// <para>index is specified.</para>
            /// </summary>
            static ::System::String^ GetFormatNameByIndex(int index);

            /// <summary>
            /// <para>Get the LUT baker format extension at index, return empty string if an</para>
            /// <para>invalid index is specified.</para>
            /// </summary>
            static ::System::String^ GetFormatExtensionByIndex(int index);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>This is a light-weight wrapper around an image, that provides a context</para>
        /// <para>for pixel access. This does NOT claim ownership of the pixels or copy</para>
        /// <para>image data.</para>
        /// </summary>
        public ref class ImageDesc : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::BitDepth Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate long long Func_long___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr(::System::IntPtr __instance);

            property class ::OpenColorIO_v2_4::ImageDesc* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ImageDesc(class ::OpenColorIO_v2_4::ImageDesc* native);
            ImageDesc(class ::OpenColorIO_v2_4::ImageDesc* native, bool ownNativeInstance);
            static ImageDesc^ __CreateInstance(::System::IntPtr native);
            static ImageDesc^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ImageDesc();

            ~ImageDesc();

            /// <summary>Get a pointer to the red channel of the first pixel.</summary>
            property ::System::IntPtr RData
            {
                ::System::IntPtr get();
            }

            /// <summary>Get a pointer to the green channel of the first pixel.</summary>
            property ::System::IntPtr GData
            {
                ::System::IntPtr get();
            }

            /// <summary>Get a pointer to the blue channel of the first pixel.</summary>
            property ::System::IntPtr BData
            {
                ::System::IntPtr get();
            }

            /// <summary>
            /// <para>Get a pointer to the alpha channel of the first pixel</para>
            /// <para>or null as alpha channel is optional.</para>
            /// </summary>
            property ::System::IntPtr AData
            {
                ::System::IntPtr get();
            }

            /// <summary>Get the bit-depth.</summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth BitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
            }

            /// <summary>Get the width to process (where x position starts at 0 and ends at width-1).</summary>
            property long Width
            {
                long get();
            }

            /// <summary>Get the height to process (where y position starts at 0 and ends at height-1).</summary>
            property long Height
            {
                long get();
            }

            /// <summary>Get the step in bytes to find the same color channel of the next pixel.</summary>
            property long long XStrideBytes
            {
                long long get();
            }

            /// <summary>
            /// <para>Get the step in bytes to find the same color channel</para>
            /// <para>of the pixel at the same position in the next line.</para>
            /// </summary>
            property long long YStrideBytes
            {
                long long get();
            }

            /// <summary>
            /// <para>Is the image buffer in packed mode with the 4 color channels?</para>
            /// <para>(&quot;Packed&quot; here means that XStrideBytes is 4x the bytes per channel, so it is more specific</para>
            /// <para>than simply any PackedImageDesc.)</para>
            /// </summary>
            property bool IsRGBAPacked
            {
                bool get();
            }

            /// <summary>Is the image buffer 32-bit float?</summary>
            property bool IsFloat
            {
                bool get();
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>All the constructors expect a pointer to packed image data (such as</para>
        /// <para>rgbrgbrgb or rgbargbargba) starting at the first color channel of</para>
        /// <para>the first pixel to process (which does not need to be the first pixel</para>
        /// <para>of the image). The number of channels must be greater than or equal to 3.</para>
        /// <para>If a 4th channel is specified, it is assumed to be alpha</para>
        /// <para>information.  Channels &gt; 4 will be ignored.</para>
        /// </summary>
        /// <remarks>The methods assume the CPUProcessor bit-depth type for the data pointer.</remarks>
        public ref class PackedImageDesc : OpenColorIO::OpenColorIO_v2_4::ImageDesc
        {
        public:

            PackedImageDesc(class ::OpenColorIO_v2_4::PackedImageDesc* native);
            PackedImageDesc(class ::OpenColorIO_v2_4::PackedImageDesc* native, bool ownNativeInstance);
            static PackedImageDesc^ __CreateInstance(::System::IntPtr native);
            static PackedImageDesc^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            /// <remarks>numChannels must be 3 (RGB) or 4 (RGBA).</remarks>
            PackedImageDesc(::System::IntPtr data, long width, long height, long numChannels);

            /// <remarks>numChannels must be 3 (RGB) or 4 (RGBA).</remarks>
            PackedImageDesc(::System::IntPtr data, long width, long height, long numChannels, OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth, long long chanStrideBytes, long long xStrideBytes, long long yStrideBytes);

            PackedImageDesc(::System::IntPtr data, long width, long height, OpenColorIO::OpenColorIO_v2_4::ChannelOrdering chanOrder);

            PackedImageDesc(::System::IntPtr data, long width, long height, OpenColorIO::OpenColorIO_v2_4::ChannelOrdering chanOrder, OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth, long long chanStrideBytes, long long xStrideBytes, long long yStrideBytes);

            ~PackedImageDesc();

            /// <summary>Get the channel ordering of all the pixels.</summary>
            property OpenColorIO::OpenColorIO_v2_4::ChannelOrdering ChannelOrder
            {
                OpenColorIO::OpenColorIO_v2_4::ChannelOrdering get();
            }

            /// <summary>Get the bit-depth.</summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth BitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
            }

            /// <summary>Get a pointer to the first color channel of the first pixel.</summary>
            property ::System::IntPtr Data
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr RData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr GData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr BData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr AData
            {
                ::System::IntPtr get();
            }

            property long Width
            {
                long get();
            }

            property long Height
            {
                long get();
            }

            property long NumChannels
            {
                long get();
            }

            property long long ChanStrideBytes
            {
                long long get();
            }

            property long long XStrideBytes
            {
                long long get();
            }

            property long long YStrideBytes
            {
                long long get();
            }

            property bool IsRGBAPacked
            {
                bool get();
            }

            property bool IsFloat
            {
                bool get();
            }
        };

        /// <summary>
        /// <para>All the constructors expect pointers to the specified image planes</para>
        /// <para>(i.e. rrrr gggg bbbb) starting at the first color channel of the</para>
        /// <para>first pixel to process (which need not be the first pixel of the image).</para>
        /// <para>Pass NULL for aData if no alpha exists (r/g/bData must not be NULL).</para>
        /// </summary>
        /// <remarks>The methods assume the CPUProcessor bit-depth type for the R/G/B/A data pointers.</remarks>
        public ref class PlanarImageDesc : OpenColorIO::OpenColorIO_v2_4::ImageDesc
        {
        public:

            PlanarImageDesc(class ::OpenColorIO_v2_4::PlanarImageDesc* native);
            PlanarImageDesc(class ::OpenColorIO_v2_4::PlanarImageDesc* native, bool ownNativeInstance);
            static PlanarImageDesc^ __CreateInstance(::System::IntPtr native);
            static PlanarImageDesc^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            PlanarImageDesc(::System::IntPtr rData, ::System::IntPtr gData, ::System::IntPtr bData, ::System::IntPtr aData, long width, long height);

            /// <summary>
            /// <para>Note that although PlanarImageDesc is powerful enough to also describe</para>
            /// <para>all PackedImageDesc scenarios, it is recommended to use</para>
            /// <para>a PackedImageDesc where possible since that allows for additional</para>
            /// <para>optimizations.</para>
            /// </summary>
            PlanarImageDesc(::System::IntPtr rData, ::System::IntPtr gData, ::System::IntPtr bData, ::System::IntPtr aData, long width, long height, OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth, long long xStrideBytes, long long yStrideBytes);

            ~PlanarImageDesc();

            property ::System::IntPtr RData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr GData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr BData
            {
                ::System::IntPtr get();
            }

            property ::System::IntPtr AData
            {
                ::System::IntPtr get();
            }

            /// <summary>Get the bit-depth.</summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth BitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
            }

            property long Width
            {
                long get();
            }

            property long Height
            {
                long get();
            }

            property long long XStrideBytes
            {
                long long get();
            }

            property long long YStrideBytes
            {
                long long get();
            }

            property bool IsRGBAPacked
            {
                bool get();
            }

            property bool IsFloat
            {
                bool get();
            }
        };

        /// <summary>
        /// <para>Inherit from the class to fully customize the implementation of a GPU shader program</para>
        /// <para>from a color transformation.</para>
        /// </summary>
        /// <remarks>
        /// <para>When no customizations are needed and the intermediate in-memory step is acceptable then the</para>
        /// <para>is a better choice.</para>
        /// <para>To better decouple thefrom their GPU implementation, the code provides</para>
        /// <para>several addUniform() methods i.e. one per access function types. For example, an</para>
        /// <para>instance owns threeand they are all</para>
        /// <para>implemented by a double. When creating the GPU fragment shader program, the addUniform() with</para>
        /// <para>GpuShaderCreator::DoubleGetter is called when property is dynamic, up to three times.</para>
        /// <para>**An OCIO shader program could contain:**</para>
        /// <para>* A declaration part  e.g., uniform sampled3D tex3;</para>
        /// <para>* Some helper methods</para>
        /// <para>* The OCIO shader function may be broken down as:</para>
        /// <para>* The function header  e.g., void OCIODisplay(in vec4 inColor) {</para>
        /// <para>* The function body    e.g.,   vec4 outColor.rgb = texture3D(tex3, inColor.rgb).rgb;</para>
        /// <para>* The function footer  e.g.,   return outColor; }</para>
        /// <para></para>
        /// <para>**Usage Example:**</para>
        /// <para>Below is a code snippet to highlight the different parts of the OCIO shader program.</para>
        /// </remarks>
        public ref class GpuShaderCreator : ICppInstance
        {
        public:

            enum class TextureType
            {
                /// <summary>Only need a red channel texture</summary>
                TEXTURE_RED_CHANNEL = 0,
                /// <summary>Need a RGB texture</summary>
                TEXTURE_RGB_CHANNEL = 1
            };

            /// <summary>Dimension enum used to differentiate between 1D and 2D object/resource types.</summary>
            enum class TextureDimensions : unsigned char
            {
                TEXTURE_1D = 1,
                TEXTURE_2D = 2
            };

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint(::System::IntPtr __instance, unsigned int arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate unsigned int Func_uint___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_bool(::System::IntPtr __instance, bool arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr(::System::IntPtr __instance, ::System::String^ arg1, ::System::String^ arg2, unsigned int arg3, unsigned int arg4, OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureType arg5, OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureDimensions arg6, OpenColorIO::OpenColorIO_v2_4::Interpolation arg7, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg8);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr(::System::IntPtr __instance, ::System::String^ arg1, ::System::String^ arg2, unsigned int arg3, OpenColorIO::OpenColorIO_v2_4::Interpolation arg4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg5);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_string8_string8_string8_string8_string8(::System::IntPtr __instance, ::System::String^ arg1, ::System::String^ arg2, ::System::String^ arg3, ::System::String^ arg4, ::System::String^ arg5);

            property class ::OpenColorIO_v2_4::GpuShaderCreator* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GpuShaderCreator(class ::OpenColorIO_v2_4::GpuShaderCreator* native);
            GpuShaderCreator(class ::OpenColorIO_v2_4::GpuShaderCreator* native, bool ownNativeInstance);
            static GpuShaderCreator^ __CreateInstance(::System::IntPtr native);
            static GpuShaderCreator^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GpuShaderCreator();

            property ::System::String^ UniqueID
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GpuLanguage Language
            {
                OpenColorIO::OpenColorIO_v2_4::GpuLanguage get();
                void set(OpenColorIO::OpenColorIO_v2_4::GpuLanguage);
            }

            property ::System::String^ FunctionName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ PixelName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <remarks>
            /// <para>Some applications require that textures, uniforms,</para>
            /// <para>and helper methods be uniquely named because several</para>
            /// <para>processor instances could coexist.</para>
            /// <para>Set a prefix to the resource name</para>
            /// </remarks>
            property ::System::String^ ResourcePrefix
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

            property unsigned int TextureMaxWidth
            {
                unsigned int get();
                void set(unsigned int);
            }

            property bool AllowTexture1D
            {
                bool get();
                void set(bool);
            }

            /// <summary>
            /// <para>To avoid global texture sampler and uniform name clashes always append an increasing index</para>
            /// <para>to the resource name.</para>
            /// </summary>
            property unsigned int NextResourceIndex
            {
                unsigned int get();
            }

            /// <summary>Dynamic Property related methods.</summary>
            property unsigned int NumDynamicProperties
            {
                unsigned int get();
            }

            /// <summary>Start to collect the shader data.</summary>
            virtual void Begin(::System::String^ uid);

            /// <summary>End to collect the shader data.</summary>
            virtual void End();

            bool HasDynamicProperty(OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType type);

            /// <summary>Add a 1D or 2D texture</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the LUT data which must be used as-is as the dimensions and</para>
            /// <para>origin are hard-coded in the fragment shader program. So, it means one GPU texture per entry.</para>
            /// </remarks>
            virtual void AddTexture(::System::String^ textureName, ::System::String^ samplerName, unsigned int width, unsigned int height, OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureType channel, OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureDimensions dimensions, OpenColorIO::OpenColorIO_v2_4::Interpolation interpolation, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% values);

            /// <summary>Add a 3D texture with RGB channel type.</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the 3D LUT data which must be used as-is as the dimension</para>
            /// <para>and origin are hard-coded in the fragment shader program. So, it means one GPU 3D texture</para>
            /// <para>per entry.</para>
            /// </remarks>
            virtual void Add3DTexture(::System::String^ textureName, ::System::String^ samplerName, unsigned int edgelen, OpenColorIO::OpenColorIO_v2_4::Interpolation interpolation, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% values);

            virtual void AddToDeclareShaderCode(::System::String^ shaderCode);

            virtual void AddToHelperShaderCode(::System::String^ shaderCode);

            virtual void AddToFunctionHeaderShaderCode(::System::String^ shaderCode);

            virtual void AddToFunctionShaderCode(::System::String^ shaderCode);

            virtual void AddToFunctionFooterShaderCode(::System::String^ shaderCode);

            /// <summary>Create the OCIO shader program</summary>
            /// <remarks>
            /// <para>The OCIO shader program is decomposed to allow a specific implementation</para>
            /// <para>to change some parts. Some product integrations add the color processing</para>
            /// <para>within a client shader program, imposing constraints requiring this flexibility.</para>
            /// </remarks>
            virtual void CreateShaderText(::System::String^ shaderDeclarations, ::System::String^ shaderHelperMethods, ::System::String^ shaderFunctionHeader, ::System::String^ shaderFunctionBody, ::System::String^ shaderFunctionFooter);

            virtual void Finalize();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>This class holds the GPU-related information needed to build a shader program</para>
        /// <para>from a specific processor.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class defines the interface and there are two implementations provided.</para>
        /// <para>The &quot;legacy&quot; mode implements the OCIO v1 approach of baking certain ops</para>
        /// <para>in order to have at most one 3D-LUT.  The &quot;generic&quot; mode is the v2 default and</para>
        /// <para>allows all the ops to be processed as-is, without baking, like the CPU renderer.</para>
        /// <para>Custom implementations could be written to accommodate the GPU needs of a</para>
        /// <para>specific client app.</para>
        /// <para>The complete fragment shader program is decomposed in two main parts:</para>
        /// <para>the OCIO shader program for the color processing and the client shader</para>
        /// <para>program which consumes the pixel color processing.</para>
        /// <para>The OCIO shader program is fully described by the GpuShaderDesc</para>
        /// <para>independently from the client shader program. The only critical</para>
        /// <para>point is the agreement on the OCIO function shader name.</para>
        /// <para>To summarize, the complete shader program is:</para>
        /// <para></para>
        /// <para>**Usage Example:** *Building a GPU shader*</para>
        /// <para>This example is based on the code in: src/apps/ociodisplay/main.cpp</para>
        /// </remarks>
        public ref class GpuShaderDesc : OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func___IntPtr___IntPtr_uint___IntPtr(::System::IntPtr __instance, unsigned int arg1, OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData^ arg2);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureTypePtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensionsPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr(::System::IntPtr __instance, unsigned int arg1, ::System::String^ arg2, ::System::String^ arg3, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% arg4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% arg5, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureType% arg6, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureDimensions% arg7, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::Interpolation% arg8);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_floatPtrPtr(::System::IntPtr __instance, unsigned int arg1, float* arg2);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr(::System::IntPtr __instance, unsigned int arg1, ::System::String^ arg2, ::System::String^ arg3, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% arg4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::Interpolation% arg5);

            /// <summary>
            /// <para>Used to retrieve uniform information. UniformData m_type indicates the type of uniform</para>
            /// <para>and what member of the structure should be used:</para>
            /// <para>* UNIFORM_DOUBLE: m_getDouble.</para>
            /// <para>* UNIFORM_BOOL: m_getBool.</para>
            /// <para>* UNIFORM_FLOAT3: m_getFloat3.</para>
            /// <para>* UNIFORM_VECTOR_FLOAT: m_vectorFloat.</para>
            /// <para>* UNIFORM_VECTOR_INT: m_vectorInt.</para>
            /// </summary>
            ref class UniformData : ICppInstance
            {
            public:

                ref class VectorFloat : ICppInstance
                {
                public:

                    property struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat* NativePtr;
                    property ::System::IntPtr __Instance
                    {
                        virtual ::System::IntPtr get();
                        virtual void set(::System::IntPtr instance);
                    }

                    VectorFloat(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat* native);
                    VectorFloat(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat* native, bool ownNativeInstance);
                    static VectorFloat^ __CreateInstance(::System::IntPtr native);
                    static VectorFloat^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
                    VectorFloat(OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat^ _0);

                    VectorFloat();

                    ~VectorFloat();

                protected:

                    bool __ownsNativeInstance;
                };

                ref class VectorInt : ICppInstance
                {
                public:

                    property struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt* NativePtr;
                    property ::System::IntPtr __Instance
                    {
                        virtual ::System::IntPtr get();
                        virtual void set(::System::IntPtr instance);
                    }

                    VectorInt(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt* native);
                    VectorInt(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt* native, bool ownNativeInstance);
                    static VectorInt^ __CreateInstance(::System::IntPtr native);
                    static VectorInt^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
                    VectorInt(OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt^ _0);

                    VectorInt();

                    ~VectorInt();

                protected:

                    bool __ownsNativeInstance;
                };

                property struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData* NativePtr;
                property ::System::IntPtr __Instance
                {
                    virtual ::System::IntPtr get();
                    virtual void set(::System::IntPtr instance);
                }

                UniformData(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData* native);
                UniformData(struct ::OpenColorIO_v2_4::GpuShaderDesc::UniformData* native, bool ownNativeInstance);
                static UniformData^ __CreateInstance(::System::IntPtr native);
                static UniformData^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
                UniformData(OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData^ _0);

                UniformData();

                ~UniformData();

                property OpenColorIO::OpenColorIO_v2_4::UniformDataType MType
                {
                    OpenColorIO::OpenColorIO_v2_4::UniformDataType get();
                    void set(OpenColorIO::OpenColorIO_v2_4::UniformDataType);
                }

                property OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat^ MVectorFloat
                {
                    OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat^ get();
                    void set(OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorFloat^);
                }

                property OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt^ MVectorInt
                {
                    OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt^ get();
                    void set(OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData::VectorInt^);
                }

            protected:

                bool __ownsNativeInstance;
            };

            GpuShaderDesc(class ::OpenColorIO_v2_4::GpuShaderDesc* native);
            GpuShaderDesc(class ::OpenColorIO_v2_4::GpuShaderDesc* native, bool ownNativeInstance);
            static GpuShaderDesc^ __CreateInstance(::System::IntPtr native);
            static GpuShaderDesc^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GpuShaderDesc();

            property unsigned int NumUniforms
            {
                unsigned int get();
            }

            property unsigned int NumTextures
            {
                unsigned int get();
            }

            property unsigned int Num3DTextures
            {
                unsigned int get();
            }

            /// <summary>Get the complete OCIO shader program.</summary>
            property ::System::String^ ShaderText
            {
                ::System::String^ get();
            }

            /// <summary>Returns name of uniform and data as parameter.</summary>
            virtual ::System::String^ GetUniform(unsigned int index, OpenColorIO::OpenColorIO_v2_4::GpuShaderDesc::UniformData^ data);

            virtual void GetTexture(unsigned int index, ::System::String^ textureName, ::System::String^ samplerName, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% width, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% height, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureType% channel, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::GpuShaderCreator::TextureDimensions% dimensions, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::Interpolation% interpolation);

            virtual void GetTextureValues(unsigned int index, float* values);

            virtual void Get3DTexture(unsigned int index, ::System::String^ textureName, ::System::String^ samplerName, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% edgelen, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] OpenColorIO::OpenColorIO_v2_4::Interpolation% interpolation);

            virtual void Get3DTextureValues(unsigned int index, float* values);
        };

        /// <summary>Context</summary>
        /// <remarks>
        /// <para>A context defines some overrides to a Config. For example, it can override the</para>
        /// <para>search path or change the value of a context variable.</para>
        /// <para>Only somemethods accept a custom context; otherwise,</para>
        /// <para>the default context instance is used (see</para>
        /// <para>Context Variables</para>
        /// <para>The context variables allow changes at runtime using environment variables. For example,</para>
        /// <para>a color space name (such as src&amp;dst for the ColorSpaceTransform) or a file</para>
        /// <para>name (such as LUT file name for the FileTransform) could be defined by context</para>
        /// <para>variables. The color transformation is then customized based on some environment variables.</para>
        /// <para>In a config the context variables support three syntaxes (i.e. ${VAR}, $VAR and %VAR%) and</para>
        /// <para>the parsing starts from longest to shortest. So, the resolve works like '$TEST_$TESTING_$TE'</para>
        /// <para>expands in this order '2 1 3'.</para>
        /// <para>Config authors are recommended to include the &quot;environment&quot; section in their configs. This</para>
        /// <para>improves performance as well as making the config more readable. When present, this section</para>
        /// <para>must declare all context variables used in the config. It may also provide a default value,</para>
        /// <para>in case the variable is not present in the user's environment.</para>
        /// <para>A context variable may only be used in the following places:</para>
        /// <para>* theto define the source and the destination color space names,</para>
        /// <para>* theto define the source file name (e.g. a LUT file name),</para>
        /// <para>* the search_path,</para>
        /// <para>* the cccid of theto only extract one specific transform from</para>
        /// <para>the CDL&amp;CCC files.</para>
        /// <para>Some specific restrictions are worth calling out:</para>
        /// <para>* they cannot be used as either the name or value of a role,</para>
        /// <para>* the context variable characters $ and % are prohibited in a color space name.</para>
        /// </remarks>
        public ref class Context : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::Context* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Context(class ::OpenColorIO_v2_4::Context* native);
            Context(class ::OpenColorIO_v2_4::Context* native, bool ownNativeInstance);
            static Context^ __CreateInstance(::System::IntPtr native);
            static Context^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Context();

            property ::System::String^ CacheID
            {
                ::System::String^ get();
            }

            property ::System::String^ SearchPath
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property int NumSearchPaths
            {
                int get();
            }

            property ::System::String^ WorkingDir
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property int NumStringVars
            {
                int get();
            }

            property OpenColorIO::OpenColorIO_v2_4::EnvironmentMode EnvironmentMode
            {
                OpenColorIO::OpenColorIO_v2_4::EnvironmentMode get();
                void set(OpenColorIO::OpenColorIO_v2_4::EnvironmentMode);
            }

            ::System::String^ GetSearchPath(int index);

            void ClearSearchPaths();

            void AddSearchPath(::System::String^ path);

            /// <summary>
            /// <para>Add (or update) a context variable. But it removes it if the value argument is null.</para>
            /// <para>Note that a Context StringVar is the same thing as a Config EnvironmentVar and these</para>
            /// <para>are both often referred to as a &quot;context var&quot;.</para>
            /// </summary>
            void SetStringVar(::System::String^ name, ::System::String^ value);

            /// <summary>
            /// <para>Get the context variable value. It returns an empty string if the context</para>
            /// <para>variable is null or does not exist.</para>
            /// </summary>
            ::System::String^ GetStringVar(::System::String^ name);

            ::System::String^ GetStringVarNameByIndex(int index);

            ::System::String^ GetStringVarByIndex(int index);

            void ClearStringVars();

            /// <summary>Seed string vars with the current environment, based on the EnvironmentMode setting.</summary>
            void LoadEnvironment();

            /// <summary>
            /// <para>Resolve all the context variables from the string. It could be color space</para>
            /// <para>names or file names. Note that it recursively applies the context variable resolution.</para>
            /// <para>Returns the string unchanged if it does not contain any context variable.</para>
            /// </summary>
            ::System::String^ ResolveStringVar(::System::String^ string);

            /// <summary>
            /// <para>Build the resolved and expanded filepath using the search_path when needed,</para>
            /// <para>and check if the filepath exists. If it cannot be resolved or found, an exception will be</para>
            /// <para>thrown. The method argument is directly from the config file so it can be an absolute or</para>
            /// <para>relative file path or a file name.</para>
            /// </summary>
            /// <remarks>
            /// <para>The filepath existence check could add a performance hit.</para>
            /// <para>The context variable resolution is performed using :cpp:func:`resolveStringVar`.</para>
            /// </remarks>
            ::System::String^ ResolveFileLocation(::System::String^ filename);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>The built-in transform registry contains all the existing built-in transforms which can</para>
        /// <para>be used by a configuration (version 2 or higher only).</para>
        /// </summary>
        public ref class BuiltinTransformRegistry : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::BuiltinTransformRegistry* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            BuiltinTransformRegistry(class ::OpenColorIO_v2_4::BuiltinTransformRegistry* native);
            BuiltinTransformRegistry(class ::OpenColorIO_v2_4::BuiltinTransformRegistry* native, bool ownNativeInstance);
            static BuiltinTransformRegistry^ __CreateInstance(::System::IntPtr native);
            static BuiltinTransformRegistry^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            /// <summary>Get the number of built-in transforms available.</summary>
            property unsigned long long NumBuiltins
            {
                unsigned long long get();
            }

            /// <summary>
            /// <para>Get the style string for the i-th built-in transform.</para>
            /// <para>The style is the ID string that identifies a given transform.</para>
            /// </summary>
            virtual ::System::String^ GetBuiltinStyle(unsigned long long index);

            /// <summary>Get the description string for the i-th built-in transform.</summary>
            virtual ::System::String^ GetBuiltinDescription(unsigned long long index);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>The built-in configs registry contains information about all the existing built-in configs.</summary>
        public ref class BuiltinConfigRegistry : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func___IntPtr___IntPtr_string8(::System::IntPtr __instance, ::System::String^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr_ulong(::System::IntPtr __instance, unsigned long long arg1);

            property class ::OpenColorIO_v2_4::BuiltinConfigRegistry* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            BuiltinConfigRegistry(class ::OpenColorIO_v2_4::BuiltinConfigRegistry* native);
            BuiltinConfigRegistry(class ::OpenColorIO_v2_4::BuiltinConfigRegistry* native, bool ownNativeInstance);
            static BuiltinConfigRegistry^ __CreateInstance(::System::IntPtr native);
            static BuiltinConfigRegistry^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            /// <summary>Get the number of built-in configs available.</summary>
            property unsigned long long NumBuiltinConfigs
            {
                unsigned long long get();
            }

            property ::System::String^ DefaultBuiltinConfigName
            {
                ::System::String^ get();
            }

            /// <summary>
            /// <para>Get the name of the config at the specified (zero-based) index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            virtual ::System::String^ GetBuiltinConfigName(unsigned long long configIndex);

            /// <summary>Throws for illegal index.</summary>
            virtual ::System::String^ GetBuiltinConfigUIName(unsigned long long configIndex);

            /// <summary>
            /// <para>Get Yaml text of the built-in config at the specified index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            virtual ::System::String^ GetBuiltinConfig(unsigned long long configIndex);

            /// <summary>
            /// <para>Get the Yaml text of the built-in config with the specified name.</para>
            /// <para>Throws if the name is not found.</para>
            /// </summary>
            virtual ::System::String^ GetBuiltinConfigByName(::System::String^ configName);

            /// <summary>Check if a specific built-in config is recommended.</summary>
            /// <param name="configIndex">Index of built-in config.</param>
            /// <returns>true if the config is recommended.</returns>
            /// <remarks>
            /// <para>For backwards compatibility reasons, configs will remain in the registry even if they have</para>
            /// <para>been superseded. If an app is presenting a list of configs to users, it should not include</para>
            /// <para>configs that are no longer recommended.</para>
            /// <para>Throws if the name is not found.</para>
            /// </remarks>
            virtual bool IsBuiltinConfigRecommended(unsigned long long configIndex);

            /// <summary>Get the current built-in configs registry.</summary>
            static OpenColorIO::OpenColorIO_v2_4::BuiltinConfigRegistry^ Get();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Provides access to the ICC monitor profile provided by the operating system for each active display.</summary>
        public ref class SystemMonitors : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::SystemMonitors* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            SystemMonitors(class ::OpenColorIO_v2_4::SystemMonitors* native);
            SystemMonitors(class ::OpenColorIO_v2_4::SystemMonitors* native, bool ownNativeInstance);
            static SystemMonitors^ __CreateInstance(::System::IntPtr native);
            static SystemMonitors^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            /// <summary>
            /// <para>True if the OS is able to provide ICC profiles for the attached monitors (macOS, Windows)</para>
            /// <para>and false otherwise.</para>
            /// </summary>
            property bool IsSupported
            {
                bool get();
            }

            /// <summary>Get the number of active monitors reported by the operating system.</summary>
            property unsigned long long NumMonitors
            {
                unsigned long long get();
            }

            /// <remarks>
            /// <para>Get the monitor profile name.</para>
            /// <para>Get the string describing the monitor. It is used as an argument to instantiateDisplay. It</para>
            /// <para>may also be used in a UI to ask a user which of several monitors they want to instantiate a</para>
            /// <para>display for.</para>
            /// </remarks>
            virtual ::System::String^ GetMonitorName(unsigned long long idx);

            /// <summary>Get the ICC profile path associated to the monitor.</summary>
            virtual ::System::String^ GetProfileFilepath(unsigned long long idx);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>ConfigIOProxy is a proxy class to allow the calling program to supply the config and any</para>
        /// <para>associated LUT files directly, without relying on the standard file system.</para>
        /// </summary>
        /// <remarks>The OCIOZ archive feature is implemented using this mechanism.</remarks>
        public ref class ConfigIOProxy : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::Collections::Generic::List<unsigned char>^ Func__System_Object^___IntPtr_string8(::System::IntPtr __instance, ::System::String^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func_std_basic_string___Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate ::System::String^ Func_std_basic_string___Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___IntPtr_string8(::System::IntPtr __instance, ::System::String^ arg1);

            property class ::OpenColorIO_v2_4::ConfigIOProxy* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            ConfigIOProxy(class ::OpenColorIO_v2_4::ConfigIOProxy* native);
            ConfigIOProxy(class ::OpenColorIO_v2_4::ConfigIOProxy* native, bool ownNativeInstance);
            static ConfigIOProxy^ __CreateInstance(::System::IntPtr native);
            static ConfigIOProxy^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ConfigIOProxy();

            ConfigIOProxy(OpenColorIO::OpenColorIO_v2_4::ConfigIOProxy^ _0);

            ~ConfigIOProxy();

            /// <summary>Provide the config file Yaml to be parsed.</summary>
            /// <returns>String with the config Yaml.</returns>
            property ::System::String^ ConfigData
            {
                ::System::String^ get();
            }

            /// <summary>Provide the contents of a LUT file as a buffer of uint8_t data.</summary>
            /// <param name="filepath">Fully resolved path to the &quot;file.&quot;</param>
            /// <returns>Vector of uint8 with the content of the LUT.</returns>
            /// <remarks>
            /// <para>The file path is based on the Config's current working directory and is the same absolute</para>
            /// <para>path that would have been provided to the file system.</para>
            /// </remarks>
            virtual ::System::Collections::Generic::List<unsigned char>^ GetLutData(::System::String^ filepath);

            /// <summary>Provide a fast unique ID for a LUT file.</summary>
            /// <param name="filepath">Fully resolve the path to the &quot;file.&quot;</param>
            /// <returns>The file hash string.</returns>
            /// <remarks>
            /// <para>This is intended to supply the string that will be used in OCIO's FileCacheMap.</para>
            /// <para>This should be highly performant and typically should not require extensive</para>
            /// <para>computation such as calculating the md5 hash of the file, unless it is pre-computed.</para>
            /// <para>If the &quot;file&quot; does not exist, in other words, if the proxy is unable to supply the requested</para>
            /// <para>file contents, the function must return an empty string.</para>
            /// <para>The file path is based on the Config's current working directory and is the same absolute</para>
            /// <para>path that would have been provided to the file system.</para>
            /// </remarks>
            virtual ::System::String^ GetFastLutFileHash(::System::String^ filepath);

        protected:

            bool __ownsNativeInstance;
        };

        public ref class OpenColorIO
        {
        public:
            /// <summary>
            /// <para>During normal usage, OpenColorIO tends to cache certain global information (such</para>
            /// <para>as the contents of LUTs on disk, intermediate results, etc.). Calling this function will flush</para>
            /// <para>all such information. The global information are related to LUT file identifications, loaded LUT</para>
            /// <para>file content and CDL transforms from loaded CDL files.</para>
            /// </summary>
            /// <remarks>
            /// <para>Under normal usage, this is not necessary, but it can be helpful in particular instances,</para>
            /// <para>such as designing OCIO profiles, and wanting to re-read luts without restarting.</para>
            /// <para>This method does not apply to instance-specific caches such as the Processor cache in</para>
            /// <para>a Config instance or the GPU and CPU Processor caches in a Processor instance. So in cases</para>
            /// <para>where you still have a Config instance after calling ClearAllCaches, you should also call</para>
            /// <para>the Config's clearProcessorCache method.</para>
            /// </remarks>
            static void ClearAllCaches();
            /// <summary>
            /// <para>Get the version number for the library, as a dot-delimited string</para>
            /// <para>(e.g., &quot;1.0.0&quot;).</para>
            /// </summary>
            /// <remarks>This is also available at compile time as OCIO_VERSION_FULL_STR.</remarks>
            static ::System::String^ GetVersion();
            /// <summary>
            /// <para>Get the version number for the library, as a</para>
            /// <para>single 4-byte hex number (e.g., 0x01050200 for &quot;1.5.2&quot;), to be used</para>
            /// <para>for numeric comparisons.</para>
            /// </summary>
            /// <remarks>This is also at compile time as OCIO_VERSION_HEX.</remarks>
            static int GetVersionHex();
            /// <summary>Get the global logging level.</summary>
            /// <remarks>
            /// <para>You can override this at runtime using theenvironment variable. The client application that sets this should use</para>
            /// <para>and not the environment variable. The default value is INFO.</para>
            /// </remarks>
            static OpenColorIO::OpenColorIO_v2_4::LoggingLevel GetLoggingLevel();
            /// <summary>Set the global logging level.</summary>
            static void SetLoggingLevel(OpenColorIO::OpenColorIO_v2_4::LoggingLevel level);
            static void ResetToDefaultLoggingFunction();
            /// <summary>Log a message using the library logging function.</summary>
            static void LogMessage(OpenColorIO::OpenColorIO_v2_4::LoggingLevel level, ::System::String^ message);
            static void ResetComputeHashFunction();
            /// <summary>
            /// <para>Another call modifies the string obtained from a previous call as the method always uses the</para>
            /// <para>same memory buffer.</para>
            /// </summary>
            static ::System::String^ GetEnvVariable(::System::String^ name);
            /// <remarks>This method is not thread safe.</remarks>
            static void SetEnvVariable(::System::String^ name, ::System::String^ value);
            /// <remarks>This method is not thread safe.</remarks>
            static void UnsetEnvVariable(::System::String^ name);
            /// <summary>cpp:function::</summary>
            static bool IsEnvVariablePresent(::System::String^ name);
            /// <summary>
            /// <para>Make a config path forward-compatible by replacing special built-in config names</para>
            /// <para>with the current name.</para>
            /// </summary>
            /// <returns>Resolved path if possible. Otherwise, the original path is returned unmodified.</returns>
            /// <remarks>
            /// <para>Application developers should call this function on any config path they intend to persist</para>
            /// <para>(e.g., to include in a file saved from a DCC).</para>
            /// <para>As the built-in config collection evolves, special names such as &quot;ocio://default&quot; and</para>
            /// <para>&quot;ocio://studio-config-latest&quot; will point to newer versions of those configs. Therefore, it is</para>
            /// <para>recommended that application developers not save those strings and instead save the string that</para>
            /// <para>refers to the current version of that config. That way, it's guaranteed that there will be no</para>
            /// <para>change of behavior in the future. For example, as of OCIO 2.4, &quot;ocio://default&quot; should be saved</para>
            /// <para>as &quot;ocio://cg-config-v2.2.0_aces-v1.3_ocio-v2.4&quot;.</para>
            /// <para>Note that there is no validation done on the path. That is left to the application since</para>
            /// <para>typically the application will load the config before attempting to save its path</para>
            /// <para>and therefore catch, for example, a badly formed URI such as &quot;ocio:default&quot;.</para>
            /// </remarks>
            static ::System::String^ ResolveConfigPath(::System::String^ originalPath);
            /// <summary>Extract an OCIO Config archive.</summary>
            /// <param name="archivePath">Absolute path to the .ocioz file.</param>
            /// <param name="destinationDir">
            /// <para>Absolute path of the directory you want to be created to contain the</para>
            /// <para>contents of the unarchived config.</para>
            /// </param>
            /// <remarks>
            /// <para>Converts an archived config file (.ocioz file) back to its original form as a config file</para>
            /// <para>and associated LUT files.  This creates destinationDir and then creates a config.ocio file</para>
            /// <para>at the root of that working directory and then unpacks the LUT files into their relative</para>
            /// <para>locations relative to that working directory, creating any necessary sub-directories in the</para>
            /// <para>process.  Note that configs which contain LUT files outside the working directory are not</para>
            /// <para>archivable, and so this function will not create directories outside the working directory.</para>
            /// <para>Exception If the archive is not found or there is a problem extracting it.</para>
            /// </remarks>
            static void ExtractOCIOZArchive(::System::String^ archivePath, ::System::String^ destinationDir);
        };
    }
}
