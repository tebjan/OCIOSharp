// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        /// <summary>An exception class to throw for errors detected at runtime.</summary>
        /// <remarks>All functions in the Config class can potentially throw this exception.</remarks>
        public unsafe partial class Exception : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0Exception@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0Exception@OpenColorIO_v2_4@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Exception> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Exception>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Exception managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Exception managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Exception __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Exception(native.ToPointer(), skipVTables);
            }

            internal static Exception __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Exception)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Exception __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Exception)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Exception __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Exception(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Exception(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Exception(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public Exception()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.Exception.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.Exception");
            }

            /// <summary>Constructor that takes a string as the exception message.</summary>
            public Exception(string _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.Exception.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, _0);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.Exception");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenColorIO.OpenColorIO_v2_4.Exception(string _0)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.Exception(_0);
            }

            #region Virtual table interop

            // ~Exception()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Exception.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An exception class for errors detected at runtime.</summary>
        /// <remarks>
        /// <para>Thrown when OCIO cannot find a file that is expected to exist. This is provided as a custom</para>
        /// <para>type to distinguish cases where one wants to continue looking for missing files, but wants</para>
        /// <para>to properly fail for other error conditions.</para>
        /// </remarks>
        public unsafe partial class ExceptionMissingFile : global::OpenColorIO.OpenColorIO_v2_4.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExceptionMissingFile@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExceptionMissingFile@OpenColorIO_v2_4@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExceptionMissingFile@OpenColorIO_v2_4@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            internal static new ExceptionMissingFile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ExceptionMissingFile(native.ToPointer(), skipVTables);
            }

            internal static new ExceptionMissingFile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ExceptionMissingFile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ExceptionMissingFile __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ExceptionMissingFile)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ExceptionMissingFile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ExceptionMissingFile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private ExceptionMissingFile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ExceptionMissingFile(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public ExceptionMissingFile()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile");
            }

            /// <summary>Constructor that takes a string as the exception message.</summary>
            public ExceptionMissingFile(string _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, _0);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile(string _0)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile(_0);
            }

            #region Virtual table interop

            // ~ExceptionMissingFile()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExceptionMissingFile.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A config defines all the color spaces to be available at runtime.</summary>
        /// <remarks>
        /// <para>The color configuration (Config) is the main object for interacting with this library. It</para>
        /// <para>encapsulates all of the information necessary to use customized ColorSpaceTransform and</para>
        /// <para>DisplayViewTransform operations.</para>
        /// <para>See thefor more information on selecting, creating, and working with custom</para>
        /// <para>color configurations.</para>
        /// <para>For applications interested in using only one color config at a time (this is the vast majority</para>
        /// <para>of apps), their API would traditionally get the global configuration and use that, as opposed</para>
        /// <para>to creating a new one. This simplifies the use case for plugins and bindings, as it alleviates</para>
        /// <para>the need to pass around configuration handles.</para>
        /// <para>An example of an application where this would not be sufficient would be a multi-threaded image</para>
        /// <para>proxy server (daemon), which wished to handle multiple show configurations in a single process</para>
        /// <para>concurrently. This app would need to keep multiple configurations alive, and to manage them</para>
        /// <para>appropriately.</para>
        /// <para>Roughly speaking, a novice user should select a default configuration that most closely</para>
        /// <para>approximates the use case (animation, visual effects, etc.), and set the :envvar:`OCIO`</para>
        /// <para>environment variable to point at the root of that configuration.</para>
        /// <para>Initialization using environment variables is typically preferable in</para>
        /// <para>a multi-app ecosystem, as it allows all applications to be</para>
        /// <para>consistently configured.</para>
        /// <para>See</para>
        /// </remarks>
        public unsafe partial class Config : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1Config@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setVersion@Config@OpenColorIO_v2_4@@QEAAXII@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVersion(__IntPtr __instance, uint major, uint minor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?upgradeToLatestVersion@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpgradeToLatestVersion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?validate@Config@OpenColorIO_v2_4@@QEBAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Validate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addEnvironmentVar@Config@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEnvironmentVar(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string defaultValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEnvironmentVarNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEnvironmentVarNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEnvironmentVarDefault@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEnvironmentVarDefault(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearEnvironmentVars@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearEnvironmentVars(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?loadEnvironment@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LoadEnvironment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSearchPath@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSearchPath(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearSearchPaths@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearSearchPaths(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addSearchPath@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSearchPath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumColorSpaces@Config@OpenColorIO_v2_4@@QEBAHW4SearchReferenceSpaceType@2@W4ColorSpaceVisibility@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumColorSpaces(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType searchReferenceType, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceVisibility visibility);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDW4SearchReferenceSpaceType@2@W4ColorSpaceVisibility@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpaceNameByIndex(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType searchReferenceType, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceVisibility visibility, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumColorSpaces@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumColorSpaces(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpaceNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getIndexForColorSpace@Config@OpenColorIO_v2_4@@QEBAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndexForColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCanonicalName@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCanonicalName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeColorSpace@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isColorSpaceUsed@Config@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsColorSpaceUsed(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearColorSpaces@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearColorSpaces(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isInactiveColorSpace@Config@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInactiveColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorspace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isColorSpaceLinear@Config@OpenColorIO_v2_4@@QEBA_NPEBDW4ReferenceSpaceType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsColorSpaceLinear(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace, global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType referenceSpaceType);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setRole@Config@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRole(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string role, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpaceName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasRole@Config@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasRole(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string role);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getRoleName@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRoleName(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getRoleColorSpace@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRoleColorSpace(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getRoleColorSpace@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRoleColorSpace_1(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string roleName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addSharedView@Config@OpenColorIO_v2_4@@QEAAXPEBD00000@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSharedView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string viewTransformName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpaceName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeSharedView@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveSharedView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplay@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplay(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDefaultView@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDefaultView@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorspaceName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumViews@Config@OpenColorIO_v2_4@@QEBAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumViews(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getView@Config@OpenColorIO_v2_4@@QEBAPEBDPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumViews@Config@OpenColorIO_v2_4@@QEBAHPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumViews(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorspaceName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getView@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorspaceName, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayViewTransformName@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayViewTransformName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayViewColorSpaceName@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayViewColorSpaceName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayViewLooks@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayViewLooks(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayViewRule@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayViewRule(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayViewDescription@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayViewDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addDisplayView@Config@OpenColorIO_v2_4@@QEAAXPEBD000@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpaceName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addDisplayView@Config@OpenColorIO_v2_4@@QEAAXPEBD000000@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string viewTransformName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpaceName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addDisplaySharedView@Config@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddDisplaySharedView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sharedView);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeDisplayView@Config@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearDisplays@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearDisplays(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addVirtualDisplayView@Config@OpenColorIO_v2_4@@QEAAXPEBD00000@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddVirtualDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string viewTransformName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpaceName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addVirtualDisplaySharedView@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddVirtualDisplaySharedView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sharedView);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayNumViews@Config@OpenColorIO_v2_4@@QEBAHW4ViewType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetVirtualDisplayNumViews(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ViewType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayView@Config@OpenColorIO_v2_4@@QEBAPEBDW4ViewType@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayView(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ViewType type, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayViewTransformName@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayViewTransformName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayViewColorSpaceName@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayViewColorSpaceName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayViewLooks@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayViewLooks(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayViewRule@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayViewRule(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVirtualDisplayViewDescription@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVirtualDisplayViewDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeVirtualDisplayView@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveVirtualDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearVirtualDisplay@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearVirtualDisplay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?instantiateDisplayFromMonitorName@Config@OpenColorIO_v2_4@@QEAAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int InstantiateDisplayFromMonitorName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string monitorName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?instantiateDisplayFromICCProfile@Config@OpenColorIO_v2_4@@QEAAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int InstantiateDisplayFromICCProfile(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ICCProfileFilepath);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayAll@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplayAll(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplayAllByName@Config@OpenColorIO_v2_4@@QEBAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetDisplayAllByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isDisplayTemporary@Config@OpenColorIO_v2_4@@QEBA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDisplayTemporary(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumViews@Config@OpenColorIO_v2_4@@QEBAHW4ViewType@2@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumViews_1(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ViewType type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getView@Config@OpenColorIO_v2_4@@QEBAPEBDW4ViewType@2@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetView_1(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ViewType type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDefaultLumaCoefs@Config@OpenColorIO_v2_4@@QEBAXPEAN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetDefaultLumaCoefs(__IntPtr __instance, double* rgb);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDefaultLumaCoefs@Config@OpenColorIO_v2_4@@QEAAXPEBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultLumaCoefs(__IntPtr __instance, double* rgb);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLookNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLookNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearLooks@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearLooks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getViewTransformNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetViewTransformNameByIndex(__IntPtr __instance, int i);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearViewTransforms@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearViewTransforms(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumNamedTransforms@Config@OpenColorIO_v2_4@@QEBAHW4NamedTransformVisibility@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumNamedTransforms(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.NamedTransformVisibility visibility);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNamedTransformNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDW4NamedTransformVisibility@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNamedTransformNameByIndex(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.NamedTransformVisibility visibility, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumNamedTransforms@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumNamedTransforms(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNamedTransformNameByIndex@Config@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNamedTransformNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getIndexForNamedTransform@Config@OpenColorIO_v2_4@@QEBAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetIndexForNamedTransform(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearNamedTransforms@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearNamedTransforms(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceFromFilepath@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpaceFromFilepath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceFromFilepath@Config@OpenColorIO_v2_4@@QEBAPEBDPEBDAEA_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpaceFromFilepath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath, ulong* ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?filepathOnlyMatchesDefaultRule@Config@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool FilepathOnlyMatchesDefaultRule(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?parseColorSpaceFromString@Config@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ParseColorSpaceFromString(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearProcessorCache@Config@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearProcessorCache(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getMajorVersion@Config@OpenColorIO_v2_4@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetMajorVersion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setMajorVersion@Config@OpenColorIO_v2_4@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMajorVersion(__IntPtr __instance, uint major);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getMinorVersion@Config@OpenColorIO_v2_4@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetMinorVersion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setMinorVersion@Config@OpenColorIO_v2_4@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMinorVersion(__IntPtr __instance, uint minor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setName@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFamilySeparator@Config@OpenColorIO_v2_4@@QEBADXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte GetFamilySeparator(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setFamilySeparator@Config@OpenColorIO_v2_4@@QEAAXD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFamilySeparator(__IntPtr __instance, sbyte separator);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetDefaultFamilySeparator@Config@OpenColorIO_v2_4@@SADXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern sbyte GetDefaultFamilySeparator();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDescription@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDescription(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDescription@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCacheID@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCacheID(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumEnvironmentVars@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumEnvironmentVars(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEnvironmentMode@Config@OpenColorIO_v2_4@@QEBA?AW4EnvironmentMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode GetEnvironmentMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setEnvironmentMode@Config@OpenColorIO_v2_4@@QEAAXW4EnvironmentMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEnvironmentMode(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode mode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSearchPath@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSearchPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSearchPath@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSearchPath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumSearchPaths@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumSearchPaths(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getWorkingDir@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetWorkingDir(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setWorkingDir@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorkingDir(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dirname);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getInactiveColorSpaces@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetInactiveColorSpaces(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setInactiveColorSpaces@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInactiveColorSpaces(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string inactiveColorSpaces);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumRoles@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumRoles(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDefaultDisplay@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultDisplay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumDisplays@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumDisplays(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getActiveDisplays@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetActiveDisplays(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setActiveDisplays@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetActiveDisplays(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string displays);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getActiveViews@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetActiveViews(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setActiveViews@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetActiveViews(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string views);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumDisplaysAll@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumDisplaysAll(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumLooks@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumLooks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumViewTransforms@Config@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumViewTransforms(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDefaultViewTransformName@Config@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultViewTransformName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDefaultViewTransformName@Config@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultViewTransformName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string defaultName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isStrictParsingEnabled@Config@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsStrictParsingEnabled(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setStrictParsingEnabled@Config@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStrictParsingEnabled(__IntPtr __instance, bool enabled);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getProcessorCacheFlags@Config@OpenColorIO_v2_4@@QEBA?AW4ProcessorCacheFlags@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.ProcessorCacheFlags GetProcessorCacheFlags(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setProcessorCacheFlags@Config@OpenColorIO_v2_4@@QEBAXW4ProcessorCacheFlags@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProcessorCacheFlags(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ProcessorCacheFlags flags);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isArchivable@Config@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArchivable(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Config> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Config>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Config managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Config managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Config __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Config(native.ToPointer(), skipVTables);
            }

            internal static Config __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Config)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Config __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Config(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Config(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Config(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the configuration major and minor versions. Throws if version is not supported.</summary>
            public void SetVersion(uint major, uint minor)
            {
                __Internal.SetVersion(__Instance, major, minor);
            }

            /// <summary>Allows an older config to be serialized as the current version.</summary>
            public void UpgradeToLatestVersion()
            {
                __Internal.UpgradeToLatestVersion(__Instance);
            }

            /// <summary>Performs a thorough validation for the most common user errors.</summary>
            /// <remarks>
            /// <para>This will throw an exception if the config is malformed. The most</para>
            /// <para>common error occurs when references are made to colorspaces that do not</para>
            /// <para>exist.</para>
            /// </remarks>
            public void Validate()
            {
                __Internal.Validate(__Instance);
            }

            /// <summary>
            /// <para>Add (or update) an environment variable with a default value.</para>
            /// <para>But it removes it if the default value is null.</para>
            /// </summary>
            public void AddEnvironmentVar(string name, string defaultValue)
            {
                __Internal.AddEnvironmentVar(__Instance, name, defaultValue);
            }

            public string GetEnvironmentVarNameByIndex(int index)
            {
                var ___ret = __Internal.GetEnvironmentVarNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetEnvironmentVarDefault(string name)
            {
                var ___ret = __Internal.GetEnvironmentVarDefault(__Instance, name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearEnvironmentVars()
            {
                __Internal.ClearEnvironmentVars(__Instance);
            }

            /// <summary>Initialize the environment/context variables in the Config's Context.</summary>
            public void LoadEnvironment()
            {
                __Internal.LoadEnvironment(__Instance);
            }

            /// <summary>Get a search path from the list.</summary>
            /// <remarks>
            /// <para>The paths are in the order they will be searched (that is, highest to</para>
            /// <para>lowest priority).</para>
            /// </remarks>
            public string GetSearchPath(int index)
            {
                var ___ret = __Internal.GetSearchPath(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearSearchPaths()
            {
                __Internal.ClearSearchPaths(__Instance);
            }

            /// <summary>Add a single search path to the end of the list.</summary>
            /// <remarks>
            /// <para>Paths may be either absolute or relative. Relative paths are</para>
            /// <para>relative to the working directory. Forward slashes will be</para>
            /// <para>normalized to reverse for Windows. Environment (context) variables</para>
            /// <para>may be used in paths.</para>
            /// </remarks>
            public void AddSearchPath(string path)
            {
                __Internal.AddSearchPath(__Instance, path);
            }

            /// <summary>
            /// <para>Work on the color spaces selected by the reference color space type</para>
            /// <para>and visibility.</para>
            /// </summary>
            public int GetNumColorSpaces(global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType searchReferenceType, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceVisibility visibility)
            {
                var ___ret = __Internal.GetNumColorSpaces(__Instance, searchReferenceType, visibility);
                return ___ret;
            }

            /// <summary>
            /// <para>Work on the color spaces selected by the reference color space</para>
            /// <para>type and visibility (active or inactive).</para>
            /// </summary>
            /// <remarks>Return empty for invalid index.</remarks>
            public string GetColorSpaceNameByIndex(global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType searchReferenceType, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceVisibility visibility, int index)
            {
                var ___ret = __Internal.GetColorSpaceNameByIndex(__Instance, searchReferenceType, visibility, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Work on the active color spaces only.</summary>
            /// <remarks>Only works from the list of active color spaces.</remarks>
            public int GetNumColorSpaces()
            {
                var ___ret = __Internal.GetNumColorSpaces(__Instance);
                return ___ret;
            }

            /// <summary>Work on the active color spaces only and return null for invalid index.</summary>
            /// <remarks>Only works from the list of active color spaces.</remarks>
            public string GetColorSpaceNameByIndex(int index)
            {
                var ___ret = __Internal.GetColorSpaceNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get an index from the active color spaces only</para>
            /// <para>and return -1 if the name is not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>The fcn accepts either a color space name, role name, or alias.</para>
            /// <para>(Color space names take precedence over roles.)</para>
            /// </remarks>
            public int GetIndexForColorSpace(string name)
            {
                var ___ret = __Internal.GetIndexForColorSpace(__Instance, name);
                return ___ret;
            }

            /// <summary>
            /// <para>Accepts an alias, role name, named transform name, or color space name and returns the</para>
            /// <para>color space name or the named transform name.</para>
            /// </summary>
            public string GetCanonicalName(string name)
            {
                var ___ret = __Internal.GetCanonicalName(__Instance, name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Remove a color space from the configuration.</summary>
            /// <remarks>
            /// <para>It does not throw an exception.  Name must be the canonical name.  If a role name or</para>
            /// <para>alias is provided or if the name is not in the config, nothing is done.</para>
            /// <para>Removing a color space from adoes not affect any</para>
            /// <para>sets that have already been created.</para>
            /// </remarks>
            public void RemoveColorSpace(string name)
            {
                __Internal.RemoveColorSpace(__Instance, name);
            }

            /// <summary>Return true if the color space is used by a transform, a role, or a look.</summary>
            /// <remarks>Name must be the canonical name.</remarks>
            public bool IsColorSpaceUsed(string name)
            {
                var ___ret = __Internal.IsColorSpaceUsed(__Instance, name);
                return ___ret;
            }

            /// <summary>Remove all the color spaces from the configuration.</summary>
            /// <remarks>
            /// <para>Removing color spaces from adoes not affect</para>
            /// <para>anysets that have already been created.</para>
            /// </remarks>
            public void ClearColorSpaces()
            {
                __Internal.ClearColorSpaces(__Instance);
            }

            /// <summary>Return true if the color space name is present in the inactive_colorspaces list.</summary>
            public bool IsInactiveColorSpace(string colorspace)
            {
                var ___ret = __Internal.IsInactiveColorSpace(__Instance, colorspace);
                return ___ret;
            }

            /// <summary>Return true if the specified color space is linear.</summary>
            /// <param name="colorSpace">Color space to evaluate.</param>
            /// <param name="referenceSpaceType">
            /// <para>Evaluate linearity with respect to the specified reference space</para>
            /// <para>(either scene-referred or display-referred).</para>
            /// </param>
            /// <remarks>
            /// <para>The determination of linearity is made with respect to one of the two reference spaces</para>
            /// <para>(i.e., either the scene-referred one or the display-referred one). If the reference space</para>
            /// <para>type of the color space is the opposite of the requested reference space type, false is</para>
            /// <para>returned immediately rather than trying to invoke the default view transform to convert</para>
            /// <para>between the reference spaces.</para>
            /// <para>Note: This function relies on heuristics that may sometimes give an incorrect result.</para>
            /// <para>For example, if the encoding attribute is not set appropriately or the sampled values fail</para>
            /// <para>to detect non-linearity.</para>
            /// <para>The algorithm proceeds as follows:</para>
            /// <para>-- If the color space isdata attribute is true, return false.</para>
            /// <para>-- If the reference space type of the color space differs from the requested reference</para>
            /// <para>space type, return false.</para>
            /// <para>-- If the color space's encoding attribute is present, return true if it matches the</para>
            /// <para>expected reference space type (i.e., &quot;scene-linear&quot; for REFERENCE_SPACE_SCENE or</para>
            /// <para>&quot;display-linear&quot; for REFERENCE_SPACE_DISPLAY) and false otherwise.</para>
            /// <para>-- If the color space has no to_reference or from_reference transform, return true.</para>
            /// <para>-- Evaluate several points through the color space's transform and check if the output only</para>
            /// <para>differs by a scale factor (which may be different per channel, e.g. allowing an arbitrary</para>
            /// <para>matrix transform, with no offset).</para>
            /// <para>Note that the encoding test happens before the sampled value test to give config authors</para>
            /// <para>ultimate control over the linearity determination. For example, they could set the encoding</para>
            /// <para>attribute to indicate linearity if they want to ignore some areas of non-linearity</para>
            /// <para>(e.g., at extreme values). Or they could set it to indicate that a color space should not</para>
            /// <para>be considered linear, even if it is, in a mathematical sense.</para>
            /// </remarks>
            public bool IsColorSpaceLinear(string colorSpace, global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType referenceSpaceType)
            {
                var ___ret = __Internal.IsColorSpaceLinear(__Instance, colorSpace, referenceSpaceType);
                return ___ret;
            }

            /// <remarks>Setting the ``colorSpaceName`` name to a null string unsets it.</remarks>
            public void SetRole(string role, string colorSpaceName)
            {
                __Internal.SetRole(__Instance, role, colorSpaceName);
            }

            /// <summary>Return true if the role has been defined.</summary>
            public bool HasRole(string role)
            {
                var ___ret = __Internal.HasRole(__Instance, role);
                return ___ret;
            }

            /// <summary>
            /// <para>Get the role name at index, this will return values</para>
            /// <para>like 'scene_linear', 'compositing_log'.</para>
            /// </summary>
            /// <remarks>Return empty string if index is out of range.</remarks>
            public string GetRoleName(int index)
            {
                var ___ret = __Internal.GetRoleName(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the role color space at index.</summary>
            /// <remarks>Return empty string if index is out of range.</remarks>
            public string GetRoleColorSpace(int index)
            {
                var ___ret = __Internal.GetRoleColorSpace(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the color space name used for the specified role.</summary>
            /// <remarks>Return an empty string if the role is not present</remarks>
            public string GetRoleColorSpace(string roleName)
            {
                var ___ret = __Internal.GetRoleColorSpace_1(__Instance, roleName);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Methods related to displays and views.</summary>
            /// <remarks>
            /// <para>The following methods only manipulate active displays and views. Active</para>
            /// <para>displays and views are defined from an env. variable or from the config file.</para>
            /// <para>Looks is a potentially comma (or colon) delimited list of lookNames,</para>
            /// <para>Where +/- prefixes are optionally allowed to denote forward/inverse</para>
            /// <para>look specification. (And forward is assumed in the absence of either)</para>
            /// <para>Add shared view (or replace existing one with same name).</para>
            /// <para>Shared views are defined at config level and can be referenced by several</para>
            /// <para>displays. Either provide a view transform and a display color space or</para>
            /// <para>just a color space (and a null view transform).  Looks, rule and description</para>
            /// <para>are optional, they can be null or empty.</para>
            /// <para>Shared views using a view transform may use the token_DISPLAY_NAME&gt;</para>
            /// <para>for the color space (see :c:var:`OCIO_VIEW_USE_DISPLAY_NAME`).  In that</para>
            /// <para>case, when the view is referenced in a display, the display color space</para>
            /// <para>that is used will be the one matching the display name.  In other words,</para>
            /// <para>the view will be customized based on the display it is used in.</para>
            /// <para>will throw if the config does not contain</para>
            /// <para>the matching display color space.</para>
            /// <para>Will throw if view or colorSpaceName are null or empty.</para>
            /// </remarks>
            public void AddSharedView(string view, string viewTransformName, string colorSpaceName, string looks, string ruleName, string description)
            {
                __Internal.AddSharedView(__Instance, view, viewTransformName, colorSpaceName, looks, ruleName, description);
            }

            /// <summary>Remove a shared view.  Will throw if the view does not exist.</summary>
            public void RemoveSharedView(string view)
            {
                __Internal.RemoveSharedView(__Instance, view);
            }

            /// <summary>Will return &quot;&quot; if the index is invalid.</summary>
            public string GetDisplay(int index)
            {
                var ___ret = __Internal.GetDisplay(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetDefaultView(string display)
            {
                var ___ret = __Internal.GetDefaultView(__Instance, display);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetDefaultView(string display, string colorspaceName)
            {
                var ___ret = __Internal.GetDefaultView(__Instance, display, colorspaceName);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Return the number of views attached to the display including the number of</para>
            /// <para>shared views if any. Return 0 if display does not exist.</para>
            /// </summary>
            public int GetNumViews(string display)
            {
                var ___ret = __Internal.GetNumViews(__Instance, display);
                return ___ret;
            }

            public string GetView(string display, int index)
            {
                var ___ret = __Internal.GetView(__Instance, display, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>If the config has ViewingRules, get the number of active Views for this</para>
            /// <para>colorspace. (If there are no rules, it returns all of them.)</para>
            /// </summary>
            public int GetNumViews(string display, string colorspaceName)
            {
                var ___ret = __Internal.GetNumViews(__Instance, display, colorspaceName);
                return ___ret;
            }

            public string GetView(string display, string colorspaceName, int index)
            {
                var ___ret = __Internal.GetView(__Instance, display, colorspaceName, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Returns the view_transform attribute of the (display, view) pair. View can</para>
            /// <para>be a shared view of the display. If display is null or empty, config shared views are used.</para>
            /// </summary>
            public string GetDisplayViewTransformName(string display, string view)
            {
                var ___ret = __Internal.GetDisplayViewTransformName(__Instance, display, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Returns the colorspace attribute of the (display, view) pair.</para>
            /// <para>(Note that this may be either a color space or a display color space.)</para>
            /// </summary>
            public string GetDisplayViewColorSpaceName(string display, string view)
            {
                var ___ret = __Internal.GetDisplayViewColorSpaceName(__Instance, display, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Returns the looks attribute of a (display, view) pair.</summary>
            public string GetDisplayViewLooks(string display, string view)
            {
                var ___ret = __Internal.GetDisplayViewLooks(__Instance, display, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Returns the rule attribute of a (display, view) pair.</summary>
            public string GetDisplayViewRule(string display, string view)
            {
                var ___ret = __Internal.GetDisplayViewRule(__Instance, display, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Returns the description attribute of a (display, view) pair.</summary>
            public string GetDisplayViewDescription(string display, string view)
            {
                var ___ret = __Internal.GetDisplayViewDescription(__Instance, display, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>For the (display, view) pair, specify which color space and look to use.</para>
            /// <para>If a look is not desired, then just pass a null or empty string.</para>
            /// </summary>
            public void AddDisplayView(string display, string view, string colorSpaceName, string looks)
            {
                __Internal.AddDisplayView(__Instance, display, view, colorSpaceName, looks);
            }

            /// <summary>
            /// <para>For the (display, view) pair, specify the color space or alternatively</para>
            /// <para>specify the view transform and display color space.  The looks, viewing rule, and</para>
            /// <para>description are optional.  Pass a null or empty string for any optional arguments.</para>
            /// <para>If the view already exists, it is replaced.</para>
            /// </summary>
            /// <remarks>
            /// <para>Will throw if:</para>
            /// <para>* Display, view or colorSpace are null or empty.</para>
            /// <para>* Display already has a shared view with the same name.</para>
            /// </remarks>
            public void AddDisplayView(string display, string view, string viewTransformName, string colorSpaceName, string looks, string ruleName, string description)
            {
                __Internal.AddDisplayView(__Instance, display, view, viewTransformName, colorSpaceName, looks, ruleName, description);
            }

            /// <summary>Add a (reference to a) shared view to a display.</summary>
            /// <remarks>
            /// <para>The shared view must be part of the config. See</para>
            /// <para>This will throw if:</para>
            /// <para>* Display or view are null or empty.</para>
            /// <para>* Display already has a view (shared or not) with the same name.</para>
            /// </remarks>
            public void AddDisplaySharedView(string display, string sharedView)
            {
                __Internal.AddDisplaySharedView(__Instance, display, sharedView);
            }

            /// <summary>Remove the view and the display if no more views.</summary>
            /// <remarks>
            /// <para>It does not remove the associated color space. If the view name is a</para>
            /// <para>shared view, it only removes the reference to the view from the display</para>
            /// <para>but the shared view, remains in the config.</para>
            /// <para>Will throw if the view does not exist.</para>
            /// </remarks>
            public void RemoveDisplayView(string display, string view)
            {
                __Internal.RemoveDisplayView(__Instance, display, view);
            }

            /// <summary>Clear all the displays.</summary>
            public void ClearDisplays()
            {
                __Internal.ClearDisplays(__Instance);
            }

            /// <summary>Methods related to the Virtual Display.</summary>
            /// <remarks>
            /// <para>...  (See descriptions for the non-virtual methods above.)</para>
            /// <para>The virtual display is the way to incorporate the ICC monitor profile for a user's display</para>
            /// <para>into OCIO. The views that are defined for the virtual display are the views that are used to</para>
            /// <para>create a new display for an ICC profile. They serve as a kind of template that lets OCIO</para>
            /// <para>know how to build the new display.</para>
            /// <para>Typically the views will define a View Transform and set the colorSpaceName to</para>
            /// <para>&quot;&lt;USE_DISPLAY_NAME&gt;&quot; so that it will use the display color space with the same name as the</para>
            /// <para>display, in this case corresponding to the ICC profile.</para>
            /// </remarks>
            public void AddVirtualDisplayView(string view, string viewTransformName, string colorSpaceName, string looks, string ruleName, string description)
            {
                __Internal.AddVirtualDisplayView(__Instance, view, viewTransformName, colorSpaceName, looks, ruleName, description);
            }

            public void AddVirtualDisplaySharedView(string sharedView)
            {
                __Internal.AddVirtualDisplaySharedView(__Instance, sharedView);
            }

            /// <summary>Get the number of views associated to the virtual display.</summary>
            public int GetVirtualDisplayNumViews(global::OpenColorIO.OpenColorIO_v2_4.ViewType type)
            {
                var ___ret = __Internal.GetVirtualDisplayNumViews(__Instance, type);
                return ___ret;
            }

            /// <summary>Get the view name at a specific index.</summary>
            public string GetVirtualDisplayView(global::OpenColorIO.OpenColorIO_v2_4.ViewType type, int index)
            {
                var ___ret = __Internal.GetVirtualDisplayView(__Instance, type, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetVirtualDisplayViewTransformName(string view)
            {
                var ___ret = __Internal.GetVirtualDisplayViewTransformName(__Instance, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetVirtualDisplayViewColorSpaceName(string view)
            {
                var ___ret = __Internal.GetVirtualDisplayViewColorSpaceName(__Instance, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetVirtualDisplayViewLooks(string view)
            {
                var ___ret = __Internal.GetVirtualDisplayViewLooks(__Instance, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetVirtualDisplayViewRule(string view)
            {
                var ___ret = __Internal.GetVirtualDisplayViewRule(__Instance, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetVirtualDisplayViewDescription(string view)
            {
                var ___ret = __Internal.GetVirtualDisplayViewDescription(__Instance, view);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Remove the view from the virtual display.</summary>
            public void RemoveVirtualDisplayView(string view)
            {
                __Internal.RemoveVirtualDisplayView(__Instance, view);
            }

            /// <summary>Clear the virtual display.</summary>
            public void ClearVirtualDisplay()
            {
                __Internal.ClearVirtualDisplay(__Instance);
            }

            /// <summary>Instantiate a new display from a virtual display, using the monitor name.</summary>
            /// <remarks>
            /// <para>This method uses the virtual display to create an actual display for the given monitorName.</para>
            /// <para>The new display will receive the views from the virtual display.</para>
            /// <para>After the ICC profile is read, a display name will be created by combining the description</para>
            /// <para>text from the profile with the monitorName obtained from the OS. Use the SystemMonitors class</para>
            /// <para>to obtain the list of monitorName strings for the displays connected to the computer.</para>
            /// <para>A new display color space will also be created using the display name. It will have a</para>
            /// <para>from_display_reference transform that is a FileTransform pointing to the ICC profile.</para>
            /// <para>Any instantiated display color spaces for a virtual display are intended to be temporary</para>
            /// <para>(i.e. last as long as the current session). By default, they are not saved when writing a</para>
            /// <para>config file. If there is a need to make it a permanent color space, it may be desirable to</para>
            /// <para>copy the ICC profile somewhere under the config search_path.</para>
            /// <para>Will throw if the config does not have a virtual display or if the monitorName does not exist.</para>
            /// <para>If there is already a display or a display color space with the name monitorName, it will be</para>
            /// <para>replaced/updated.</para>
            /// <para>Returns the index of the display.</para>
            /// </remarks>
            public int InstantiateDisplayFromMonitorName(string monitorName)
            {
                var ___ret = __Internal.InstantiateDisplayFromMonitorName(__Instance, monitorName);
                return ___ret;
            }

            /// <summary>Instantiate a new display from a virtual display, using an ICC profile.</summary>
            /// <remarks>
            /// <para>On platforms such as Linux, where the SystemMonitors class is not able to obtain a list of</para>
            /// <para>ICC profiles from the OS, this method may be used to manually specify a path to an ICC profile.</para>
            /// <para>Will throw if the virtual display definition is missing from the config.</para>
            /// <para>Returns the index of the display.</para>
            /// </remarks>
            public int InstantiateDisplayFromICCProfile(string ICCProfileFilepath)
            {
                var ___ret = __Internal.InstantiateDisplayFromICCProfile(__Instance, ICCProfileFilepath);
                return ___ret;
            }

            public string GetDisplayAll(int index)
            {
                var ___ret = __Internal.GetDisplayAll(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public int GetDisplayAllByName(string _0)
            {
                var ___ret = __Internal.GetDisplayAllByName(__Instance, _0);
                return ___ret;
            }

            /// <summary>
            /// <para>Will be true for a display that was instantiated from a virtual display. These displays are</para>
            /// <para>intended to be temporary (i.e. for the current session) and are not saved to a config file.</para>
            /// </summary>
            public bool IsDisplayTemporary(int index)
            {
                var ___ret = __Internal.IsDisplayTemporary(__Instance, index);
                return ___ret;
            }

            /// <summary>
            /// <para>Get either the shared or display-defined views for a display. The</para>
            /// <para>active_views list is ignored.  Passing a null or empty display (with type=VIEW_SHARED)</para>
            /// <para>returns the contents of the shared_views section of the config. Return 0 if display</para>
            /// <para>does not exist.</para>
            /// </summary>
            public int GetNumViews(global::OpenColorIO.OpenColorIO_v2_4.ViewType type, string display)
            {
                var ___ret = __Internal.GetNumViews_1(__Instance, type, display);
                return ___ret;
            }

            public string GetView(global::OpenColorIO.OpenColorIO_v2_4.ViewType type, string display, int index)
            {
                var ___ret = __Internal.GetView_1(__Instance, type, display, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the default coefficients for computing luma.</summary>
            /// <remarks>
            /// <para>There is no &quot;1 size fits all&quot; set of luma coefficients. (The</para>
            /// <para>values are typically different for each colorspace, and the</para>
            /// <para>application of them may be nonsensical depending on the</para>
            /// <para>intensity coding anyways). Thus, the 'right' answer is to make</para>
            /// <para>these functions on the ColorSpace class. However, it's</para>
            /// <para>often useful to have a config-wide default so here it is. We will</para>
            /// <para>add the colorspace specific luma call if/when another client is</para>
            /// <para>interesting in using it.</para>
            /// </remarks>
            public void GetDefaultLumaCoefs(ref double rgb)
            {
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    __Internal.GetDefaultLumaCoefs(__Instance, __arg0);
                }
            }

            /// <summary>These should be normalized (sum to 1.0 exactly).</summary>
            public void SetDefaultLumaCoefs(ref double rgb)
            {
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    __Internal.SetDefaultLumaCoefs(__Instance, __arg0);
                }
            }

            public string GetLookNameByIndex(int index)
            {
                var ___ret = __Internal.GetLookNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearLooks()
            {
                __Internal.ClearLooks(__Instance);
            }

            public string GetViewTransformNameByIndex(int i)
            {
                var ___ret = __Internal.GetViewTransformNameByIndex(__Instance, i);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearViewTransforms()
            {
                __Internal.ClearViewTransforms(__Instance);
            }

            /// <summary>Work on the named transforms selected by visibility.</summary>
            public int GetNumNamedTransforms(global::OpenColorIO.OpenColorIO_v2_4.NamedTransformVisibility visibility)
            {
                var ___ret = __Internal.GetNumNamedTransforms(__Instance, visibility);
                return ___ret;
            }

            /// <summary>Work on the named transforms selected by visibility (active or inactive).</summary>
            /// <remarks>Return an empty string for invalid index.</remarks>
            public string GetNamedTransformNameByIndex(global::OpenColorIO.OpenColorIO_v2_4.NamedTransformVisibility visibility, int index)
            {
                var ___ret = __Internal.GetNamedTransformNameByIndex(__Instance, visibility, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Work on the active named transforms only.</summary>
            public int GetNumNamedTransforms()
            {
                var ___ret = __Internal.GetNumNamedTransforms(__Instance);
                return ___ret;
            }

            /// <summary>Work on the active named transforms only and return an empty string for invalid index.</summary>
            public string GetNamedTransformNameByIndex(int index)
            {
                var ___ret = __Internal.GetNamedTransformNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get an index from the active named transforms only and return -1 if the name is not found.</summary>
            public int GetIndexForNamedTransform(string name)
            {
                var ___ret = __Internal.GetIndexForNamedTransform(__Instance, name);
                return ___ret;
            }

            /// <summary>Clear all named transforms.</summary>
            public void ClearNamedTransforms()
            {
                __Internal.ClearNamedTransforms(__Instance);
            }

            /// <summary>
            /// <para>Get the color space of the first rule that matched filePath. (For v1 configs, this is</para>
            /// <para>equivalent to calling parseColorSpaceFromString with strictparsing set to false.)</para>
            /// </summary>
            public string GetColorSpaceFromFilepath(string filePath)
            {
                var ___ret = __Internal.GetColorSpaceFromFilepath(__Instance, filePath);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Most applications will use the preceding method, but this method may be</para>
            /// <para>used for applications that want to know which was the highest priority rule to match</para>
            /// <para>filePath.and custom keys methods</para>
            /// <para>may then be used to get additional information about the matching rule.</para>
            /// </summary>
            public string GetColorSpaceFromFilepath(string filePath, ref ulong ruleIndex)
            {
                fixed (ulong* __ruleIndex1 = &ruleIndex)
                {
                    var __arg1 = __ruleIndex1;
                    var ___ret = __Internal.GetColorSpaceFromFilepath(__Instance, filePath, __arg1);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            /// <summary>
            /// <para>Returns true if the only rule matched by filePath is the default rule.</para>
            /// <para>This is a convenience method for applications that want to require the user to manually</para>
            /// <para>choose a color space when strictParsing is true and no other rules match.</para>
            /// </summary>
            public bool FilepathOnlyMatchesDefaultRule(string filePath)
            {
                var ___ret = __Internal.FilepathOnlyMatchesDefaultRule(__Instance, filePath);
                return ___ret;
            }

            /// <summary>
            /// <para>Given the specified string, get the longest, right-most, colorspace substring that</para>
            /// <para>appears.</para>
            /// </summary>
            /// <remarks>
            /// <para>* If strict parsing is enabled, and no color space is found, return</para>
            /// <para>an empty string.</para>
            /// <para>* If strict parsing is disabled, return ROLE_DEFAULT (if defined).</para>
            /// <para>* If the default role is not defined, return an empty string.</para>
            /// </remarks>
            public string ParseColorSpaceFromString(string str)
            {
                var ___ret = __Internal.ParseColorSpaceFromString(__Instance, str);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Clears this config's cache of Processor, CPUProcessor, and GPUProcessor instances.</summary>
            /// <remarks>
            /// <para>This must be done if any of the LUT files used by these Processors have been modified.</para>
            /// <para>Note that setProcessorCacheFlags(PROCESSOR_CACHE_OFF) turns off caching but does not clear</para>
            /// <para>any existing cache.</para>
            /// </remarks>
            public void ClearProcessorCache()
            {
                __Internal.ClearProcessorCache(__Instance);
            }

            /// <summary>Get the configuration major version.</summary>
            /// <remarks>
            /// <para>Set the configuration major version.</para>
            /// <para>Throws if it is not supported. Resets minor to the most recent minor for the given major.</para>
            /// </remarks>
            public uint MajorVersion
            {
                get
                {
                    var ___ret = __Internal.GetMajorVersion(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMajorVersion(__Instance, value);
                }
            }

            /// <summary>Get the configuration minor version.</summary>
            /// <remarks>Set the configuration minor version. Throws if it is not supported for the current major.</remarks>
            public uint MinorVersion
            {
                get
                {
                    var ___ret = __Internal.GetMinorVersion(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetMinorVersion(__Instance, value);
                }
            }

            /// <summary>Get/set a name string for the config.</summary>
            /// <remarks>
            /// <para>The name string may be used to communicate config update details or similar information</para>
            /// <para>to workflows external to OCIO in cases where the config path/filename itself does not</para>
            /// <para>provide adequate information.</para>
            /// </remarks>
            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetName(__Instance, value);
                }
            }

            /// <summary>Get the family separator</summary>
            /// <remarks>
            /// <para>A single character used to separate the family string into tokens for use in hierarchical</para>
            /// <para>menus.  Defaults to '/'.</para>
            /// <para>Set the family separator</para>
            /// <para>Succeeds if the characters is null or a valid character from the ASCII table i.e. from</para>
            /// <para>value 32 (i.e. space) to 126 (i.e. '~'); otherwise, it throws an exception.</para>
            /// </remarks>
            public sbyte FamilySeparator
            {
                get
                {
                    var ___ret = __Internal.GetFamilySeparator(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFamilySeparator(__Instance, value);
                }
            }

            /// <summary>Get the default family separator i.e. '/' .</summary>
            public static sbyte DefaultFamilySeparator
            {
                get
                {
                    var ___ret = __Internal.GetDefaultFamilySeparator();
                    return ___ret;
                }
            }

            public string Description
            {
                get
                {
                    var ___ret = __Internal.GetDescription(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDescription(__Instance, value);
                }
            }

            /// <summary>
            /// <para>This will produce a hash of the all colorspace definitions, etc. All external references,</para>
            /// <para>such as files used in FileTransforms, etc., will be incorporated into the cacheID. While</para>
            /// <para>the contents of the files are not read, the file system is queried for relevant information</para>
            /// <para>(mtime, inode) so that the config's cacheID will change when the underlying luts are updated.</para>
            /// </summary>
            /// <remarks>
            /// <para>If a context is not provided, the current Context will be used.</para>
            /// <para>If a null context is provided, file references will not be taken into</para>
            /// <para>account (this is essentially a hash of Config::serialize).</para>
            /// </remarks>
            public string CacheID
            {
                get
                {
                    var ___ret = __Internal.GetCacheID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public int NumEnvironmentVars
            {
                get
                {
                    var ___ret = __Internal.GetNumEnvironmentVars(__Instance);
                    return ___ret;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode EnvironmentMode
            {
                get
                {
                    var ___ret = __Internal.GetEnvironmentMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetEnvironmentMode(__Instance, value);
                }
            }

            public string SearchPath
            {
                get
                {
                    var ___ret = __Internal.GetSearchPath(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSearchPath(__Instance, value);
                }
            }

            public int NumSearchPaths
            {
                get
                {
                    var ___ret = __Internal.GetNumSearchPaths(__Instance);
                    return ___ret;
                }
            }

            public string WorkingDir
            {
                get
                {
                    var ___ret = __Internal.GetWorkingDir(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetWorkingDir(__Instance, value);
                }
            }

            public string InactiveColorSpaces
            {
                get
                {
                    var ___ret = __Internal.GetInactiveColorSpaces(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetInactiveColorSpaces(__Instance, value);
                }
            }

            public int NumRoles
            {
                get
                {
                    var ___ret = __Internal.GetNumRoles(__Instance);
                    return ___ret;
                }
            }

            public string DefaultDisplay
            {
                get
                {
                    var ___ret = __Internal.GetDefaultDisplay(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public int NumDisplays
            {
                get
                {
                    var ___ret = __Internal.GetNumDisplays(__Instance);
                    return ___ret;
                }
            }

            public string ActiveDisplays
            {
                get
                {
                    var ___ret = __Internal.GetActiveDisplays(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetActiveDisplays(__Instance, value);
                }
            }

            public string ActiveViews
            {
                get
                {
                    var ___ret = __Internal.GetActiveViews(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetActiveViews(__Instance, value);
                }
            }

            /// <summary>Get all displays in the config, ignoring the active_displays list.</summary>
            public int NumDisplaysAll
            {
                get
                {
                    var ___ret = __Internal.GetNumDisplaysAll(__Instance);
                    return ___ret;
                }
            }

            public int NumLooks
            {
                get
                {
                    var ___ret = __Internal.GetNumLooks(__Instance);
                    return ___ret;
                }
            }

            public int NumViewTransforms
            {
                get
                {
                    var ___ret = __Internal.GetNumViewTransforms(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get or set the default_view_transform string from the config.</summary>
            /// <remarks>
            /// <para>Note that if this is not the name of a valid view transform from the scene-referred</para>
            /// <para>connection space, it will be ignored.</para>
            /// </remarks>
            public string DefaultViewTransformName
            {
                get
                {
                    var ___ret = __Internal.GetDefaultViewTransformName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDefaultViewTransformName(__Instance, value);
                }
            }

            public bool StrictParsingEnabled
            {
                get
                {
                    var ___ret = __Internal.IsStrictParsingEnabled(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStrictParsingEnabled(__Instance, value);
                }
            }

            /// <summary>Get the Processor Cache flags.</summary>
            /// <remarks>
            /// <para>Control the caching of processors in the config instance.  By default, caching is on.</para>
            /// <para>The flags allow turning caching off entirely or only turning it off if dynamic</para>
            /// <para>properties are being used by the processor.</para>
            /// </remarks>
            public global::OpenColorIO.OpenColorIO_v2_4.ProcessorCacheFlags ProcessorCacheFlags
            {
                get
                {
                    var ___ret = __Internal.GetProcessorCacheFlags(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetProcessorCacheFlags(__Instance, value);
                }
            }

            /// <summary>Verify if the config is archivable.</summary>
            /// <returns>bool Archivable if true.</returns>
            /// <remarks>
            /// <para>A config is not archivable if any of the following are true:</para>
            /// <para>-- The working directory is not set</para>
            /// <para>-- It contains FileTransforms with a src outside the working directory</para>
            /// <para>-- The search path contains paths outside the working directory</para>
            /// <para>-- The search path contains paths that start with a context variable</para>
            /// <para>Context variables are allowed but the intent is that they may only resolve to paths that</para>
            /// <para>are within or below the working directory.  This is because the archiving function will</para>
            /// <para>only archive files that are within the working directory in order to ensure that if it is</para>
            /// <para>later expanded, that it will not create any files outside this directory.</para>
            /// <para>For example, a context variable on the search path intended to contain the name of a</para>
            /// <para>sub-directory under the working directory must have the form &quot;./$DIR_NAME&quot; rather than just</para>
            /// <para>&quot;$DIR_NAME&quot; to be considered archivable.  This is imperfect since there is no way to</para>
            /// <para>prevent the context variable from creating a path outside the working dir, but it should</para>
            /// <para>at least draw attention to the fact that the archive would fail if used with context vars</para>
            /// <para>that try to abuse the intended functionality.</para>
            /// </remarks>
            public bool IsArchivable
            {
                get
                {
                    var ___ret = __Internal.IsArchivable(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The File Rules are a set of filepath to color space mappings that are evaluated</para>
        /// <para>from first to last. The first rule to match is what determines which color space is</para>
        /// <para>returned. There are four types of rules available. Each rule type has a name key that may</para>
        /// <para>be used by applications to refer to that rule. Name values must be unique i.e. using a</para>
        /// <para>case insensitive comparison. The other keys depend on the rule type:</para>
        /// </summary>
        /// <remarks>
        /// <para>* *Basic Rule*: This is the basic rule type that uses Unix glob style pattern matching and</para>
        /// <para>is thus very easy to use. It contains the keys:</para>
        /// <para>* name: Name of the rule</para>
        /// <para>* colorspace: Color space name to be returned.</para>
        /// <para>* pattern: Glob pattern to be used for the main part of the name/path.</para>
        /// <para>* extension: Glob pattern to be used for the file extension. Note that if glob tokens</para>
        /// <para>are not used, the extension will be used in a non-case-sensitive way by default.</para>
        /// <para>* *Regex Rule*: This is similar to the basic rule but allows additional capabilities for</para>
        /// <para>power-users. It contains the keys:</para>
        /// <para>* name: Name of the rule</para>
        /// <para>* colorspace: Color space name to be returned.</para>
        /// <para>* regex: Regular expression to be evaluated.</para>
        /// <para>* *OCIO v1 style Rule*: This rule allows the use of the OCIO v1 style, where the string</para>
        /// <para>is searched for color space names from the config. This rule may occur 0 or 1 times</para>
        /// <para>in the list. The position in the list prioritizes it with respect to the other rules.</para>
        /// <para>StrictParsing is not used. If no color space is found in the path, the rule will not</para>
        /// <para>match and the next rule will be considered.</para>
        /// <para>seeIt has the key:</para>
        /// <para>* name: Must be &quot;ColorSpaceNamePathSearch&quot;.</para>
        /// <para>* *Default Rule*: The file_rules must always end with this rule. If no prior rules match,</para>
        /// <para>this rule specifies the color space applications will use.</para>
        /// <para>seeIt has the keys:</para>
        /// <para>* name: must be &quot;Default&quot;.</para>
        /// <para>* colorspace : Color space name to be returned.</para>
        /// <para>Custom string keys and associated string values may be used to convey app or</para>
        /// <para>workflow-specific information, e.g. whether the color space should be left as is</para>
        /// <para>or converted into a working space.</para>
        /// <para>Getters and setters are using the rule position, they will throw if the position is not</para>
        /// <para>valid. If the rule at the specified position does not implement the requested property</para>
        /// <para>getter will return NULL and setter will throw.</para>
        /// <para>When loading a v1 config, a set of FileRules are created with ColorSpaceNamePathSearch followed</para>
        /// <para>by the Default rule pointing to the default role. This allows getColorSpaceFromFilepath to emulate</para>
        /// <para>OCIO v1 code that used parseColorSpaceFromString with strictparsing set to false.</para>
        /// </remarks>
        public unsafe partial class FileRules : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_FileRules;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getIndexForRule@FileRules@OpenColorIO_v2_4@@QEBA_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetIndexForRule(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getPattern@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPattern(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setPattern@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPattern(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pattern);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getExtension@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetExtension(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setExtension@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetExtension(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string extension);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getRegex@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRegex(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setRegex@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRegex(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string regex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpace@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpace(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setColorSpace@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColorSpace(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumCustomKeys@FileRules@OpenColorIO_v2_4@@QEBA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumCustomKeys(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCustomKeyName@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCustomKeyName(__IntPtr __instance, ulong ruleIndex, ulong key);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCustomKeyValue@FileRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCustomKeyValue(__IntPtr __instance, ulong ruleIndex, ulong key);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setCustomKey@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCustomKey(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?insertRule@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD111@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertRule(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pattern, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string extension);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?insertRule@FileRules@OpenColorIO_v2_4@@QEAAX_KPEBD11@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertRule(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string regex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?insertPathSearchRule@FileRules@OpenColorIO_v2_4@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertPathSearchRule(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDefaultRuleColorSpace@FileRules@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDefaultRuleColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeRule@FileRules@OpenColorIO_v2_4@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveRule(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?increaseRulePriority@FileRules@OpenColorIO_v2_4@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void IncreaseRulePriority(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?decreaseRulePriority@FileRules@OpenColorIO_v2_4@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DecreaseRulePriority(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumEntries@FileRules@OpenColorIO_v2_4@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumEntries(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isDefault@FileRules@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDefault(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.FileRules> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.FileRules>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.FileRules managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.FileRules managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static FileRules __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new FileRules(native.ToPointer(), skipVTables);
            }

            internal static FileRules __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (FileRules)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static FileRules __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (FileRules)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static FileRules __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FileRules(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FileRules(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected FileRules(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the index from the rule name.</summary>
            public ulong GetIndexForRule(string ruleName)
            {
                var ___ret = __Internal.GetIndexForRule(__Instance, ruleName);
                return ___ret;
            }

            /// <summary>Get name of the rule.</summary>
            public string GetName(ulong ruleIndex)
            {
                var ___ret = __Internal.GetName(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Setting pattern will erase regex.</summary>
            public string GetPattern(ulong ruleIndex)
            {
                var ___ret = __Internal.GetPattern(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void SetPattern(ulong ruleIndex, string pattern)
            {
                __Internal.SetPattern(__Instance, ruleIndex, pattern);
            }

            /// <summary>Setting extension will erase regex.</summary>
            public string GetExtension(ulong ruleIndex)
            {
                var ___ret = __Internal.GetExtension(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void SetExtension(ulong ruleIndex, string extension)
            {
                __Internal.SetExtension(__Instance, ruleIndex, extension);
            }

            /// <summary>Setting a regex will erase pattern&amp;extension.</summary>
            public string GetRegex(ulong ruleIndex)
            {
                var ___ret = __Internal.GetRegex(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void SetRegex(ulong ruleIndex, string regex)
            {
                __Internal.SetRegex(__Instance, ruleIndex, regex);
            }

            /// <summary>Set the rule's color space (may also be a role).</summary>
            public string GetColorSpace(ulong ruleIndex)
            {
                var ___ret = __Internal.GetColorSpace(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void SetColorSpace(ulong ruleIndex, string colorSpace)
            {
                __Internal.SetColorSpace(__Instance, ruleIndex, colorSpace);
            }

            /// <summary>Get number of key/value pairs.</summary>
            public ulong GetNumCustomKeys(ulong ruleIndex)
            {
                var ___ret = __Internal.GetNumCustomKeys(__Instance, ruleIndex);
                return ___ret;
            }

            /// <summary>Get name of key.</summary>
            public string GetCustomKeyName(ulong ruleIndex, ulong key)
            {
                var ___ret = __Internal.GetCustomKeyName(__Instance, ruleIndex, key);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get value for the key.</summary>
            public string GetCustomKeyValue(ulong ruleIndex, ulong key)
            {
                var ___ret = __Internal.GetCustomKeyValue(__Instance, ruleIndex, key);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Adds a key/value or replace value if key exists. Setting a NULL or an</para>
            /// <para>empty value will erase the key.</para>
            /// </summary>
            public void SetCustomKey(ulong ruleIndex, string key, string value)
            {
                __Internal.SetCustomKey(__Instance, ruleIndex, key, value);
            }

            /// <summary>Insert a rule at a given ruleIndex.</summary>
            /// <remarks>
            /// <para>Rule currently at ruleIndex will be pushed to index: ruleIndex + 1.</para>
            /// <para>Name must be unique.</para>
            /// <para>- &quot;Default&quot; is a reserved name for the default rule. The default rule is automatically</para>
            /// <para>added and can't be removed. (see).</para>
            /// <para>- &quot;ColorSpaceNamePathSearch&quot; is also a reserved name</para>
            /// <para>(see).</para>
            /// <para>Will throw if pattern, extension or regex is a null or empty string.</para>
            /// <para>Will throw if ruleIndex is not less than.</para>
            /// </remarks>
            public void InsertRule(ulong ruleIndex, string name, string colorSpace, string pattern, string extension)
            {
                __Internal.InsertRule(__Instance, ruleIndex, name, colorSpace, pattern, extension);
            }

            public void InsertRule(ulong ruleIndex, string name, string colorSpace, string regex)
            {
                __Internal.InsertRule(__Instance, ruleIndex, name, colorSpace, regex);
            }

            /// <summary>Helper function to insert a rule.</summary>
            /// <remarks>
            /// <para>Usesto search the path for any of</para>
            /// <para>the color spaces named in the config (as per OCIO v1).</para>
            /// </remarks>
            public void InsertPathSearchRule(ulong ruleIndex)
            {
                __Internal.InsertPathSearchRule(__Instance, ruleIndex);
            }

            /// <summary>Helper function to set the color space for the default rule.</summary>
            public void SetDefaultRuleColorSpace(string colorSpace)
            {
                __Internal.SetDefaultRuleColorSpace(__Instance, colorSpace);
            }

            /// <remarks>
            /// <para>Default rule can't be removed.</para>
            /// <para>Will throw if ruleIndex + 1 is not less than.</para>
            /// </remarks>
            public void RemoveRule(ulong ruleIndex)
            {
                __Internal.RemoveRule(__Instance, ruleIndex);
            }

            /// <summary>Move a rule closer to the start of the list by one position.</summary>
            public void IncreaseRulePriority(ulong ruleIndex)
            {
                __Internal.IncreaseRulePriority(__Instance, ruleIndex);
            }

            /// <summary>Move a rule closer to the end of the list by one position.</summary>
            public void DecreaseRulePriority(ulong ruleIndex)
            {
                __Internal.DecreaseRulePriority(__Instance, ruleIndex);
            }

            /// <summary>Reserved rule name for the default rule.</summary>
            public static string DefaultRuleName
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._DefaultRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._DefaultRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>Reserved rule name for the file path search rule</summary>
            /// <remarks>FileRules::insertPathSearchRule.</remarks>
            public static string FilePathSearchRuleName
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._FilePathSearchRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._FilePathSearchRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>Does include default rule. Result will be at least 1.</summary>
            public ulong NumEntries
            {
                get
                {
                    var ___ret = __Internal.GetNumEntries(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Check if there is only the default rule using default role and no custom key. This is the</para>
            /// <para>default FileRules state when creating a new config.</para>
            /// </summary>
            public bool IsDefault
            {
                get
                {
                    var ___ret = __Internal.IsDefault(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~FileRules()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileRules.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>ViewingRules</summary>
        /// <remarks>
        /// <para>Viewing Rules allow config authors to filter the list of views an application should offer</para>
        /// <para>based on the color space of an image.  For example, a config may define a large number of</para>
        /// <para>views but not all of them may be appropriate for use with all color spaces.  E.g., some views</para>
        /// <para>may be intended for use with scene-linear color space encodings and others with video color</para>
        /// <para>space encodings.</para>
        /// <para>Each rule has a name key for applications to refer to the rule.  Name values must be unique</para>
        /// <para>(using case insensitive comparison). Viewing Rules may also have the following keys:</para>
        /// <para>* colorspaces: Either a single colorspace name or a list of names.</para>
        /// <para>* encodings: One or more strings to be found in the colorspace's encoding attribute.</para>
        /// <para>Either this attribute or colorspaces must be present, but not both.</para>
        /// <para>* custom : Allows arbitrary key / value string pairs, similar to FileRules.</para>
        /// <para>Getters and setters are using the rule position, they will throw if the position is not</para>
        /// <para>valid.</para>
        /// </remarks>
        public unsafe partial class ViewingRules : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_ViewingRules;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getIndexForRule@ViewingRules@OpenColorIO_v2_4@@QEBA_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetIndexForRule(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@ViewingRules@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumColorSpaces@ViewingRules@OpenColorIO_v2_4@@QEBA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumColorSpaces(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpace@ViewingRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpace(__IntPtr __instance, ulong ruleIndex, ulong colorSpaceIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addColorSpace@ViewingRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddColorSpace(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string colorSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeColorSpace@ViewingRules@OpenColorIO_v2_4@@QEAAX_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveColorSpace(__IntPtr __instance, ulong ruleIndex, ulong colorSpaceIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumEncodings@ViewingRules@OpenColorIO_v2_4@@QEBA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumEncodings(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEncoding@ViewingRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEncoding(__IntPtr __instance, ulong ruleIndex, ulong encodingIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addEncoding@ViewingRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEncoding(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string encoding);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeEncoding@ViewingRules@OpenColorIO_v2_4@@QEAAX_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveEncoding(__IntPtr __instance, ulong ruleIndex, ulong encodingIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumCustomKeys@ViewingRules@OpenColorIO_v2_4@@QEBA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumCustomKeys(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCustomKeyName@ViewingRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCustomKeyName(__IntPtr __instance, ulong ruleIndex, ulong keyIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCustomKeyValue@ViewingRules@OpenColorIO_v2_4@@QEBAPEBD_K0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCustomKeyValue(__IntPtr __instance, ulong ruleIndex, ulong keyIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setCustomKey@ViewingRules@OpenColorIO_v2_4@@QEAAX_KPEBD1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCustomKey(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?insertRule@ViewingRules@OpenColorIO_v2_4@@QEAAX_KPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertRule(__IntPtr __instance, ulong ruleIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ruleName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeRule@ViewingRules@OpenColorIO_v2_4@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveRule(__IntPtr __instance, ulong ruleIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumEntries@ViewingRules@OpenColorIO_v2_4@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumEntries(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ViewingRules> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ViewingRules>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ViewingRules managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ViewingRules managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ViewingRules __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ViewingRules(native.ToPointer(), skipVTables);
            }

            internal static ViewingRules __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ViewingRules)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ViewingRules __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ViewingRules)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ViewingRules __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ViewingRules(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ViewingRules(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ViewingRules(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get the index from the rule name. Will throw if there is no rule named</para>
            /// <para>ruleName.</para>
            /// </summary>
            public ulong GetIndexForRule(string ruleName)
            {
                var ___ret = __Internal.GetIndexForRule(__Instance, ruleName);
                return ___ret;
            }

            /// <summary>Get name of the rule. Will throw if ruleIndex is invalid.</summary>
            public string GetName(ulong ruleIndex)
            {
                var ___ret = __Internal.GetName(__Instance, ruleIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get number of colorspaces. Will throw if ruleIndex is invalid.</summary>
            public ulong GetNumColorSpaces(ulong ruleIndex)
            {
                var ___ret = __Internal.GetNumColorSpaces(__Instance, ruleIndex);
                return ___ret;
            }

            /// <summary>Get colorspace name. Will throw if ruleIndex or colorSpaceIndex is invalid.</summary>
            public string GetColorSpace(ulong ruleIndex, ulong colorSpaceIndex)
            {
                var ___ret = __Internal.GetColorSpace(__Instance, ruleIndex, colorSpaceIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Add colorspace name. Will throw if:</para>
            /// <para>* RuleIndex is invalid.</para>
            /// <para>*is not 0.</para>
            /// </summary>
            public void AddColorSpace(ulong ruleIndex, string colorSpace)
            {
                __Internal.AddColorSpace(__Instance, ruleIndex, colorSpace);
            }

            /// <summary>Remove colorspace. Will throw if ruleIndex or colorSpaceIndex is invalid.</summary>
            public void RemoveColorSpace(ulong ruleIndex, ulong colorSpaceIndex)
            {
                __Internal.RemoveColorSpace(__Instance, ruleIndex, colorSpaceIndex);
            }

            /// <summary>Get number of encodings. Will throw if ruleIndex is invalid.</summary>
            public ulong GetNumEncodings(ulong ruleIndex)
            {
                var ___ret = __Internal.GetNumEncodings(__Instance, ruleIndex);
                return ___ret;
            }

            /// <summary>Get encoding name. Will throw if ruleIndex or encodingIndex is invalid.</summary>
            public string GetEncoding(ulong ruleIndex, ulong encodingIndex)
            {
                var ___ret = __Internal.GetEncoding(__Instance, ruleIndex, encodingIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Add encoding name. Will throw if:</para>
            /// <para>* RuleIndex is invalid.</para>
            /// <para>*is not 0.</para>
            /// </summary>
            public void AddEncoding(ulong ruleIndex, string encoding)
            {
                __Internal.AddEncoding(__Instance, ruleIndex, encoding);
            }

            /// <summary>Remove encoding. Will throw if ruleIndex or encodingIndex is invalid.</summary>
            public void RemoveEncoding(ulong ruleIndex, ulong encodingIndex)
            {
                __Internal.RemoveEncoding(__Instance, ruleIndex, encodingIndex);
            }

            /// <summary>Get number of key/value pairs. Will throw if ruleIndex is invalid.</summary>
            public ulong GetNumCustomKeys(ulong ruleIndex)
            {
                var ___ret = __Internal.GetNumCustomKeys(__Instance, ruleIndex);
                return ___ret;
            }

            /// <summary>Get name of key. Will throw if ruleIndex or keyIndex is invalid.</summary>
            public string GetCustomKeyName(ulong ruleIndex, ulong keyIndex)
            {
                var ___ret = __Internal.GetCustomKeyName(__Instance, ruleIndex, keyIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get value for the key. Will throw if ruleIndex or keyIndex is invalid.</summary>
            public string GetCustomKeyValue(ulong ruleIndex, ulong keyIndex)
            {
                var ___ret = __Internal.GetCustomKeyValue(__Instance, ruleIndex, keyIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Adds a key/value or replace value if key exists. Setting a NULL or an</para>
            /// <para>empty value will erase the key. Will throw if ruleIndex is invalid.</para>
            /// </summary>
            public void SetCustomKey(ulong ruleIndex, string key, string value)
            {
                __Internal.SetCustomKey(__Instance, ruleIndex, key, value);
            }

            /// <summary>Insert a rule at a given ruleIndex.</summary>
            /// <remarks>
            /// <para>Rule currently at ruleIndex will be pushed to index: ruleIndex + 1. If ruleIndex is</para>
            /// <para>a new rule will be added at the end. Will throw if:</para>
            /// <para>* RuleIndex is invalid (must be less than or equal to</para>
            /// <para>* RuleName already exists.</para>
            /// </remarks>
            public void InsertRule(ulong ruleIndex, string ruleName)
            {
                __Internal.InsertRule(__Instance, ruleIndex, ruleName);
            }

            /// <summary>Remove a rule. Throws if ruleIndex is not valid.</summary>
            public void RemoveRule(ulong ruleIndex)
            {
                __Internal.RemoveRule(__Instance, ruleIndex);
            }

            public ulong NumEntries
            {
                get
                {
                    var ___ret = __Internal.GetNumEntries(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~ViewingRules()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ViewingRules.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>The *ColorSpace* is the state of an image with respect to colorimetry</para>
        /// <para>and color encoding. Transforming images between different</para>
        /// <para>*ColorSpaces* is the primary motivation for this library.</para>
        /// </summary>
        /// <remarks>
        /// <para>While a complete discussion of color spaces is beyond the scope of</para>
        /// <para>header documentation, traditional uses would be to have *ColorSpaces*</para>
        /// <para>corresponding to: physical capture devices (known cameras, scanners),</para>
        /// <para>and internal 'convenience' spaces (such as scene linear, logarithmic).</para>
        /// </remarks>
        public unsafe partial class ColorSpace : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1ColorSpace@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getAlias@ColorSpace@OpenColorIO_v2_4@@QEBAPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetAlias(__IntPtr __instance, ulong idx);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasAlias@ColorSpace@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAlias(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addAlias@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddAlias(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeAlias@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveAlias(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearAliases@ColorSpace@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAliases(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasCategory@ColorSpace@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addCategory@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeCategory@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCategory@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCategory(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearCategories@ColorSpace@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearCategories(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getAllocationVars@ColorSpace@OpenColorIO_v2_4@@QEBAXPEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetAllocationVars(__IntPtr __instance, float* vars);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setAllocationVars@ColorSpace@OpenColorIO_v2_4@@QEAAXHPEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAllocationVars(__IntPtr __instance, int numvars, float* vars);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setName@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumAliases@ColorSpace@OpenColorIO_v2_4@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetNumAliases(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFamily@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFamily(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setFamily@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFamily(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string family);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEqualityGroup@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEqualityGroup(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setEqualityGroup@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEqualityGroup(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string equalityGroup);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDescription@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDescription(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDescription@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getBitDepth@ColorSpace@OpenColorIO_v2_4@@QEBA?AW4BitDepth@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.BitDepth GetBitDepth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setBitDepth@ColorSpace@OpenColorIO_v2_4@@QEAAXW4BitDepth@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBitDepth(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getReferenceSpaceType@ColorSpace@OpenColorIO_v2_4@@QEBA?AW4ReferenceSpaceType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType GetReferenceSpaceType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumCategories@ColorSpace@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumCategories(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEncoding@ColorSpace@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEncoding(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setEncoding@ColorSpace@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEncoding(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string encoding);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isData@ColorSpace@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setIsData@ColorSpace@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIsData(__IntPtr __instance, bool isData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getAllocation@ColorSpace@OpenColorIO_v2_4@@QEBA?AW4Allocation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.Allocation GetAllocation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setAllocation@ColorSpace@OpenColorIO_v2_4@@QEAAXW4Allocation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAllocation(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Allocation allocation);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getAllocationNumVars@ColorSpace@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetAllocationNumVars(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpace> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpace>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ColorSpace managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ColorSpace managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ColorSpace __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ColorSpace(native.ToPointer(), skipVTables);
            }

            internal static ColorSpace __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ColorSpace)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ColorSpace __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ColorSpace(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ColorSpace(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ColorSpace(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Return empty string if idx is out of range.</summary>
            public string GetAlias(ulong idx)
            {
                var ___ret = __Internal.GetAlias(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Return true if alias exists.</summary>
            public bool HasAlias(string alias)
            {
                var ___ret = __Internal.HasAlias(__Instance, alias);
                return ___ret;
            }

            /// <summary>
            /// <para>Add an alias for the color space name (the aliases may be used as a synonym for the</para>
            /// <para>name).  Nothing will be added if the alias is already the color space name, one of its</para>
            /// <para>aliases, or the argument is null.  The aliases must not conflict with existing roles,</para>
            /// <para>color space names, named transform names, or other aliases.  This is verified when</para>
            /// <para>adding the color space to the config.</para>
            /// </summary>
            public void AddAlias(string alias)
            {
                __Internal.AddAlias(__Instance, alias);
            }

            /// <summary>Does nothing if alias is not present.</summary>
            public void RemoveAlias(string alias)
            {
                __Internal.RemoveAlias(__Instance, alias);
            }

            public void ClearAliases()
            {
                __Internal.ClearAliases(__Instance);
            }

            /// <summary>
            /// <para>A category is used to allow applications to filter the list of color spaces</para>
            /// <para>they display in menus based on what that color space is used for.</para>
            /// </summary>
            /// <remarks>
            /// <para>Here is an example config entry that could appear under a ColorSpace:</para>
            /// <para></para>
            /// <para>The example contains three categories: 'file-io', 'working-space' and 'basic-3d'.</para>
            /// <para>Category strings are not case-sensitive and the order is not significant.</para>
            /// <para>There is no limit imposed on length or number. Although users may add their own categories,</para>
            /// <para>the strings will typically come from a fixed set listed in the documentation (similar to</para>
            /// <para>roles).</para>
            /// <para>Return true if the category is present.</para>
            /// </remarks>
            public bool HasCategory(string category)
            {
                var ___ret = __Internal.HasCategory(__Instance, category);
                return ___ret;
            }

            /// <summary>Add a single category.</summary>
            /// <remarks>Will do nothing if the category already exists.</remarks>
            public void AddCategory(string category)
            {
                __Internal.AddCategory(__Instance, category);
            }

            /// <summary>Remove a category.</summary>
            /// <remarks>Will do nothing if the category is missing.</remarks>
            public void RemoveCategory(string category)
            {
                __Internal.RemoveCategory(__Instance, category);
            }

            /// <summary>Return the category name using its index</summary>
            /// <remarks>Will be null if the index is invalid.</remarks>
            public string GetCategory(int index)
            {
                var ___ret = __Internal.GetCategory(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Clear all the categories.</summary>
            public void ClearCategories()
            {
                __Internal.ClearCategories(__Instance);
            }

            public void GetAllocationVars(ref float vars)
            {
                fixed (float* __vars0 = &vars)
                {
                    var __arg0 = __vars0;
                    __Internal.GetAllocationVars(__Instance, __arg0);
                }
            }

            public void SetAllocationVars(int numvars, ref float vars)
            {
                fixed (float* __vars1 = &vars)
                {
                    var __arg1 = __vars1;
                    __Internal.SetAllocationVars(__Instance, numvars, __arg1);
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetName(__Instance, value);
                }
            }

            public ulong NumAliases
            {
                get
                {
                    var ___ret = __Internal.GetNumAliases(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Get the family, for use in user interfaces (optional)</para>
            /// <para>The family string could use a '/' separator to indicate levels to be used</para>
            /// <para>by hierarchical menus.</para>
            /// </summary>
            /// <remarks>Set the family, for use in user interfaces (optional)</remarks>
            public string Family
            {
                get
                {
                    var ___ret = __Internal.GetFamily(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetFamily(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Get the ColorSpace group name (used for equality comparisons)</para>
            /// <para>This allows no-op transforms between different colorspaces.</para>
            /// <para>If an equalityGroup is not defined (an empty string), it will be considered</para>
            /// <para>unique (i.e., it will not compare as equal to other ColorSpaces with an</para>
            /// <para>empty equality group).</para>
            /// </summary>
            public string EqualityGroup
            {
                get
                {
                    var ___ret = __Internal.GetEqualityGroup(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetEqualityGroup(__Instance, value);
                }
            }

            public string Description
            {
                get
                {
                    var ___ret = __Internal.GetDescription(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDescription(__Instance, value);
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepth
            {
                get
                {
                    var ___ret = __Internal.GetBitDepth(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBitDepth(__Instance, value);
                }
            }

            /// <summary>A display color space will use the display-referred reference space.</summary>
            public global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType ReferenceSpaceType
            {
                get
                {
                    var ___ret = __Internal.GetReferenceSpaceType(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of categories.</summary>
            public int NumCategories
            {
                get
                {
                    var ___ret = __Internal.GetNumCategories(__Instance);
                    return ___ret;
                }
            }

            /// <summary>*Encodings*</summary>
            /// <remarks>
            /// <para>It is sometimes useful for applications to group color spaces based on how the color values</para>
            /// <para>are digitally encoded.  For example, images in scene-linear, logarithmic, video, and data</para>
            /// <para>color spaces could have different default views.  Unlike the Family and EqualityGroup</para>
            /// <para>attributes of a color space, the list of Encodings is predefined in the OCIO documentation</para>
            /// <para>(rather than being config-specific) to make it easier for applications to utilize.</para>
            /// <para>Here is an example config entry that could appear under a ColorSpace:</para>
            /// <para>Encoding strings are not case-sensitive. Although users may add their own encodings, the</para>
            /// <para>strings will typically come from a fixed set listed in the documentation (similar to roles).</para>
            /// </remarks>
            public string Encoding
            {
                get
                {
                    var ___ret = __Internal.GetEncoding(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetEncoding(__Instance, value);
                }
            }

            /// <summary>*Data*</summary>
            /// <remarks>
            /// <para>ColorSpaces that are data are treated a bit special. Basically, any colorspace transforms</para>
            /// <para>you try to apply to them are ignored. (Think of applying a gamut mapping transform to an</para>
            /// <para>ID pass). However, the setDataBypass method on ColorSpaceTransform and DisplayViewTransform</para>
            /// <para>allow applications to process data when necessary.  (Think of sending mattes to an HDR</para>
            /// <para>monitor.)</para>
            /// <para>This is traditionally used for pixel data that represents non-color</para>
            /// <para>pixel data, such as normals, point positions, ID information, etc.</para>
            /// </remarks>
            public bool IsData
            {
                get
                {
                    var ___ret = __Internal.IsData(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIsData(__Instance, value);
                }
            }

            /// <summary>*Allocation*</summary>
            /// <remarks>
            /// <para>If this colorspace needs to be transferred to a limited dynamic</para>
            /// <para>range coding space (such as during display with a GPU path), use this</para>
            /// <para>allocation to maximize bit efficiency.</para>
            /// </remarks>
            public global::OpenColorIO.OpenColorIO_v2_4.Allocation Allocation
            {
                get
                {
                    var ___ret = __Internal.GetAllocation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAllocation(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Specify the optional variable values to configure the allocation.</para>
            /// <para>If no variables are specified, the defaults are used.</para>
            /// </summary>
            /// <remarks>
            /// <para>ALLOCATION_UNIFORM::</para>
            /// <para>2 vars: [min, max]</para>
            /// <para>ALLOCATION_LG2::</para>
            /// <para>2 vars: [lg2min, lg2max]</para>
            /// <para>3 vars: [lg2min, lg2max, linear_offset]</para>
            /// </remarks>
            public int AllocationNumVars
            {
                get
                {
                    var ___ret = __Internal.GetAllocationNumVars(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The *ColorSpaceSet* is a set of color spaces (i.e. no color space duplication)</para>
        /// <para>which could be the result ofor built from scratch.</para>
        /// </summary>
        /// <remarks>
        /// <para>The color spaces are decoupled from the config ones, i.e., any</para>
        /// <para>changes to the set itself or to its color spaces do not affect the</para>
        /// <para>original color spaces from the configuration.  If needed,</para>
        /// <para>useto update the configuration.</para>
        /// </remarks>
        public unsafe partial class ColorSpaceSet : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1ColorSpaceSet@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8ColorSpaceSet@OpenColorIO_v2_4@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr css);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9ColorSpaceSet@OpenColorIO_v2_4@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr css);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceNameByIndex@ColorSpaceSet@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetColorSpaceNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getColorSpaceIndex@ColorSpaceSet@OpenColorIO_v2_4@@QEBAHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetColorSpaceIndex(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasColorSpace@ColorSpaceSet@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeColorSpace@ColorSpaceSet@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveColorSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearColorSpaces@ColorSpaceSet@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearColorSpaces(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumColorSpaces@ColorSpaceSet@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumColorSpaces(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ColorSpaceSet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ColorSpaceSet(native.ToPointer(), skipVTables);
            }

            internal static ColorSpaceSet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ColorSpaceSet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ColorSpaceSet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ColorSpaceSet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ColorSpaceSet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ColorSpaceSet(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Return true if the two sets are equal.</summary>
            /// <remarks>The comparison is done on the color space names (not a deep comparison).</remarks>
            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet __op, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet css)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool cssNull = ReferenceEquals(css, null);
                if (__opNull || cssNull)
                    return __opNull && cssNull;
                var __arg0 = __op.__Instance;
                var __arg1 = css.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Return true if the two sets are different.</summary>
            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet __op, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceSet css)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool cssNull = ReferenceEquals(css, null);
                if (__opNull || cssNull)
                    return !(__opNull && cssNull);
                var __arg0 = __op.__Instance;
                var __arg1 = css.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>
            /// <para>Return the color space name using its index.</para>
            /// <para>This will be null if an invalid index is specified.</para>
            /// </summary>
            public string GetColorSpaceNameByIndex(int index)
            {
                var ___ret = __Internal.GetColorSpaceNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Will return -1 if the name is not found.</summary>
            /// <remarks>Only accepts color space names (i.e. no role name).</remarks>
            public int GetColorSpaceIndex(string name)
            {
                var ___ret = __Internal.GetColorSpaceIndex(__Instance, name);
                return ___ret;
            }

            /// <returns>true</returns>
            /// <returns>false</returns>
            /// <remarks>Only accepts color space names (i.e. no role name)</remarks>
            public bool HasColorSpace(string name)
            {
                var ___ret = __Internal.HasColorSpace(__Instance, name);
                return ___ret;
            }

            /// <summary>Remove color space(s) using color space names (i.e. no role name).</summary>
            /// <remarks>The removal of a missing color space does nothing.</remarks>
            public void RemoveColorSpace(string name)
            {
                __Internal.RemoveColorSpace(__Instance, name);
            }

            /// <summary>Clear all color spaces.</summary>
            public void ClearColorSpaces()
            {
                __Internal.ClearColorSpaces(__Instance);
            }

            /// <summary>Return the number of color spaces.</summary>
            public int NumColorSpaces
            {
                get
                {
                    var ___ret = __Internal.GetNumColorSpaces(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The *Look* is an 'artistic' image modification, in a specified image</para>
        /// <para>state.</para>
        /// <para>The processSpace defines the ColorSpace the image is required to be</para>
        /// <para>in, for the math to apply correctly.</para>
        /// </summary>
        public unsafe partial class Look : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1Look@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@Look@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setName@Look@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getProcessSpace@Look@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetProcessSpace(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setProcessSpace@Look@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProcessSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string processSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDescription@Look@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDescription(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDescription@Look@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Look> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Look>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Look managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Look managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Look __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Look(native.ToPointer(), skipVTables);
            }

            internal static Look __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Look)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Look __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Look(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Look(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Look(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetName(__Instance, value);
                }
            }

            public string ProcessSpace
            {
                get
                {
                    var ___ret = __Internal.GetProcessSpace(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetProcessSpace(__Instance, value);
                }
            }

            public string Description
            {
                get
                {
                    var ___ret = __Internal.GetDescription(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDescription(__Instance, value);
                }
            }
        }

        /// <summary>NamedTransform.</summary>
        /// <remarks>
        /// <para>A NamedTransform provides a way for config authors to include a set of color</para>
        /// <para>transforms that are independent of the color space being processed.  For example a &quot;utility</para>
        /// <para>curve&quot; transform where there is no need to convert to or from a reference space.</para>
        /// </remarks>
        public unsafe abstract partial class NamedTransform : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_NamedTransform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0NamedTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.NamedTransform> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.NamedTransform>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.NamedTransform managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.NamedTransform managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static NamedTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new NamedTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static NamedTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (NamedTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static NamedTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (NamedTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static NamedTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new NamedTransformInternal(native, skipVTables);
            }

            protected NamedTransform(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected NamedTransform()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.NamedTransform");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Return empty string if idx is  out of range.</summary>
            public abstract string GetAlias(ulong idx);

            /// <summary>Return true if alias exists.</summary>
            public abstract bool HasAlias(string alias);

            /// <summary>
            /// <para>Nothing is done if alias is NULL or empty, if it is already there, or if it is already</para>
            /// <para>the named transform name.</para>
            /// </summary>
            public abstract void AddAlias(string alias);

            /// <summary>Does nothing if alias is not present.</summary>
            public abstract void RemoveAlias(string alias);

            public abstract void ClearAliases();

            /// <remarks>ColorSpace::hasCategory</remarks>
            public abstract bool HasCategory(string category);

            /// <remarks>ColorSpace::addCategory</remarks>
            public abstract void AddCategory(string category);

            /// <remarks>ColorSpace::removeCategory</remarks>
            public abstract void RemoveCategory(string category);

            /// <remarks>ColorSpace::getCategory</remarks>
            public abstract string GetCategory(int index);

            /// <remarks>ColorSpace::clearCategories</remarks>
            public abstract void ClearCategories();

            public abstract string Name
            {
                get;

                set;
            }

            /// <summary>Aliases can be used instead of the name. They must be unique within the config.</summary>
            public abstract ulong NumAliases
            {
                get;
            }

            /// <remarks>
            /// <para>ColorSpace::getFamily</para>
            /// <para>ColorSpace::setFamily</para>
            /// </remarks>
            public abstract string Family
            {
                get;

                set;
            }

            public abstract string Description
            {
                get;

                set;
            }

            /// <remarks>ColorSpace::getNumCategories</remarks>
            public abstract int NumCategories
            {
                get;
            }

            /// <summary>
            /// <para>A NamedTransform is not a color space and does not have an encoding in the same sense.</para>
            /// <para>However, it may be useful to associate a color space encoding that the transform is intended</para>
            /// <para>to be used with, for organizational purposes.</para>
            /// </summary>
            public abstract string Encoding
            {
                get;

                set;
            }

            #region Virtual table interop

            // char * getName() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetNameDelegateInstance;

            private static __IntPtr _GetNameDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.Name;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setName(const char * name) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetNameDelegateInstance;

            private static void _SetNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.Name = name;
            }

            // size_t getNumAliases() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumAliasesDelegateInstance;

            private static ulong _GetNumAliasesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.NumAliases;
                return ___ret;
            }

            // char * getAlias(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetAliasDelegateInstance;

            private static __IntPtr _GetAliasDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.GetAlias(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // bool hasAlias(const char* alias) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr_string8 _HasAliasDelegateInstance;

            private static bool _HasAliasDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.HasAlias(alias);
                return ___ret;
            }

            // void addAlias(const char * alias) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddAliasDelegateInstance;

            private static void _AddAliasDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.AddAlias(alias);
            }

            // void removeAlias(const char * alias) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _RemoveAliasDelegateInstance;

            private static void _RemoveAliasDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string alias)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.RemoveAlias(alias);
            }

            // void clearAliases() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ClearAliasesDelegateInstance;

            private static void _ClearAliasesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.ClearAliases();
            }

            // char * getFamily() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFamilyDelegateInstance;

            private static __IntPtr _GetFamilyDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.Family;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setFamily(const char * family) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetFamilyDelegateInstance;

            private static void _SetFamilyDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string family)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.Family = family;
            }

            // char * getDescription() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetDescriptionDelegateInstance;

            private static __IntPtr _GetDescriptionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.Description;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setDescription(const char * description) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetDescriptionDelegateInstance;

            private static void _SetDescriptionDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.Description = description;
            }

            // bool hasCategory(const char * category) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr_string8 _HasCategoryDelegateInstance;

            private static bool _HasCategoryDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.HasCategory(category);
                return ___ret;
            }

            // void addCategory(const char * category) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddCategoryDelegateInstance;

            private static void _AddCategoryDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.AddCategory(category);
            }

            // void removeCategory(const char * category) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _RemoveCategoryDelegateInstance;

            private static void _RemoveCategoryDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.RemoveCategory(category);
            }

            // int getNumCategories() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetNumCategoriesDelegateInstance;

            private static int _GetNumCategoriesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.NumCategories;
                return ___ret;
            }

            // char * getCategory(int index) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int _GetCategoryDelegateInstance;

            private static __IntPtr _GetCategoryDelegateHook(__IntPtr __instance, int index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.GetCategory(index);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void clearCategories() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ClearCategoriesDelegateInstance;

            private static void _ClearCategoriesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.ClearCategories();
            }

            // char * getEncoding() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetEncodingDelegateInstance;

            private static __IntPtr _GetEncodingDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                var ___ret = __target.Encoding;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setEncoding(const char * encoding) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetEncodingDelegateInstance;

            private static void _SetEncodingDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string encoding)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.Encoding = encoding;
            }

            // virtual ~NamedTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.NamedTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[21];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNameDelegateInstance += _GetNameDelegateHook;
                    _SetNameDelegateInstance += _SetNameDelegateHook;
                    _GetNumAliasesDelegateInstance += _GetNumAliasesDelegateHook;
                    _GetAliasDelegateInstance += _GetAliasDelegateHook;
                    _HasAliasDelegateInstance += _HasAliasDelegateHook;
                    _AddAliasDelegateInstance += _AddAliasDelegateHook;
                    _RemoveAliasDelegateInstance += _RemoveAliasDelegateHook;
                    _ClearAliasesDelegateInstance += _ClearAliasesDelegateHook;
                    _GetFamilyDelegateInstance += _GetFamilyDelegateHook;
                    _SetFamilyDelegateInstance += _SetFamilyDelegateHook;
                    _GetDescriptionDelegateInstance += _GetDescriptionDelegateHook;
                    _SetDescriptionDelegateInstance += _SetDescriptionDelegateHook;
                    _HasCategoryDelegateInstance += _HasCategoryDelegateHook;
                    _AddCategoryDelegateInstance += _AddCategoryDelegateHook;
                    _RemoveCategoryDelegateInstance += _RemoveCategoryDelegateHook;
                    _GetNumCategoriesDelegateInstance += _GetNumCategoriesDelegateHook;
                    _GetCategoryDelegateInstance += _GetCategoryDelegateHook;
                    _ClearCategoriesDelegateInstance += _ClearCategoriesDelegateHook;
                    _GetEncodingDelegateInstance += _GetEncodingDelegateHook;
                    _SetEncodingDelegateInstance += _SetEncodingDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetNameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetNumAliasesDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetAliasDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_HasAliasDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_AddAliasDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_RemoveAliasDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_ClearAliasesDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetFamilyDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_SetFamilyDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetDescriptionDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SetDescriptionDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_HasCategoryDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_AddCategoryDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_RemoveCategoryDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetNumCategoriesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetCategoryDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_ClearCategoriesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetEncodingDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_SetEncodingDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 24, 0);
                                ManagedVTablesDtorOnly[0][23] = Thunks[20];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 24, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][8] = Thunks[7];
                                ManagedVTables[0][9] = Thunks[8];
                                ManagedVTables[0][10] = Thunks[9];
                                ManagedVTables[0][11] = Thunks[10];
                                ManagedVTables[0][12] = Thunks[11];
                                ManagedVTables[0][13] = Thunks[12];
                                ManagedVTables[0][14] = Thunks[13];
                                ManagedVTables[0][15] = Thunks[14];
                                ManagedVTables[0][16] = Thunks[15];
                                ManagedVTables[0][17] = Thunks[16];
                                ManagedVTables[0][18] = Thunks[17];
                                ManagedVTables[0][19] = Thunks[18];
                                ManagedVTables[0][20] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                VTables.Methods[0] = new Delegate[24];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>A *ViewTransform* provides a conversion from the main (usually scene-referred) reference space</para>
        /// <para>to the display-referred reference space.  This allows splitting the conversion from the main</para>
        /// <para>reference space to a display into two parts: the ViewTransform plus a display color space.</para>
        /// </summary>
        /// <remarks>
        /// <para>It is also possible to provide a ViewTransform that converts from the display-referred</para>
        /// <para>reference space back to that space.  This is useful in cases when a ViewTransform is needed</para>
        /// <para>when converting between displays (such as HDR to SDR).</para>
        /// <para>The ReferenceSpaceType indicates whether the ViewTransform converts from scene-to-display</para>
        /// <para>reference or display-to-display reference.</para>
        /// <para>The from_reference transform direction is the one that is used when going out towards a display.</para>
        /// </remarks>
        public unsafe partial class ViewTransform : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1ViewTransform@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasCategory@ViewTransform@OpenColorIO_v2_4@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addCategory@ViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?removeCategory@ViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RemoveCategory(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string category);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCategory@ViewTransform@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCategory(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearCategories@ViewTransform@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearCategories(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getName@ViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setName@ViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFamily@ViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFamily(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setFamily@ViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFamily(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string family);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDescription@ViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDescription(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDescription@ViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescription(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumCategories@ViewTransform@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumCategories(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getReferenceSpaceType@ViewTransform@OpenColorIO_v2_4@@QEBA?AW4ReferenceSpaceType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType GetReferenceSpaceType(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ViewTransform> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ViewTransform>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ViewTransform managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ViewTransform managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ViewTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ViewTransform(native.ToPointer(), skipVTables);
            }

            internal static ViewTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ViewTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ViewTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ViewTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ViewTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ViewTransform(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <remarks>ColorSpace::hasCategory</remarks>
            public bool HasCategory(string category)
            {
                var ___ret = __Internal.HasCategory(__Instance, category);
                return ___ret;
            }

            /// <remarks>ColorSpace::addCategory</remarks>
            public void AddCategory(string category)
            {
                __Internal.AddCategory(__Instance, category);
            }

            /// <remarks>ColorSpace::removeCategory</remarks>
            public void RemoveCategory(string category)
            {
                __Internal.RemoveCategory(__Instance, category);
            }

            /// <remarks>ColorSpace::getCategory</remarks>
            public string GetCategory(int index)
            {
                var ___ret = __Internal.GetCategory(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <remarks>ColorSpace::clearCategories</remarks>
            public void ClearCategories()
            {
                __Internal.ClearCategories(__Instance);
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetName(__Instance, value);
                }
            }

            /// <remarks>
            /// <para>ColorSpace::getFamily</para>
            /// <para>ColorSpace::setFamily</para>
            /// </remarks>
            public string Family
            {
                get
                {
                    var ___ret = __Internal.GetFamily(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetFamily(__Instance, value);
                }
            }

            public string Description
            {
                get
                {
                    var ___ret = __Internal.GetDescription(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDescription(__Instance, value);
                }
            }

            /// <remarks>ColorSpace::getNumCategories</remarks>
            public int NumCategories
            {
                get
                {
                    var ___ret = __Internal.GetNumCategories(__Instance);
                    return ___ret;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.ReferenceSpaceType ReferenceSpaceType
            {
                get
                {
                    var ___ret = __Internal.GetReferenceSpaceType(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The *Processor* represents a specific color transformation which is</para>
        /// <para>the result of</para>
        /// </summary>
        public unsafe partial class Processor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1Processor@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getTransformFormatMetadata@Processor@OpenColorIO_v2_4@@QEBAAEBVFormatMetadata@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTransformFormatMetadata(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasDynamicProperty@Processor@OpenColorIO_v2_4@@QEBA_NW4DynamicPropertyType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDynamicProperty(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isNoOp@Processor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsNoOp(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasChannelCrosstalk@Processor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasChannelCrosstalk(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCacheID@Processor@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCacheID(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFormatMetadata@Processor@OpenColorIO_v2_4@@QEBAAEBVFormatMetadata@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatMetadata(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumTransforms@Processor@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumTransforms(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isDynamic@Processor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDynamic(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Processor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Processor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Processor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Processor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Processor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Processor(native.ToPointer(), skipVTables);
            }

            internal static Processor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Processor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Processor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Processor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Processor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Processor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get a FormatMetadata containing the metadata for a</para>
            /// <para>transform within the processor. For a processor from a CLF file, this</para>
            /// <para>corresponds to the metadata associated with an individual process node.</para>
            /// </summary>
            public global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata GetTransformFormatMetadata(int index)
            {
                var ___ret = __Internal.GetTransformFormatMetadata(__Instance, index);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>True if at least one dynamic property of that type exists.</summary>
            public bool HasDynamicProperty(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type)
            {
                var ___ret = __Internal.HasDynamicProperty(__Instance, type);
                return ___ret;
            }

            public bool IsNoOp
            {
                get
                {
                    var ___ret = __Internal.IsNoOp(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>True if the image transformation is non-separable.</para>
            /// <para>For example, if a change in red may also cause a change in green or blue.</para>
            /// </summary>
            public bool HasChannelCrosstalk
            {
                get
                {
                    var ___ret = __Internal.HasChannelCrosstalk(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Returns a hash string generated by hashing the cachedIDs of the (unoptimized) list of ops</para>
            /// <para>contained in the Processor. (This forms part of the key used by the config's processor cache.)</para>
            /// </summary>
            public string CacheID
            {
                get
                {
                    var ___ret = __Internal.GetCacheID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            /// <summary>
            /// <para>Get a FormatMetadata containing the top level metadata</para>
            /// <para>for the processor.  For a processor from a CLF file, this corresponds to</para>
            /// <para>the ProcessList metadata.</para>
            /// </summary>
            public global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___ret = __Internal.GetFormatMetadata(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the number of transforms that comprise the processor.</para>
            /// <para>Each transform has a (potentially empty) FormatMetadata.</para>
            /// </summary>
            public int NumTransforms
            {
                get
                {
                    var ___ret = __Internal.GetNumTransforms(__Instance);
                    return ___ret;
                }
            }

            /// <summary>True if at least one dynamic property of any type exists and is dynamic.</summary>
            public bool IsDynamic
            {
                get
                {
                    var ___ret = __Internal.IsDynamic(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>////////////////////////////////////////////////////////////////////////</summary>
        public unsafe partial class CPUProcessor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1CPUProcessor@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasDynamicProperty@CPUProcessor@OpenColorIO_v2_4@@QEBA_NW4DynamicPropertyType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDynamicProperty(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?apply@CPUProcessor@OpenColorIO_v2_4@@QEBAXAEBVImageDesc@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr __instance, __IntPtr imgDesc);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?apply@CPUProcessor@OpenColorIO_v2_4@@QEBAXAEBVImageDesc@2@AEAV32@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Apply(__IntPtr __instance, __IntPtr srcImgDesc, __IntPtr dstImgDesc);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?applyRGB@CPUProcessor@OpenColorIO_v2_4@@QEBAXPEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ApplyRGB(__IntPtr __instance, float* pixel);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?applyRGBA@CPUProcessor@OpenColorIO_v2_4@@QEBAXPEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ApplyRGBA(__IntPtr __instance, float* pixel);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isNoOp@CPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsNoOp(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isIdentity@CPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsIdentity(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasChannelCrosstalk@CPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasChannelCrosstalk(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCacheID@CPUProcessor@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCacheID(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getInputBitDepth@CPUProcessor@OpenColorIO_v2_4@@QEBA?AW4BitDepth@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.BitDepth GetInputBitDepth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getOutputBitDepth@CPUProcessor@OpenColorIO_v2_4@@QEBA?AW4BitDepth@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.BitDepth GetOutputBitDepth(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isDynamic@CPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDynamic(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.CPUProcessor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.CPUProcessor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.CPUProcessor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.CPUProcessor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static CPUProcessor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CPUProcessor(native.ToPointer(), skipVTables);
            }

            internal static CPUProcessor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CPUProcessor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CPUProcessor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CPUProcessor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CPUProcessor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CPUProcessor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>True if at least one dynamic property of that type exists.</summary>
            public bool HasDynamicProperty(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type)
            {
                var ___ret = __Internal.HasDynamicProperty(__Instance, type);
                return ___ret;
            }

            /// <summary>
            /// <para>Apply to an image with any kind of channel ordering while</para>
            /// <para>respecting the input and output bit-depths.</para>
            /// </summary>
            public void Apply(global::OpenColorIO.OpenColorIO_v2_4.ImageDesc imgDesc)
            {
                if (ReferenceEquals(imgDesc, null))
                    throw new global::System.ArgumentNullException("imgDesc", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = imgDesc.__Instance;
                __Internal.Apply(__Instance, __arg0);
            }

            public void Apply(global::OpenColorIO.OpenColorIO_v2_4.ImageDesc srcImgDesc, global::OpenColorIO.OpenColorIO_v2_4.ImageDesc dstImgDesc)
            {
                if (ReferenceEquals(srcImgDesc, null))
                    throw new global::System.ArgumentNullException("srcImgDesc", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = srcImgDesc.__Instance;
                if (ReferenceEquals(dstImgDesc, null))
                    throw new global::System.ArgumentNullException("dstImgDesc", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dstImgDesc.__Instance;
                __Internal.Apply(__Instance, __arg0, __arg1);
            }

            /// <summary>
            /// <para>Apply to a single pixel respecting that the input and output bit-depths</para>
            /// <para>be 32-bit float and the image buffer be packed RGB/RGBA.</para>
            /// </summary>
            /// <remarks>
            /// <para>This is not as efficient as applying to an entire image at once.</para>
            /// <para>If you are processing multiple pixels, and have the flexibility,</para>
            /// <para>use the above function instead.</para>
            /// </remarks>
            public void ApplyRGB(ref float pixel)
            {
                fixed (float* __pixel0 = &pixel)
                {
                    var __arg0 = __pixel0;
                    __Internal.ApplyRGB(__Instance, __arg0);
                }
            }

            public void ApplyRGBA(ref float pixel)
            {
                fixed (float* __pixel0 = &pixel)
                {
                    var __arg0 = __pixel0;
                    __Internal.ApplyRGBA(__Instance, __arg0);
                }
            }

            /// <summary>The in and out bit-depths must be equal for isNoOp to be true.</summary>
            public bool IsNoOp
            {
                get
                {
                    var ___ret = __Internal.IsNoOp(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Equivalent to isNoOp from the underlying Processor, i.e., it ignores</para>
            /// <para>in/out bit-depth differences.</para>
            /// </summary>
            public bool IsIdentity
            {
                get
                {
                    var ___ret = __Internal.IsIdentity(__Instance);
                    return ___ret;
                }
            }

            public bool HasChannelCrosstalk
            {
                get
                {
                    var ___ret = __Internal.HasChannelCrosstalk(__Instance);
                    return ___ret;
                }
            }

            public string CacheID
            {
                get
                {
                    var ___ret = __Internal.GetCacheID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            /// <summary>Bit-depth of the input pixel buffer.</summary>
            public global::OpenColorIO.OpenColorIO_v2_4.BitDepth InputBitDepth
            {
                get
                {
                    var ___ret = __Internal.GetInputBitDepth(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Bit-depth of the output pixel buffer.</summary>
            public global::OpenColorIO.OpenColorIO_v2_4.BitDepth OutputBitDepth
            {
                get
                {
                    var ___ret = __Internal.GetOutputBitDepth(__Instance);
                    return ___ret;
                }
            }

            /// <summary>True if at least one dynamic property of any type exists and is dynamic.</summary>
            public bool IsDynamic
            {
                get
                {
                    var ___ret = __Internal.IsDynamic(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>////////////////////////////////////////////////////////////////////////</summary>
        public unsafe partial class GPUProcessor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1GPUProcessor@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?isNoOp@GPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsNoOp(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasChannelCrosstalk@GPUProcessor@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasChannelCrosstalk(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCacheID@GPUProcessor@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCacheID(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GPUProcessor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GPUProcessor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GPUProcessor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GPUProcessor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GPUProcessor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GPUProcessor(native.ToPointer(), skipVTables);
            }

            internal static GPUProcessor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GPUProcessor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GPUProcessor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GPUProcessor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GPUProcessor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GPUProcessor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool IsNoOp
            {
                get
                {
                    var ___ret = __Internal.IsNoOp(__Instance);
                    return ___ret;
                }
            }

            public bool HasChannelCrosstalk
            {
                get
                {
                    var ___ret = __Internal.HasChannelCrosstalk(__Instance);
                    return ___ret;
                }
            }

            public string CacheID
            {
                get
                {
                    var ___ret = __Internal.GetCacheID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }
        }

        /// <summary>
        /// <para>This class contains meta information about the process that generated</para>
        /// <para>this processor.  The results of these functions do not</para>
        /// <para>impact the pixel processing.</para>
        /// </summary>
        public unsafe partial class ProcessorMetadata : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1ProcessorMetadata@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFile@ProcessorMetadata@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFile(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLook@ProcessorMetadata@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLook(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addFile@ProcessorMetadata@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddFile(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fname);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addLook@ProcessorMetadata@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddLook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string look);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumFiles@ProcessorMetadata@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumFiles(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumLooks@ProcessorMetadata@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumLooks(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ProcessorMetadata> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ProcessorMetadata>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ProcessorMetadata managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ProcessorMetadata managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ProcessorMetadata __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ProcessorMetadata(native.ToPointer(), skipVTables);
            }

            internal static ProcessorMetadata __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ProcessorMetadata)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ProcessorMetadata __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ProcessorMetadata(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ProcessorMetadata(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ProcessorMetadata(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string GetFile(int index)
            {
                var ___ret = __Internal.GetFile(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetLook(int index)
            {
                var ___ret = __Internal.GetLook(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void AddFile(string fname)
            {
                __Internal.AddFile(__Instance, fname);
            }

            public void AddLook(string look)
            {
                __Internal.AddLook(__Instance, look);
            }

            public int NumFiles
            {
                get
                {
                    var ___ret = __Internal.GetNumFiles(__Instance);
                    return ___ret;
                }
            }

            public int NumLooks
            {
                get
                {
                    var ___ret = __Internal.GetNumLooks(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>In certain situations it is necessary to serialize transforms into a variety</para>
        /// <para>of application specific LUT formats. Note that not all file formats that may</para>
        /// <para>be read also support baking.</para>
        /// </summary>
        /// <remarks>**Usage Example:** *Bake a CSP sRGB viewer LUT*</remarks>
        public unsafe partial class Baker : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1Baker@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDisplayView@Baker@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDisplayView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFormatNameByIndex@Baker@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatNameByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFormatExtensionByIndex@Baker@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatExtensionByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFormat@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormat(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setFormat@Baker@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFormat(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string formatName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFormatMetadata@Baker@OpenColorIO_v2_4@@QEAAAEAVFormatMetadata@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatMetadata(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getInputSpace@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetInputSpace(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setInputSpace@Baker@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInputSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string inputSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getShaperSpace@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetShaperSpace(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setShaperSpace@Baker@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShaperSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaperSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLooks@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLooks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setLooks@Baker@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLooks(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getTargetSpace@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTargetSpace(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setTargetSpace@Baker@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTargetSpace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string targetSpace);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplay@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getView@Baker@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetView(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getShaperSize@Baker@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetShaperSize(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setShaperSize@Baker@OpenColorIO_v2_4@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetShaperSize(__IntPtr __instance, int shapersize);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCubeSize@Baker@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetCubeSize(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setCubeSize@Baker@OpenColorIO_v2_4@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCubeSize(__IntPtr __instance, int cubesize);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumFormats@Baker@OpenColorIO_v2_4@@SAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumFormats();
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Baker> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Baker>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Baker managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Baker managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Baker __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Baker(native.ToPointer(), skipVTables);
            }

            internal static Baker __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Baker)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Baker __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Baker(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Baker(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Baker(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the display and view to apply during the baking. Must not be used if setTargetSpace is used.</summary>
            public void SetDisplayView(string display, string view)
            {
                __Internal.SetDisplayView(__Instance, display, view);
            }

            /// <summary>
            /// <para>Get the LUT baker format name at index, return empty string if an invalid</para>
            /// <para>index is specified.</para>
            /// </summary>
            public static string GetFormatNameByIndex(int index)
            {
                var ___ret = __Internal.GetFormatNameByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get the LUT baker format extension at index, return empty string if an</para>
            /// <para>invalid index is specified.</para>
            /// </summary>
            public static string GetFormatExtensionByIndex(int index)
            {
                var ___ret = __Internal.GetFormatExtensionByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string Format
            {
                get
                {
                    var ___ret = __Internal.GetFormat(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetFormat(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Get editable *optional* format metadata. The metadata that will be used</para>
            /// <para>varies based on the capability of the given file format.  Formats such as CSP,</para>
            /// <para>IridasCube, and ResolveCube will create comments in the file header using the value of</para>
            /// <para>any first-level children elements of the formatMetadata.  The CLF/CTF formats will make</para>
            /// <para>use of the top-level &quot;id&quot; and &quot;name&quot; attributes and children elements &quot;Description&quot;,</para>
            /// <para>&quot;InputDescriptor&quot;, &quot;OutputDescriptor&quot;, and &quot;Info&quot;.</para>
            /// </summary>
            public global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___ret = __Internal.GetFormatMetadata(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public string InputSpace
            {
                get
                {
                    var ___ret = __Internal.GetInputSpace(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetInputSpace(__Instance, value);
                }
            }

            public string ShaperSpace
            {
                get
                {
                    var ___ret = __Internal.GetShaperSpace(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetShaperSpace(__Instance, value);
                }
            }

            public string Looks
            {
                get
                {
                    var ___ret = __Internal.GetLooks(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetLooks(__Instance, value);
                }
            }

            public string TargetSpace
            {
                get
                {
                    var ___ret = __Internal.GetTargetSpace(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetTargetSpace(__Instance, value);
                }
            }

            public string Display
            {
                get
                {
                    var ___ret = __Internal.GetDisplay(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public string View
            {
                get
                {
                    var ___ret = __Internal.GetView(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public int ShaperSize
            {
                get
                {
                    var ___ret = __Internal.GetShaperSize(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShaperSize(__Instance, value);
                }
            }

            public int CubeSize
            {
                get
                {
                    var ___ret = __Internal.GetCubeSize(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCubeSize(__Instance, value);
                }
            }

            /// <summary>Get the number of LUT bakers.</summary>
            public static int NumFormats
            {
                get
                {
                    var ___ret = __Internal.GetNumFormats();
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>This is a light-weight wrapper around an image, that provides a context</para>
        /// <para>for pixel access. This does NOT claim ownership of the pixels or copy</para>
        /// <para>image data.</para>
        /// </summary>
        public unsafe abstract partial class ImageDesc : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_ImageDesc;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ImageDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ImageDesc> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ImageDesc>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ImageDesc managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ImageDesc managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ImageDescInternal(native.ToPointer(), skipVTables);
            }

            internal static ImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ImageDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ImageDesc __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ImageDesc)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ImageDescInternal(native, skipVTables);
            }

            protected ImageDesc(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ImageDesc()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ImageDesc");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get a pointer to the red channel of the first pixel.</summary>
            public abstract __IntPtr RData
            {
                get;
            }

            /// <summary>Get a pointer to the green channel of the first pixel.</summary>
            public abstract __IntPtr GData
            {
                get;
            }

            /// <summary>Get a pointer to the blue channel of the first pixel.</summary>
            public abstract __IntPtr BData
            {
                get;
            }

            /// <summary>
            /// <para>Get a pointer to the alpha channel of the first pixel</para>
            /// <para>or null as alpha channel is optional.</para>
            /// </summary>
            public abstract __IntPtr AData
            {
                get;
            }

            /// <summary>Get the bit-depth.</summary>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepth
            {
                get;
            }

            /// <summary>Get the width to process (where x position starts at 0 and ends at width-1).</summary>
            public abstract int Width
            {
                get;
            }

            /// <summary>Get the height to process (where y position starts at 0 and ends at height-1).</summary>
            public abstract int Height
            {
                get;
            }

            /// <summary>Get the step in bytes to find the same color channel of the next pixel.</summary>
            public abstract long XStrideBytes
            {
                get;
            }

            /// <summary>
            /// <para>Get the step in bytes to find the same color channel</para>
            /// <para>of the pixel at the same position in the next line.</para>
            /// </summary>
            public abstract long YStrideBytes
            {
                get;
            }

            /// <summary>
            /// <para>Is the image buffer in packed mode with the 4 color channels?</para>
            /// <para>(&quot;Packed&quot; here means that XStrideBytes is 4x the bytes per channel, so it is more specific</para>
            /// <para>than simply any PackedImageDesc.)</para>
            /// </summary>
            public abstract bool IsRGBAPacked
            {
                get;
            }

            /// <summary>Is the image buffer 32-bit float?</summary>
            public abstract bool IsFloat
            {
                get;
            }

            #region Virtual table interop

            // virtual ~ImageDesc()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void * getRData() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetRDataDelegateInstance;

            private static __IntPtr _GetRDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.RData;
                return ___ret;
            }

            // void * getGData() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetGDataDelegateInstance;

            private static __IntPtr _GetGDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.GData;
                return ___ret;
            }

            // void * getBData() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetBDataDelegateInstance;

            private static __IntPtr _GetBDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.BData;
                return ___ret;
            }

            // void * getAData() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetADataDelegateInstance;

            private static __IntPtr _GetADataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.AData;
                return ___ret;
            }

            // BitDepth getBitDepth() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.BitDepth;
                return ___ret;
            }

            // long getWidth() const = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetWidthDelegateInstance;

            private static int _GetWidthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.Width;
                return ___ret;
            }

            // long getHeight() const = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetHeightDelegateInstance;

            private static int _GetHeightDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.Height;
                return ___ret;
            }

            // ptrdiff_t getXStrideBytes() const = 0
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetXStrideBytesDelegateInstance;

            private static long _GetXStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.XStrideBytes;
                return ___ret;
            }

            // ptrdiff_t getYStrideBytes() const = 0
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetYStrideBytesDelegateInstance;

            private static long _GetYStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.YStrideBytes;
                return ___ret;
            }

            // bool isRGBAPacked() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsRGBAPackedDelegateInstance;

            private static bool _IsRGBAPackedDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsRGBAPacked;
                return ___ret;
            }

            // bool isFloat() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsFloatDelegateInstance;

            private static bool _IsFloatDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsFloat;
                return ___ret;
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRDataDelegateInstance += _GetRDataDelegateHook;
                    _GetGDataDelegateInstance += _GetGDataDelegateHook;
                    _GetBDataDelegateInstance += _GetBDataDelegateHook;
                    _GetADataDelegateInstance += _GetADataDelegateHook;
                    _GetBitDepthDelegateInstance += _GetBitDepthDelegateHook;
                    _GetWidthDelegateInstance += _GetWidthDelegateHook;
                    _GetHeightDelegateInstance += _GetHeightDelegateHook;
                    _GetXStrideBytesDelegateInstance += _GetXStrideBytesDelegateHook;
                    _GetYStrideBytesDelegateInstance += _GetYStrideBytesDelegateHook;
                    _IsRGBAPackedDelegateInstance += _IsRGBAPackedDelegateHook;
                    _IsFloatDelegateInstance += _IsFloatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRDataDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetGDataDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetBDataDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetADataDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetBitDepthDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetWidthDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetHeightDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetXStrideBytesDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetYStrideBytesDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_IsRGBAPackedDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsFloatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                VTables.Methods[0] = new Delegate[12];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>All the constructors expect a pointer to packed image data (such as</para>
        /// <para>rgbrgbrgb or rgbargbargba) starting at the first color channel of</para>
        /// <para>the first pixel to process (which does not need to be the first pixel</para>
        /// <para>of the image). The number of channels must be greater than or equal to 3.</para>
        /// <para>If a 4th channel is specified, it is assumed to be alpha</para>
        /// <para>information.  Channels &gt; 4 will be ignored.</para>
        /// </summary>
        /// <remarks>The methods assume the CPUProcessor bit-depth type for the data pointer.</remarks>
        public unsafe partial class PackedImageDesc : global::OpenColorIO.OpenColorIO_v2_4.ImageDesc, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_ImageDesc;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PackedImageDesc@OpenColorIO_v2_4@@QEAA@PEAXJJJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, int width, int height, int numChannels);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PackedImageDesc@OpenColorIO_v2_4@@QEAA@PEAXJJJW4BitDepth@1@_J22@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr data, int width, int height, int numChannels, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long chanStrideBytes, long xStrideBytes, long yStrideBytes);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PackedImageDesc@OpenColorIO_v2_4@@QEAA@PEAXJJW4ChannelOrdering@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, __IntPtr data, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering chanOrder);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PackedImageDesc@OpenColorIO_v2_4@@QEAA@PEAXJJW4ChannelOrdering@1@W4BitDepth@1@_J33@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, __IntPtr data, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering chanOrder, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long chanStrideBytes, long xStrideBytes, long yStrideBytes);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getChannelOrder@PackedImageDesc@OpenColorIO_v2_4@@QEBA?AW4ChannelOrdering@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering GetChannelOrder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getData@PackedImageDesc@OpenColorIO_v2_4@@QEBAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetData(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumChannels@PackedImageDesc@OpenColorIO_v2_4@@QEBAJXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumChannels(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getChanStrideBytes@PackedImageDesc@OpenColorIO_v2_4@@QEBA_JXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetChanStrideBytes(__IntPtr __instance);
            }

            internal static new PackedImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PackedImageDesc(native.ToPointer(), skipVTables);
            }

            internal static new PackedImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PackedImageDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PackedImageDesc __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PackedImageDesc)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PackedImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PackedImageDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PackedImageDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PackedImageDesc(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <remarks>numChannels must be 3 (RGB) or 4 (RGBA).</remarks>
            public PackedImageDesc(__IntPtr data, int width, int height, int numChannels)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, data, width, height, numChannels);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PackedImageDesc");
            }

            /// <remarks>numChannels must be 3 (RGB) or 4 (RGBA).</remarks>
            public PackedImageDesc(__IntPtr data, int width, int height, int numChannels, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long chanStrideBytes, long xStrideBytes, long yStrideBytes)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, data, width, height, numChannels, bitDepth, chanStrideBytes, xStrideBytes, yStrideBytes);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PackedImageDesc");
            }

            public PackedImageDesc(__IntPtr data, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering chanOrder)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor_1(__Instance, data, width, height, chanOrder);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PackedImageDesc");
            }

            public PackedImageDesc(__IntPtr data, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering chanOrder, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long chanStrideBytes, long xStrideBytes, long yStrideBytes)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor_1(__Instance, data, width, height, chanOrder, bitDepth, chanStrideBytes, xStrideBytes, yStrideBytes);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PackedImageDesc");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the channel ordering of all the pixels.</summary>
            public global::OpenColorIO.OpenColorIO_v2_4.ChannelOrdering ChannelOrder
            {
                get
                {
                    var ___ret = __Internal.GetChannelOrder(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the bit-depth.</summary>
            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepth
            {
                get
                {
                    var ___GetBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 5);
                    var ___ret = ___GetBitDepthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get a pointer to the first color channel of the first pixel.</summary>
            public __IntPtr Data
            {
                get
                {
                    var ___ret = __Internal.GetData(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr RData
            {
                get
                {
                    var ___GetRDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr GData
            {
                get
                {
                    var ___GetGDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetGDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr BData
            {
                get
                {
                    var ___GetBDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetBDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr AData
            {
                get
                {
                    var ___GetADataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 4);
                    var ___ret = ___GetADataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int Width
            {
                get
                {
                    var ___GetWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 6);
                    var ___ret = ___GetWidthDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int Height
            {
                get
                {
                    var ___GetHeightDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 7);
                    var ___ret = ___GetHeightDelegate(__Instance);
                    return ___ret;
                }
            }

            public int NumChannels
            {
                get
                {
                    var ___ret = __Internal.GetNumChannels(__Instance);
                    return ___ret;
                }
            }

            public long ChanStrideBytes
            {
                get
                {
                    var ___ret = __Internal.GetChanStrideBytes(__Instance);
                    return ___ret;
                }
            }

            public override long XStrideBytes
            {
                get
                {
                    var ___GetXStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 8);
                    var ___ret = ___GetXStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override long YStrideBytes
            {
                get
                {
                    var ___GetYStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 9);
                    var ___ret = ___GetYStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsRGBAPacked
            {
                get
                {
                    var ___IsRGBAPackedDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 10);
                    var ___ret = ___IsRGBAPackedDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsFloat
            {
                get
                {
                    var ___IsFloatDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 11);
                    var ___ret = ___IsFloatDelegate(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~PackedImageDesc()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void * getRData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetRDataDelegateInstance;

            private static __IntPtr _GetRDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.RData;
                return ___ret;
            }

            // void * getGData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetGDataDelegateInstance;

            private static __IntPtr _GetGDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.GData;
                return ___ret;
            }

            // void * getBData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetBDataDelegateInstance;

            private static __IntPtr _GetBDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.BData;
                return ___ret;
            }

            // void * getAData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetADataDelegateInstance;

            private static __IntPtr _GetADataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.AData;
                return ___ret;
            }

            // BitDepth getBitDepth() const override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.BitDepth;
                return ___ret;
            }

            // long getWidth() const override
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetWidthDelegateInstance;

            private static int _GetWidthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.Width;
                return ___ret;
            }

            // long getHeight() const override
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetHeightDelegateInstance;

            private static int _GetHeightDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.Height;
                return ___ret;
            }

            // ptrdiff_t getXStrideBytes() const override
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetXStrideBytesDelegateInstance;

            private static long _GetXStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.XStrideBytes;
                return ___ret;
            }

            // ptrdiff_t getYStrideBytes() const override
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetYStrideBytesDelegateInstance;

            private static long _GetYStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.YStrideBytes;
                return ___ret;
            }

            // bool isRGBAPacked() const override
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsRGBAPackedDelegateInstance;

            private static bool _IsRGBAPackedDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsRGBAPacked;
                return ___ret;
            }

            // bool isFloat() const override
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsFloatDelegateInstance;

            private static bool _IsFloatDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PackedImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsFloat;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRDataDelegateInstance += _GetRDataDelegateHook;
                    _GetGDataDelegateInstance += _GetGDataDelegateHook;
                    _GetBDataDelegateInstance += _GetBDataDelegateHook;
                    _GetADataDelegateInstance += _GetADataDelegateHook;
                    _GetBitDepthDelegateInstance += _GetBitDepthDelegateHook;
                    _GetWidthDelegateInstance += _GetWidthDelegateHook;
                    _GetHeightDelegateInstance += _GetHeightDelegateHook;
                    _GetXStrideBytesDelegateInstance += _GetXStrideBytesDelegateHook;
                    _GetYStrideBytesDelegateInstance += _GetYStrideBytesDelegateHook;
                    _IsRGBAPackedDelegateInstance += _IsRGBAPackedDelegateHook;
                    _IsFloatDelegateInstance += _IsFloatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRDataDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetGDataDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetBDataDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetADataDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetBitDepthDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetWidthDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetHeightDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetXStrideBytesDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetYStrideBytesDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_IsRGBAPackedDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsFloatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                VTables.Methods[0] = new Delegate[12];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>All the constructors expect pointers to the specified image planes</para>
        /// <para>(i.e. rrrr gggg bbbb) starting at the first color channel of the</para>
        /// <para>first pixel to process (which need not be the first pixel of the image).</para>
        /// <para>Pass NULL for aData if no alpha exists (r/g/bData must not be NULL).</para>
        /// </summary>
        /// <remarks>The methods assume the CPUProcessor bit-depth type for the R/G/B/A data pointers.</remarks>
        public unsafe partial class PlanarImageDesc : global::OpenColorIO.OpenColorIO_v2_4.ImageDesc, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_ImageDesc;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PlanarImageDesc@OpenColorIO_v2_4@@QEAA@PEAX000JJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr rData, __IntPtr gData, __IntPtr bData, __IntPtr aData, int width, int height);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0PlanarImageDesc@OpenColorIO_v2_4@@QEAA@PEAX000JJW4BitDepth@1@_J2@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr rData, __IntPtr gData, __IntPtr bData, __IntPtr aData, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long xStrideBytes, long yStrideBytes);
            }

            internal static new PlanarImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PlanarImageDesc(native.ToPointer(), skipVTables);
            }

            internal static new PlanarImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PlanarImageDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new PlanarImageDesc __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PlanarImageDesc)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PlanarImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PlanarImageDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PlanarImageDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PlanarImageDesc(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public PlanarImageDesc(__IntPtr rData, __IntPtr gData, __IntPtr bData, __IntPtr aData, int width, int height)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, rData, gData, bData, aData, width, height);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc");
            }

            /// <summary>
            /// <para>Note that although PlanarImageDesc is powerful enough to also describe</para>
            /// <para>all PackedImageDesc scenarios, it is recommended to use</para>
            /// <para>a PackedImageDesc where possible since that allows for additional</para>
            /// <para>optimizations.</para>
            /// </summary>
            public PlanarImageDesc(__IntPtr rData, __IntPtr gData, __IntPtr bData, __IntPtr aData, int width, int height, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth, long xStrideBytes, long yStrideBytes)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, rData, gData, bData, aData, width, height, bitDepth, xStrideBytes, yStrideBytes);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override __IntPtr RData
            {
                get
                {
                    var ___GetRDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr GData
            {
                get
                {
                    var ___GetGDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetGDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr BData
            {
                get
                {
                    var ___GetBDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetBDataDelegate(__Instance);
                    return ___ret;
                }
            }

            public override __IntPtr AData
            {
                get
                {
                    var ___GetADataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 4);
                    var ___ret = ___GetADataDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the bit-depth.</summary>
            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepth
            {
                get
                {
                    var ___GetBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 5);
                    var ___ret = ___GetBitDepthDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int Width
            {
                get
                {
                    var ___GetWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 6);
                    var ___ret = ___GetWidthDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int Height
            {
                get
                {
                    var ___GetHeightDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 7);
                    var ___ret = ___GetHeightDelegate(__Instance);
                    return ___ret;
                }
            }

            public override long XStrideBytes
            {
                get
                {
                    var ___GetXStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 8);
                    var ___ret = ___GetXStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override long YStrideBytes
            {
                get
                {
                    var ___GetYStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 9);
                    var ___ret = ___GetYStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsRGBAPacked
            {
                get
                {
                    var ___IsRGBAPackedDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 10);
                    var ___ret = ___IsRGBAPackedDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsFloat
            {
                get
                {
                    var ___IsFloatDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 11);
                    var ___ret = ___IsFloatDelegate(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // virtual ~PlanarImageDesc()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void * getRData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetRDataDelegateInstance;

            private static __IntPtr _GetRDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.RData;
                return ___ret;
            }

            // void * getGData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetGDataDelegateInstance;

            private static __IntPtr _GetGDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.GData;
                return ___ret;
            }

            // void * getBData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetBDataDelegateInstance;

            private static __IntPtr _GetBDataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.BData;
                return ___ret;
            }

            // void * getAData() const override
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetADataDelegateInstance;

            private static __IntPtr _GetADataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.AData;
                return ___ret;
            }

            // BitDepth getBitDepth() const override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.BitDepth;
                return ___ret;
            }

            // long getWidth() const override
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetWidthDelegateInstance;

            private static int _GetWidthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.Width;
                return ___ret;
            }

            // long getHeight() const override
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetHeightDelegateInstance;

            private static int _GetHeightDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.Height;
                return ___ret;
            }

            // ptrdiff_t getXStrideBytes() const override
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetXStrideBytesDelegateInstance;

            private static long _GetXStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.XStrideBytes;
                return ___ret;
            }

            // ptrdiff_t getYStrideBytes() const override
            private static global::OpenColorIO.Delegates.Func_long___IntPtr _GetYStrideBytesDelegateInstance;

            private static long _GetYStrideBytesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.YStrideBytes;
                return ___ret;
            }

            // bool isRGBAPacked() const override
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsRGBAPackedDelegateInstance;

            private static bool _IsRGBAPackedDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsRGBAPacked;
                return ___ret;
            }

            // bool isFloat() const override
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsFloatDelegateInstance;

            private static bool _IsFloatDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.PlanarImageDesc.__GetInstance(__instance);
                var ___ret = __target.IsFloat;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetRDataDelegateInstance += _GetRDataDelegateHook;
                    _GetGDataDelegateInstance += _GetGDataDelegateHook;
                    _GetBDataDelegateInstance += _GetBDataDelegateHook;
                    _GetADataDelegateInstance += _GetADataDelegateHook;
                    _GetBitDepthDelegateInstance += _GetBitDepthDelegateHook;
                    _GetWidthDelegateInstance += _GetWidthDelegateHook;
                    _GetHeightDelegateInstance += _GetHeightDelegateHook;
                    _GetXStrideBytesDelegateInstance += _GetXStrideBytesDelegateHook;
                    _GetYStrideBytesDelegateInstance += _GetYStrideBytesDelegateHook;
                    _IsRGBAPackedDelegateInstance += _IsRGBAPackedDelegateHook;
                    _IsFloatDelegateInstance += _IsFloatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRDataDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetGDataDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetBDataDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetADataDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetBitDepthDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetWidthDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetHeightDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetXStrideBytesDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetYStrideBytesDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_IsRGBAPackedDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsFloatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                VTables.Methods[0] = new Delegate[12];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Inherit from the class to fully customize the implementation of a GPU shader program</para>
        /// <para>from a color transformation.</para>
        /// </summary>
        /// <remarks>
        /// <para>When no customizations are needed and the intermediate in-memory step is acceptable then the</para>
        /// <para>is a better choice.</para>
        /// <para>To better decouple thefrom their GPU implementation, the code provides</para>
        /// <para>several addUniform() methods i.e. one per access function types. For example, an</para>
        /// <para>instance owns threeand they are all</para>
        /// <para>implemented by a double. When creating the GPU fragment shader program, the addUniform() with</para>
        /// <para>GpuShaderCreator::DoubleGetter is called when property is dynamic, up to three times.</para>
        /// <para>**An OCIO shader program could contain:**</para>
        /// <para>* A declaration part  e.g., uniform sampled3D tex3;</para>
        /// <para>* Some helper methods</para>
        /// <para>* The OCIO shader function may be broken down as:</para>
        /// <para>* The function header  e.g., void OCIODisplay(in vec4 inColor) {</para>
        /// <para>* The function body    e.g.,   vec4 outColor.rgb = texture3D(tex3, inColor.rgb).rgb;</para>
        /// <para>* The function footer  e.g.,   return outColor; }</para>
        /// <para></para>
        /// <para>**Usage Example:**</para>
        /// <para>Below is a code snippet to highlight the different parts of the OCIO shader program.</para>
        /// </remarks>
        public unsafe abstract partial class GpuShaderCreator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GpuShaderCreator;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GpuShaderCreator@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?hasDynamicProperty@GpuShaderCreator@OpenColorIO_v2_4@@QEBA_NW4DynamicPropertyType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDynamicProperty(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getUniqueID@GpuShaderCreator@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUniqueID(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setUniqueID@GpuShaderCreator@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUniqueID(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uid);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLanguage@GpuShaderCreator@OpenColorIO_v2_4@@QEBA?AW4GpuLanguage@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage GetLanguage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setLanguage@GpuShaderCreator@OpenColorIO_v2_4@@QEAAXW4GpuLanguage@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLanguage(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage lang);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getFunctionName@GpuShaderCreator@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFunctionName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setFunctionName@GpuShaderCreator@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFunctionName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getPixelName@GpuShaderCreator@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPixelName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setPixelName@GpuShaderCreator@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPixelName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getResourcePrefix@GpuShaderCreator@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetResourcePrefix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setResourcePrefix@GpuShaderCreator@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetResourcePrefix(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNextResourceIndex@GpuShaderCreator@OpenColorIO_v2_4@@QEAAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetNextResourceIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumDynamicProperties@GpuShaderCreator@OpenColorIO_v2_4@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetNumDynamicProperties(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getImpl@GpuShaderCreator@OpenColorIO_v2_4@@IEAAPEAVImpl@12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetImpl(__IntPtr __instance);
            }

            public enum TextureType
            {
                /// <summary>Only need a red channel texture</summary>
                TEXTURE_RED_CHANNEL = 0,
                /// <summary>Need a RGB texture</summary>
                TEXTURE_RGB_CHANNEL = 1
            }

            /// <summary>Dimension enum used to differentiate between 1D and 2D object/resource types.</summary>
            public enum TextureDimensions : byte
            {
                TEXTURE_1D = 1,
                TEXTURE_2D = 2
            }

            public unsafe partial class Impl
            {
                public partial struct __Internal
                {
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Impl __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Impl(native.ToPointer(), skipVTables);
                }

                internal static Impl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Impl)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Impl __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Impl(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Impl(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Impl(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GpuShaderCreator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GpuShaderCreatorInternal(native.ToPointer(), skipVTables);
            }

            internal static GpuShaderCreator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GpuShaderCreator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GpuShaderCreator __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GpuShaderCreator)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GpuShaderCreator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GpuShaderCreatorInternal(native, skipVTables);
            }

            protected GpuShaderCreator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GpuShaderCreator()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Start to collect the shader data.</summary>
            public virtual void Begin(string uid)
            {
                var ___BeginDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 2);
                ___BeginDelegate(__Instance, uid);
            }

            /// <summary>End to collect the shader data.</summary>
            public virtual void End()
            {
                var ___EndDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 3);
                ___EndDelegate(__Instance);
            }

            public bool HasDynamicProperty(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType type)
            {
                var ___ret = __Internal.HasDynamicProperty(__Instance, type);
                return ___ret;
            }

            /// <summary>Add a 1D or 2D texture</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the LUT data which must be used as-is as the dimensions and</para>
            /// <para>origin are hard-coded in the fragment shader program. So, it means one GPU texture per entry.</para>
            /// </remarks>
            public abstract void AddTexture(string textureName, string samplerName, uint width, uint height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values);

            /// <summary>Add a 3D texture with RGB channel type.</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the 3D LUT data which must be used as-is as the dimension</para>
            /// <para>and origin are hard-coded in the fragment shader program. So, it means one GPU 3D texture</para>
            /// <para>per entry.</para>
            /// </remarks>
            public abstract void Add3DTexture(string textureName, string samplerName, uint edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values);

            public virtual void AddToDeclareShaderCode(string shaderCode)
            {
                var ___AddToDeclareShaderCodeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 15);
                ___AddToDeclareShaderCodeDelegate(__Instance, shaderCode);
            }

            public virtual void AddToHelperShaderCode(string shaderCode)
            {
                var ___AddToHelperShaderCodeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 16);
                ___AddToHelperShaderCodeDelegate(__Instance, shaderCode);
            }

            public virtual void AddToFunctionHeaderShaderCode(string shaderCode)
            {
                var ___AddToFunctionHeaderShaderCodeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 17);
                ___AddToFunctionHeaderShaderCodeDelegate(__Instance, shaderCode);
            }

            public virtual void AddToFunctionShaderCode(string shaderCode)
            {
                var ___AddToFunctionShaderCodeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 18);
                ___AddToFunctionShaderCodeDelegate(__Instance, shaderCode);
            }

            public virtual void AddToFunctionFooterShaderCode(string shaderCode)
            {
                var ___AddToFunctionFooterShaderCodeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 19);
                ___AddToFunctionFooterShaderCodeDelegate(__Instance, shaderCode);
            }

            /// <summary>Create the OCIO shader program</summary>
            /// <remarks>
            /// <para>The OCIO shader program is decomposed to allow a specific implementation</para>
            /// <para>to change some parts. Some product integrations add the color processing</para>
            /// <para>within a client shader program, imposing constraints requiring this flexibility.</para>
            /// </remarks>
            public virtual void CreateShaderText(string shaderDeclarations, string shaderHelperMethods, string shaderFunctionHeader, string shaderFunctionBody, string shaderFunctionFooter)
            {
                var ___CreateShaderTextDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_string8_string8_string8>(0, 20);
                ___CreateShaderTextDelegate(__Instance, shaderDeclarations, shaderHelperMethods, shaderFunctionHeader, shaderFunctionBody, shaderFunctionFooter);
            }

            public virtual void Finalize()
            {
                var ___FinalizeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 21);
                ___FinalizeDelegate(__Instance);
            }

            protected global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl MImpl
            {
                get
                {
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.Impl.__GetOrCreateInstance(((__Internal*)__Instance)->m_impl, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->m_impl = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public string UniqueID
            {
                get
                {
                    var ___ret = __Internal.GetUniqueID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetUniqueID(__Instance, value);
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage Language
            {
                get
                {
                    var ___ret = __Internal.GetLanguage(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLanguage(__Instance, value);
                }
            }

            public string FunctionName
            {
                get
                {
                    var ___ret = __Internal.GetFunctionName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetFunctionName(__Instance, value);
                }
            }

            public string PixelName
            {
                get
                {
                    var ___ret = __Internal.GetPixelName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetPixelName(__Instance, value);
                }
            }

            /// <remarks>
            /// <para>Some applications require that textures, uniforms,</para>
            /// <para>and helper methods be uniquely named because several</para>
            /// <para>processor instances could coexist.</para>
            /// <para>Set a prefix to the resource name</para>
            /// </remarks>
            public string ResourcePrefix
            {
                get
                {
                    var ___ret = __Internal.GetResourcePrefix(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetResourcePrefix(__Instance, value);
                }
            }

            public virtual string CacheID
            {
                get
                {
                    var ___GetCacheIDDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetCacheIDDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public abstract uint TextureMaxWidth
            {
                get;

                set;
            }

            public abstract bool AllowTexture1D
            {
                get;

                set;
            }

            /// <summary>
            /// <para>To avoid global texture sampler and uniform name clashes always append an increasing index</para>
            /// <para>to the resource name.</para>
            /// </summary>
            public uint NextResourceIndex
            {
                get
                {
                    var ___ret = __Internal.GetNextResourceIndex(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Dynamic Property related methods.</summary>
            public uint NumDynamicProperties
            {
                get
                {
                    var ___ret = __Internal.GetNumDynamicProperties(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // char * getCacheID() const noexcept
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetCacheIDDelegateInstance;

            private static __IntPtr _GetCacheIDDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                var ___ret = __target.CacheID;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void begin(const char * uid)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _BeginDelegateInstance;

            private static void _BeginDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uid)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.Begin(uid);
            }

            // void end()
            private static global::OpenColorIO.Delegates.Action___IntPtr _EndDelegateInstance;

            private static void _EndDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.End();
            }

            // void setTextureMaxWidth(unsigned maxWidth) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint _SetTextureMaxWidthDelegateInstance;

            private static void _SetTextureMaxWidthDelegateHook(__IntPtr __instance, uint maxWidth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.TextureMaxWidth = maxWidth;
            }

            // unsigned getTextureMaxWidth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetTextureMaxWidthDelegateInstance;

            private static uint _GetTextureMaxWidthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                var ___ret = __target.TextureMaxWidth;
                return ___ret;
            }

            // void setAllowTexture1D(bool allowed) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetAllowTexture1DDelegateInstance;

            private static void _SetAllowTexture1DDelegateHook(__IntPtr __instance, bool allowed)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AllowTexture1D = allowed;
            }

            // bool getAllowTexture1D() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetAllowTexture1DDelegateInstance;

            private static bool _GetAllowTexture1DDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                var ___ret = __target.AllowTexture1D;
                return ___ret;
            }

            // void addTexture(const char * textureName, const char * samplerName, unsigned width, unsigned height, TextureType channel, TextureDimensions dimensions, Interpolation interpolation, const float * values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr _AddTextureDelegateInstance;

            private static void _AddTextureDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string textureName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string samplerName, uint width, uint height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, float* values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddTexture(textureName, samplerName, width, height, channel, dimensions, interpolation, ref *values);
            }

            // void add3DTexture(const char * textureName, const char * samplerName, unsigned edgelen, Interpolation interpolation, const float * values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr _Add3DTextureDelegateInstance;

            private static void _Add3DTextureDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string textureName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string samplerName, uint edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, float* values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.Add3DTexture(textureName, samplerName, edgelen, interpolation, ref *values);
            }

            // void addToDeclareShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToDeclareShaderCodeDelegateInstance;

            private static void _AddToDeclareShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddToDeclareShaderCode(shaderCode);
            }

            // void addToHelperShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToHelperShaderCodeDelegateInstance;

            private static void _AddToHelperShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddToHelperShaderCode(shaderCode);
            }

            // void addToFunctionHeaderShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionHeaderShaderCodeDelegateInstance;

            private static void _AddToFunctionHeaderShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddToFunctionHeaderShaderCode(shaderCode);
            }

            // void addToFunctionShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionShaderCodeDelegateInstance;

            private static void _AddToFunctionShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddToFunctionShaderCode(shaderCode);
            }

            // void addToFunctionFooterShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionFooterShaderCodeDelegateInstance;

            private static void _AddToFunctionFooterShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.AddToFunctionFooterShaderCode(shaderCode);
            }

            // void createShaderText(const char * shaderDeclarations, const char * shaderHelperMethods, const char * shaderFunctionHeader, const char * shaderFunctionBody, const char * shaderFunctionFooter)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_string8_string8_string8 _CreateShaderTextDelegateInstance;

            private static void _CreateShaderTextDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderDeclarations, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderHelperMethods, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionHeader, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionBody, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionFooter)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.CreateShaderText(shaderDeclarations, shaderHelperMethods, shaderFunctionHeader, shaderFunctionBody, shaderFunctionFooter);
            }

            // void finalize()
            private static global::OpenColorIO.Delegates.Action___IntPtr _FinalizeDelegateInstance;

            private static void _FinalizeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.Finalize();
            }

            // virtual ~GpuShaderCreator()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[17];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetCacheIDDelegateInstance += _GetCacheIDDelegateHook;
                    _BeginDelegateInstance += _BeginDelegateHook;
                    _EndDelegateInstance += _EndDelegateHook;
                    _SetTextureMaxWidthDelegateInstance += _SetTextureMaxWidthDelegateHook;
                    _GetTextureMaxWidthDelegateInstance += _GetTextureMaxWidthDelegateHook;
                    _SetAllowTexture1DDelegateInstance += _SetAllowTexture1DDelegateHook;
                    _GetAllowTexture1DDelegateInstance += _GetAllowTexture1DDelegateHook;
                    _AddTextureDelegateInstance += _AddTextureDelegateHook;
                    _Add3DTextureDelegateInstance += _Add3DTextureDelegateHook;
                    _AddToDeclareShaderCodeDelegateInstance += _AddToDeclareShaderCodeDelegateHook;
                    _AddToHelperShaderCodeDelegateInstance += _AddToHelperShaderCodeDelegateHook;
                    _AddToFunctionHeaderShaderCodeDelegateInstance += _AddToFunctionHeaderShaderCodeDelegateHook;
                    _AddToFunctionShaderCodeDelegateInstance += _AddToFunctionShaderCodeDelegateHook;
                    _AddToFunctionFooterShaderCodeDelegateInstance += _AddToFunctionFooterShaderCodeDelegateHook;
                    _CreateShaderTextDelegateInstance += _CreateShaderTextDelegateHook;
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCacheIDDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BeginDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_EndDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetTextureMaxWidthDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetTextureMaxWidthDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_SetAllowTexture1DDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetAllowTexture1DDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_AddTextureDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_Add3DTextureDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AddToDeclareShaderCodeDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_AddToHelperShaderCodeDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionHeaderShaderCodeDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionShaderCodeDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionFooterShaderCodeDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_CreateShaderTextDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTablesDtorOnly[0][22] = Thunks[16];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][13] = Thunks[7];
                                ManagedVTables[0][14] = Thunks[8];
                                ManagedVTables[0][15] = Thunks[9];
                                ManagedVTables[0][16] = Thunks[10];
                                ManagedVTables[0][17] = Thunks[11];
                                ManagedVTables[0][18] = Thunks[12];
                                ManagedVTables[0][19] = Thunks[13];
                                ManagedVTables[0][20] = Thunks[14];
                                ManagedVTables[0][21] = Thunks[15];
                                ManagedVTables[0][22] = Thunks[16];
                                VTables.Methods[0] = new Delegate[23];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>This class holds the GPU-related information needed to build a shader program</para>
        /// <para>from a specific processor.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class defines the interface and there are two implementations provided.</para>
        /// <para>The &quot;legacy&quot; mode implements the OCIO v1 approach of baking certain ops</para>
        /// <para>in order to have at most one 3D-LUT.  The &quot;generic&quot; mode is the v2 default and</para>
        /// <para>allows all the ops to be processed as-is, without baking, like the CPU renderer.</para>
        /// <para>Custom implementations could be written to accommodate the GPU needs of a</para>
        /// <para>specific client app.</para>
        /// <para>The complete fragment shader program is decomposed in two main parts:</para>
        /// <para>the OCIO shader program for the color processing and the client shader</para>
        /// <para>program which consumes the pixel color processing.</para>
        /// <para>The OCIO shader program is fully described by the GpuShaderDesc</para>
        /// <para>independently from the client shader program. The only critical</para>
        /// <para>point is the agreement on the OCIO function shader name.</para>
        /// <para>To summarize, the complete shader program is:</para>
        /// <para></para>
        /// <para>**Usage Example:** *Building a GPU shader*</para>
        /// <para>This example is based on the code in: src/apps/ociodisplay/main.cpp</para>
        /// </remarks>
        public unsafe abstract partial class GpuShaderDesc : global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GpuShaderCreator;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GpuShaderDesc@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getShaderText@GpuShaderDesc@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetShaderText(__IntPtr __instance);
            }

            /// <summary>
            /// <para>Used to retrieve uniform information. UniformData m_type indicates the type of uniform</para>
            /// <para>and what member of the structure should be used:</para>
            /// <para>* UNIFORM_DOUBLE: m_getDouble.</para>
            /// <para>* UNIFORM_BOOL: m_getBool.</para>
            /// <para>* UNIFORM_FLOAT3: m_getFloat3.</para>
            /// <para>* UNIFORM_VECTOR_FLOAT: m_vectorFloat.</para>
            /// <para>* UNIFORM_VECTOR_INT: m_vectorInt.</para>
            /// </summary>
            public unsafe partial class UniformData : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 456)]
                public partial struct __Internal
                {
                    internal global::OpenColorIO.OpenColorIO_v2_4.UniformDataType m_type;
                    internal global::Std.Function.__Internal m_getDouble;
                    internal global::Std.Function.__Internal m_getBool;
                    internal global::Std.Function.__Internal m_getFloat3;
                    internal global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__Internal m_vectorFloat;
                    internal global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__Internal m_vectorInt;

                    [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                    [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr ctor(__IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void dtor(__IntPtr __instance);
                }

                public unsafe partial class VectorFloat : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 128)]
                    public partial struct __Internal
                    {
                        internal global::Std.Function.__Internal m_getSize;
                        internal global::Std.Function.__Internal m_getVector;

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0VectorFloat@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@AEBU0123@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0VectorFloat@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr ctor(__IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1VectorFloat@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern void dtor(__IntPtr __instance);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static VectorFloat __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new VectorFloat(native.ToPointer(), skipVTables);
                    }

                    internal static VectorFloat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (VectorFloat)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static VectorFloat __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new VectorFloat(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__Internal.cctor(ret, new __IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private VectorFloat(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected VectorFloat(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public VectorFloat(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public VectorFloat()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        __Internal.ctor(__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (callNativeDtor)
                            __Internal.dtor(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                public unsafe partial class VectorInt : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 128)]
                    public partial struct __Internal
                    {
                        internal global::Std.Function.__Internal m_getSize;
                        internal global::Std.Function.__Internal m_getVector;

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0VectorInt@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@AEBU0123@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0VectorInt@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr ctor(__IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1VectorInt@UniformData@GpuShaderDesc@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern void dtor(__IntPtr __instance);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static VectorInt __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new VectorInt(native.ToPointer(), skipVTables);
                    }

                    internal static VectorInt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (VectorInt)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static VectorInt __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new VectorInt(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__Internal.cctor(ret, new __IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private VectorInt(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected VectorInt(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public VectorInt(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public VectorInt()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        __Internal.ctor(__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (callNativeDtor)
                            __Internal.dtor(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static UniformData __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new UniformData(native.ToPointer(), skipVTables);
                }

                internal static UniformData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (UniformData)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static UniformData __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new UniformData(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.__Internal.cctor(ret, new __IntPtr(&native));
                    return ret.ToPointer();
                }

                private UniformData(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected UniformData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public UniformData(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public UniformData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    __Internal.ctor(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (callNativeDtor)
                        __Internal.dtor(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::OpenColorIO.OpenColorIO_v2_4.UniformDataType MType
                {
                    get
                    {
                        return ((__Internal*)__Instance)->m_type;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->m_type = value;
                    }
                }

                public global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat MVectorFloat
                {
                    get
                    {
                        return global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_vectorFloat));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((__Internal*)__Instance)->m_vectorFloat = *(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorFloat.__Internal*) value.__Instance;
                    }
                }

                public global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt MVectorInt
                {
                    get
                    {
                        return global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_vectorInt));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((__Internal*)__Instance)->m_vectorInt = *(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.VectorInt.__Internal*) value.__Instance;
                    }
                }
            }

            internal static new GpuShaderDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GpuShaderDescInternal(native.ToPointer(), skipVTables);
            }

            internal static new GpuShaderDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GpuShaderDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GpuShaderDesc __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GpuShaderDesc)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GpuShaderDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GpuShaderDescInternal(native, skipVTables);
            }

            protected GpuShaderDesc(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GpuShaderDesc()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Returns name of uniform and data as parameter.</summary>
            public abstract string GetUniform(uint index, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData data);

            public abstract void GetTexture(uint index, string textureName, string samplerName, ref uint width, ref uint height, ref global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, ref global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, ref global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation);

            public abstract void GetTextureValues(uint index, float* values);

            public abstract void Get3DTexture(uint index, string textureName, string samplerName, ref uint edgelen, ref global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation);

            public abstract void Get3DTextureValues(uint index, float* values);

            public abstract uint NumUniforms
            {
                get;
            }

            public abstract uint NumTextures
            {
                get;
            }

            public abstract uint Num3DTextures
            {
                get;
            }

            /// <summary>Get the complete OCIO shader program.</summary>
            public string ShaderText
            {
                get
                {
                    var ___ret = __Internal.GetShaderText(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            #region Virtual table interop

            // char * getCacheID() const noexcept
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetCacheIDDelegateInstance;

            private static __IntPtr _GetCacheIDDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.CacheID;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void begin(const char * uid)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _BeginDelegateInstance;

            private static void _BeginDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uid)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Begin(uid);
            }

            // void end()
            private static global::OpenColorIO.Delegates.Action___IntPtr _EndDelegateInstance;

            private static void _EndDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.End();
            }

            // void setTextureMaxWidth(unsigned maxWidth) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint _SetTextureMaxWidthDelegateInstance;

            private static void _SetTextureMaxWidthDelegateHook(__IntPtr __instance, uint maxWidth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.TextureMaxWidth = maxWidth;
            }

            // unsigned getTextureMaxWidth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetTextureMaxWidthDelegateInstance;

            private static uint _GetTextureMaxWidthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.TextureMaxWidth;
                return ___ret;
            }

            // void setAllowTexture1D(bool allowed) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetAllowTexture1DDelegateInstance;

            private static void _SetAllowTexture1DDelegateHook(__IntPtr __instance, bool allowed)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AllowTexture1D = allowed;
            }

            // bool getAllowTexture1D() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetAllowTexture1DDelegateInstance;

            private static bool _GetAllowTexture1DDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.AllowTexture1D;
                return ___ret;
            }

            // void addTexture(const char * textureName, const char * samplerName, unsigned width, unsigned height, TextureType channel, TextureDimensions dimensions, Interpolation interpolation, const float * values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr _AddTextureDelegateInstance;

            private static void _AddTextureDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string textureName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string samplerName, uint width, uint height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, float* values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddTexture(textureName, samplerName, width, height, channel, dimensions, interpolation, ref *values);
            }

            // void add3DTexture(const char * textureName, const char * samplerName, unsigned edgelen, Interpolation interpolation, const float * values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr _Add3DTextureDelegateInstance;

            private static void _Add3DTextureDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string textureName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string samplerName, uint edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, float* values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Add3DTexture(textureName, samplerName, edgelen, interpolation, ref *values);
            }

            // void addToDeclareShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToDeclareShaderCodeDelegateInstance;

            private static void _AddToDeclareShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddToDeclareShaderCode(shaderCode);
            }

            // void addToHelperShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToHelperShaderCodeDelegateInstance;

            private static void _AddToHelperShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddToHelperShaderCode(shaderCode);
            }

            // void addToFunctionHeaderShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionHeaderShaderCodeDelegateInstance;

            private static void _AddToFunctionHeaderShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddToFunctionHeaderShaderCode(shaderCode);
            }

            // void addToFunctionShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionShaderCodeDelegateInstance;

            private static void _AddToFunctionShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddToFunctionShaderCode(shaderCode);
            }

            // void addToFunctionFooterShaderCode(const char * shaderCode)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddToFunctionFooterShaderCodeDelegateInstance;

            private static void _AddToFunctionFooterShaderCodeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderCode)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.AddToFunctionFooterShaderCode(shaderCode);
            }

            // void createShaderText(const char * shaderDeclarations, const char * shaderHelperMethods, const char * shaderFunctionHeader, const char * shaderFunctionBody, const char * shaderFunctionFooter)
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_string8_string8_string8 _CreateShaderTextDelegateInstance;

            private static void _CreateShaderTextDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderDeclarations, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderHelperMethods, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionHeader, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionBody, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shaderFunctionFooter)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.CreateShaderText(shaderDeclarations, shaderHelperMethods, shaderFunctionHeader, shaderFunctionBody, shaderFunctionFooter);
            }

            // void finalize()
            private static global::OpenColorIO.Delegates.Action___IntPtr _FinalizeDelegateInstance;

            private static void _FinalizeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Finalize();
            }

            // virtual ~GpuShaderDesc()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // unsigned getNumUniforms() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetNumUniformsDelegateInstance;

            private static uint _GetNumUniformsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.NumUniforms;
                return ___ret;
            }

            // char * getUniform(unsigned index, UniformData & data) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_uint___IntPtr _GetUniformDelegateInstance;

            private static __IntPtr _GetUniformDelegateHook(__IntPtr __instance, uint index, __IntPtr data)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var __result1 = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData.__GetOrCreateInstance(data, false);
                var ___ret = __target.GetUniform(index, __result1);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // unsigned getNumTextures() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetNumTexturesDelegateInstance;

            private static uint _GetNumTexturesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.NumTextures;
                return ___ret;
            }

            // void getTexture(unsigned index, const char *& textureName, const char *& samplerName, unsigned & width, unsigned & height, TextureType & channel, TextureDimensions & dimensions, Interpolation & interpolation) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureTypePtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensionsPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr _GetTextureDelegateInstance;

            private static void _GetTextureDelegateHook(__IntPtr __instance, uint index, string textureName, string samplerName, uint* width, uint* height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType* channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions* dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation* interpolation)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.GetTexture(index, textureName, samplerName, ref *width, ref *height, ref *channel, ref *dimensions, ref *interpolation);
            }

            // void getTextureValues(unsigned index, const float *& values) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtrPtr _GetTextureValuesDelegateInstance;

            private static void _GetTextureValuesDelegateHook(__IntPtr __instance, uint index, float** values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.GetTextureValues(index, *values);
            }

            // unsigned getNum3DTextures() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetNum3DTexturesDelegateInstance;

            private static uint _GetNum3DTexturesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                var ___ret = __target.Num3DTextures;
                return ___ret;
            }

            // void get3DTexture(unsigned index, const char *& textureName, const char *& samplerName, unsigned & edgelen, Interpolation & interpolation) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr _Get3DTextureDelegateInstance;

            private static void _Get3DTextureDelegateHook(__IntPtr __instance, uint index, string textureName, string samplerName, uint* edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation* interpolation)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Get3DTexture(index, textureName, samplerName, ref *edgelen, ref *interpolation);
            }

            // void get3DTextureValues(unsigned index, const float *& values) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtrPtr _Get3DTextureValuesDelegateInstance;

            private static void _Get3DTextureValuesDelegateHook(__IntPtr __instance, uint index, float** values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.__GetInstance(__instance);
                __target.Get3DTextureValues(index, *values);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[25];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetCacheIDDelegateInstance += _GetCacheIDDelegateHook;
                    _BeginDelegateInstance += _BeginDelegateHook;
                    _EndDelegateInstance += _EndDelegateHook;
                    _SetTextureMaxWidthDelegateInstance += _SetTextureMaxWidthDelegateHook;
                    _GetTextureMaxWidthDelegateInstance += _GetTextureMaxWidthDelegateHook;
                    _SetAllowTexture1DDelegateInstance += _SetAllowTexture1DDelegateHook;
                    _GetAllowTexture1DDelegateInstance += _GetAllowTexture1DDelegateHook;
                    _AddTextureDelegateInstance += _AddTextureDelegateHook;
                    _Add3DTextureDelegateInstance += _Add3DTextureDelegateHook;
                    _AddToDeclareShaderCodeDelegateInstance += _AddToDeclareShaderCodeDelegateHook;
                    _AddToHelperShaderCodeDelegateInstance += _AddToHelperShaderCodeDelegateHook;
                    _AddToFunctionHeaderShaderCodeDelegateInstance += _AddToFunctionHeaderShaderCodeDelegateHook;
                    _AddToFunctionShaderCodeDelegateInstance += _AddToFunctionShaderCodeDelegateHook;
                    _AddToFunctionFooterShaderCodeDelegateInstance += _AddToFunctionFooterShaderCodeDelegateHook;
                    _CreateShaderTextDelegateInstance += _CreateShaderTextDelegateHook;
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetNumUniformsDelegateInstance += _GetNumUniformsDelegateHook;
                    _GetUniformDelegateInstance += _GetUniformDelegateHook;
                    _GetNumTexturesDelegateInstance += _GetNumTexturesDelegateHook;
                    _GetTextureDelegateInstance += _GetTextureDelegateHook;
                    _GetTextureValuesDelegateInstance += _GetTextureValuesDelegateHook;
                    _GetNum3DTexturesDelegateInstance += _GetNum3DTexturesDelegateHook;
                    _Get3DTextureDelegateInstance += _Get3DTextureDelegateHook;
                    _Get3DTextureValuesDelegateInstance += _Get3DTextureValuesDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCacheIDDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BeginDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_EndDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetTextureMaxWidthDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetTextureMaxWidthDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_SetAllowTexture1DDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetAllowTexture1DDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_AddTextureDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_Add3DTextureDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AddToDeclareShaderCodeDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_AddToHelperShaderCodeDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionHeaderShaderCodeDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionShaderCodeDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_AddToFunctionFooterShaderCodeDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_CreateShaderTextDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetNumUniformsDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetUniformDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetNumTexturesDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_GetTextureDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_GetTextureValuesDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_GetNum3DTexturesDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_Get3DTextureDelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_Get3DTextureValuesDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 31, 0);
                                ManagedVTablesDtorOnly[0][22] = Thunks[16];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 31, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][13] = Thunks[7];
                                ManagedVTables[0][14] = Thunks[8];
                                ManagedVTables[0][15] = Thunks[9];
                                ManagedVTables[0][16] = Thunks[10];
                                ManagedVTables[0][17] = Thunks[11];
                                ManagedVTables[0][18] = Thunks[12];
                                ManagedVTables[0][19] = Thunks[13];
                                ManagedVTables[0][20] = Thunks[14];
                                ManagedVTables[0][21] = Thunks[15];
                                ManagedVTables[0][22] = Thunks[16];
                                ManagedVTables[0][23] = Thunks[17];
                                ManagedVTables[0][24] = Thunks[18];
                                ManagedVTables[0][25] = Thunks[19];
                                ManagedVTables[0][26] = Thunks[20];
                                ManagedVTables[0][27] = Thunks[21];
                                ManagedVTables[0][28] = Thunks[22];
                                ManagedVTables[0][29] = Thunks[23];
                                ManagedVTables[0][30] = Thunks[24];
                                VTables.Methods[0] = new Delegate[31];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Context</summary>
        /// <remarks>
        /// <para>A context defines some overrides to a Config. For example, it can override the</para>
        /// <para>search path or change the value of a context variable.</para>
        /// <para>Only somemethods accept a custom context; otherwise,</para>
        /// <para>the default context instance is used (see</para>
        /// <para>Context Variables</para>
        /// <para>The context variables allow changes at runtime using environment variables. For example,</para>
        /// <para>a color space name (such as src&amp;dst for the ColorSpaceTransform) or a file</para>
        /// <para>name (such as LUT file name for the FileTransform) could be defined by context</para>
        /// <para>variables. The color transformation is then customized based on some environment variables.</para>
        /// <para>In a config the context variables support three syntaxes (i.e. ${VAR}, $VAR and %VAR%) and</para>
        /// <para>the parsing starts from longest to shortest. So, the resolve works like '$TEST_$TESTING_$TE'</para>
        /// <para>expands in this order '2 1 3'.</para>
        /// <para>Config authors are recommended to include the &quot;environment&quot; section in their configs. This</para>
        /// <para>improves performance as well as making the config more readable. When present, this section</para>
        /// <para>must declare all context variables used in the config. It may also provide a default value,</para>
        /// <para>in case the variable is not present in the user's environment.</para>
        /// <para>A context variable may only be used in the following places:</para>
        /// <para>* theto define the source and the destination color space names,</para>
        /// <para>* theto define the source file name (e.g. a LUT file name),</para>
        /// <para>* the search_path,</para>
        /// <para>* the cccid of theto only extract one specific transform from</para>
        /// <para>the CDL&amp;CCC files.</para>
        /// <para>Some specific restrictions are worth calling out:</para>
        /// <para>* they cannot be used as either the name or value of a role,</para>
        /// <para>* the context variable characters $ and % are prohibited in a color space name.</para>
        /// </remarks>
        public unsafe partial class Context : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??1Context@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSearchPath@Context@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSearchPath(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearSearchPaths@Context@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearSearchPaths(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?addSearchPath@Context@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSearchPath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setStringVar@Context@OpenColorIO_v2_4@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStringVar(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getStringVar@Context@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringVar(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getStringVarNameByIndex@Context@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringVarNameByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getStringVarByIndex@Context@OpenColorIO_v2_4@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStringVarByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?clearStringVars@Context@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearStringVars(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?loadEnvironment@Context@OpenColorIO_v2_4@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LoadEnvironment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?resolveStringVar@Context@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ResolveStringVar(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?resolveFileLocation@Context@OpenColorIO_v2_4@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ResolveFileLocation(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCacheID@Context@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCacheID(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSearchPath@Context@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSearchPath(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSearchPath@Context@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSearchPath(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumSearchPaths@Context@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumSearchPaths(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getWorkingDir@Context@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetWorkingDir(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setWorkingDir@Context@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWorkingDir(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dirname);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumStringVars@Context@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumStringVars(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getEnvironmentMode@Context@OpenColorIO_v2_4@@QEBA?AW4EnvironmentMode@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode GetEnvironmentMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setEnvironmentMode@Context@OpenColorIO_v2_4@@QEAAXW4EnvironmentMode@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEnvironmentMode(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode mode);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Context> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Context>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Context managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Context managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Context __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Context(native.ToPointer(), skipVTables);
            }

            internal static Context __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Context)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Context __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Context(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Context(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Context(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string GetSearchPath(int index)
            {
                var ___ret = __Internal.GetSearchPath(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearSearchPaths()
            {
                __Internal.ClearSearchPaths(__Instance);
            }

            public void AddSearchPath(string path)
            {
                __Internal.AddSearchPath(__Instance, path);
            }

            /// <summary>
            /// <para>Add (or update) a context variable. But it removes it if the value argument is null.</para>
            /// <para>Note that a Context StringVar is the same thing as a Config EnvironmentVar and these</para>
            /// <para>are both often referred to as a &quot;context var&quot;.</para>
            /// </summary>
            public void SetStringVar(string name, string value)
            {
                __Internal.SetStringVar(__Instance, name, value);
            }

            /// <summary>
            /// <para>Get the context variable value. It returns an empty string if the context</para>
            /// <para>variable is null or does not exist.</para>
            /// </summary>
            public string GetStringVar(string name)
            {
                var ___ret = __Internal.GetStringVar(__Instance, name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetStringVarNameByIndex(int index)
            {
                var ___ret = __Internal.GetStringVarNameByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string GetStringVarByIndex(int index)
            {
                var ___ret = __Internal.GetStringVarByIndex(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public void ClearStringVars()
            {
                __Internal.ClearStringVars(__Instance);
            }

            /// <summary>Seed string vars with the current environment, based on the EnvironmentMode setting.</summary>
            public void LoadEnvironment()
            {
                __Internal.LoadEnvironment(__Instance);
            }

            /// <summary>
            /// <para>Resolve all the context variables from the string. It could be color space</para>
            /// <para>names or file names. Note that it recursively applies the context variable resolution.</para>
            /// <para>Returns the string unchanged if it does not contain any context variable.</para>
            /// </summary>
            public string ResolveStringVar(string @string)
            {
                var ___ret = __Internal.ResolveStringVar(__Instance, @string);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Build the resolved and expanded filepath using the search_path when needed,</para>
            /// <para>and check if the filepath exists. If it cannot be resolved or found, an exception will be</para>
            /// <para>thrown. The method argument is directly from the config file so it can be an absolute or</para>
            /// <para>relative file path or a file name.</para>
            /// </summary>
            /// <remarks>
            /// <para>The filepath existence check could add a performance hit.</para>
            /// <para>The context variable resolution is performed using :cpp:func:`resolveStringVar`.</para>
            /// </remarks>
            public string ResolveFileLocation(string filename)
            {
                var ___ret = __Internal.ResolveFileLocation(__Instance, filename);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string CacheID
            {
                get
                {
                    var ___ret = __Internal.GetCacheID(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public string SearchPath
            {
                get
                {
                    var ___ret = __Internal.GetSearchPath(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSearchPath(__Instance, value);
                }
            }

            public int NumSearchPaths
            {
                get
                {
                    var ___ret = __Internal.GetNumSearchPaths(__Instance);
                    return ___ret;
                }
            }

            public string WorkingDir
            {
                get
                {
                    var ___ret = __Internal.GetWorkingDir(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetWorkingDir(__Instance, value);
                }
            }

            public int NumStringVars
            {
                get
                {
                    var ___ret = __Internal.GetNumStringVars(__Instance);
                    return ___ret;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode EnvironmentMode
            {
                get
                {
                    var ___ret = __Internal.GetEnvironmentMode(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetEnvironmentMode(__Instance, value);
                }
            }
        }

        /// <summary>
        /// <para>The built-in transform registry contains all the existing built-in transforms which can</para>
        /// <para>be used by a configuration (version 2 or higher only).</para>
        /// </summary>
        public unsafe abstract partial class BuiltinTransformRegistry : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_BuiltinTransformRegistry;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0BuiltinTransformRegistry@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BuiltinTransformRegistry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BuiltinTransformRegistryInternal(native.ToPointer(), skipVTables);
            }

            internal static BuiltinTransformRegistry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BuiltinTransformRegistry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BuiltinTransformRegistry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BuiltinTransformRegistry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BuiltinTransformRegistry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BuiltinTransformRegistryInternal(native, skipVTables);
            }

            protected BuiltinTransformRegistry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected BuiltinTransformRegistry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get the style string for the i-th built-in transform.</para>
            /// <para>The style is the ID string that identifies a given transform.</para>
            /// </summary>
            public abstract string GetBuiltinStyle(ulong index);

            /// <summary>Get the description string for the i-th built-in transform.</summary>
            public abstract string GetBuiltinDescription(ulong index);

            /// <summary>Get the number of built-in transforms available.</summary>
            public abstract ulong NumBuiltins
            {
                get;
            }

            #region Virtual table interop

            // size_t getNumBuiltins() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumBuiltinsDelegateInstance;

            private static ulong _GetNumBuiltinsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry.__GetInstance(__instance);
                var ___ret = __target.NumBuiltins;
                return ___ret;
            }

            // char * getBuiltinStyle(size_t index) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetBuiltinStyleDelegateInstance;

            private static __IntPtr _GetBuiltinStyleDelegateHook(__IntPtr __instance, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinStyle(index);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getBuiltinDescription(size_t index) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetBuiltinDescriptionDelegateInstance;

            private static __IntPtr _GetBuiltinDescriptionDelegateHook(__IntPtr __instance, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinDescription(index);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // virtual ~BuiltinTransformRegistry() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[4];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNumBuiltinsDelegateInstance += _GetNumBuiltinsDelegateHook;
                    _GetBuiltinStyleDelegateInstance += _GetBuiltinStyleDelegateHook;
                    _GetBuiltinDescriptionDelegateInstance += _GetBuiltinDescriptionDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNumBuiltinsDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinStyleDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinDescriptionDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][3] = Thunks[3];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>The built-in configs registry contains information about all the existing built-in configs.</summary>
        public unsafe abstract partial class BuiltinConfigRegistry : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_BuiltinConfigRegistry;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0BuiltinConfigRegistry@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?Get@BuiltinConfigRegistry@OpenColorIO_v2_4@@SAAEBV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Get();
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BuiltinConfigRegistry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BuiltinConfigRegistryInternal(native.ToPointer(), skipVTables);
            }

            internal static BuiltinConfigRegistry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BuiltinConfigRegistry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BuiltinConfigRegistry __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BuiltinConfigRegistry)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BuiltinConfigRegistry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BuiltinConfigRegistryInternal(native, skipVTables);
            }

            protected BuiltinConfigRegistry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected BuiltinConfigRegistry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get the name of the config at the specified (zero-based) index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            public abstract string GetBuiltinConfigName(ulong configIndex);

            /// <summary>Throws for illegal index.</summary>
            public abstract string GetBuiltinConfigUIName(ulong configIndex);

            /// <summary>
            /// <para>Get Yaml text of the built-in config at the specified index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            public abstract string GetBuiltinConfig(ulong configIndex);

            /// <summary>
            /// <para>Get the Yaml text of the built-in config with the specified name.</para>
            /// <para>Throws if the name is not found.</para>
            /// </summary>
            public abstract string GetBuiltinConfigByName(string configName);

            /// <summary>Check if a specific built-in config is recommended.</summary>
            /// <param name="configIndex">Index of built-in config.</param>
            /// <returns>true if the config is recommended.</returns>
            /// <remarks>
            /// <para>For backwards compatibility reasons, configs will remain in the registry even if they have</para>
            /// <para>been superseded. If an app is presenting a list of configs to users, it should not include</para>
            /// <para>configs that are no longer recommended.</para>
            /// <para>Throws if the name is not found.</para>
            /// </remarks>
            public abstract bool IsBuiltinConfigRecommended(ulong configIndex);

            /// <summary>Get the current built-in configs registry.</summary>
            public static global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry Get()
            {
                var ___ret = __Internal.Get();
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Get the number of built-in configs available.</summary>
            public abstract ulong NumBuiltinConfigs
            {
                get;
            }

            public abstract string DefaultBuiltinConfigName
            {
                get;
            }

            #region Virtual table interop

            // size_t getNumBuiltinConfigs() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumBuiltinConfigsDelegateInstance;

            private static ulong _GetNumBuiltinConfigsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.NumBuiltinConfigs;
                return ___ret;
            }

            // char * getBuiltinConfigName(size_t configIndex) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetBuiltinConfigNameDelegateInstance;

            private static __IntPtr _GetBuiltinConfigNameDelegateHook(__IntPtr __instance, ulong configIndex)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinConfigName(configIndex);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getBuiltinConfigUIName(size_t configIndex) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetBuiltinConfigUINameDelegateInstance;

            private static __IntPtr _GetBuiltinConfigUINameDelegateHook(__IntPtr __instance, ulong configIndex)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinConfigUIName(configIndex);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getBuiltinConfig(size_t configIndex) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetBuiltinConfigDelegateInstance;

            private static __IntPtr _GetBuiltinConfigDelegateHook(__IntPtr __instance, ulong configIndex)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinConfig(configIndex);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getBuiltinConfigByName(const char * configName) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8 _GetBuiltinConfigByNameDelegateInstance;

            private static __IntPtr _GetBuiltinConfigByNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string configName)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.GetBuiltinConfigByName(configName);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // bool isBuiltinConfigRecommended(size_t configIndex) const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr_ulong _IsBuiltinConfigRecommendedDelegateInstance;

            private static bool _IsBuiltinConfigRecommendedDelegateHook(__IntPtr __instance, ulong configIndex)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.IsBuiltinConfigRecommended(configIndex);
                return ___ret;
            }

            // char * getDefaultBuiltinConfigName() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetDefaultBuiltinConfigNameDelegateInstance;

            private static __IntPtr _GetDefaultBuiltinConfigNameDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                var ___ret = __target.DefaultBuiltinConfigName;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // virtual ~BuiltinConfigRegistry() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[8];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNumBuiltinConfigsDelegateInstance += _GetNumBuiltinConfigsDelegateHook;
                    _GetBuiltinConfigNameDelegateInstance += _GetBuiltinConfigNameDelegateHook;
                    _GetBuiltinConfigUINameDelegateInstance += _GetBuiltinConfigUINameDelegateHook;
                    _GetBuiltinConfigDelegateInstance += _GetBuiltinConfigDelegateHook;
                    _GetBuiltinConfigByNameDelegateInstance += _GetBuiltinConfigByNameDelegateHook;
                    _IsBuiltinConfigRecommendedDelegateInstance += _IsBuiltinConfigRecommendedDelegateHook;
                    _GetDefaultBuiltinConfigNameDelegateInstance += _GetDefaultBuiltinConfigNameDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNumBuiltinConfigsDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinConfigNameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinConfigUINameDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinConfigDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetBuiltinConfigByNameDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_IsBuiltinConfigRecommendedDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetDefaultBuiltinConfigNameDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8, 0);
                                ManagedVTablesDtorOnly[0][7] = Thunks[7];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                VTables.Methods[0] = new Delegate[8];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Provides access to the ICC monitor profile provided by the operating system for each active display.</summary>
        public unsafe abstract partial class SystemMonitors : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_SystemMonitors;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0SystemMonitors@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SystemMonitors __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SystemMonitorsInternal(native.ToPointer(), skipVTables);
            }

            internal static SystemMonitors __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SystemMonitors)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SystemMonitors __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (SystemMonitors)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static SystemMonitors __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SystemMonitorsInternal(native, skipVTables);
            }

            protected SystemMonitors(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected SystemMonitors()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.SystemMonitors");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <remarks>
            /// <para>Get the monitor profile name.</para>
            /// <para>Get the string describing the monitor. It is used as an argument to instantiateDisplay. It</para>
            /// <para>may also be used in a UI to ask a user which of several monitors they want to instantiate a</para>
            /// <para>display for.</para>
            /// </remarks>
            public abstract string GetMonitorName(ulong idx);

            /// <summary>Get the ICC profile path associated to the monitor.</summary>
            public abstract string GetProfileFilepath(ulong idx);

            /// <summary>
            /// <para>True if the OS is able to provide ICC profiles for the attached monitors (macOS, Windows)</para>
            /// <para>and false otherwise.</para>
            /// </summary>
            public abstract bool IsSupported
            {
                get;
            }

            /// <summary>Get the number of active monitors reported by the operating system.</summary>
            public abstract ulong NumMonitors
            {
                get;
            }

            #region Virtual table interop

            // bool isSupported() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsSupportedDelegateInstance;

            private static bool _IsSupportedDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__GetInstance(__instance);
                var ___ret = __target.IsSupported;
                return ___ret;
            }

            // size_t getNumMonitors() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumMonitorsDelegateInstance;

            private static ulong _GetNumMonitorsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__GetInstance(__instance);
                var ___ret = __target.NumMonitors;
                return ___ret;
            }

            // char * getMonitorName(size_t idx) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetMonitorNameDelegateInstance;

            private static __IntPtr _GetMonitorNameDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__GetInstance(__instance);
                var ___ret = __target.GetMonitorName(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getProfileFilepath(size_t idx) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetProfileFilepathDelegateInstance;

            private static __IntPtr _GetProfileFilepathDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__GetInstance(__instance);
                var ___ret = __target.GetProfileFilepath(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // virtual ~SystemMonitors() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _IsSupportedDelegateInstance += _IsSupportedDelegateHook;
                    _GetNumMonitorsDelegateInstance += _GetNumMonitorsDelegateHook;
                    _GetMonitorNameDelegateInstance += _GetMonitorNameDelegateHook;
                    _GetProfileFilepathDelegateInstance += _GetProfileFilepathDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsSupportedDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetNumMonitorsDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetMonitorNameDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetProfileFilepathDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTablesDtorOnly[0][4] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                VTables.Methods[0] = new Delegate[5];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>ConfigIOProxy is a proxy class to allow the calling program to supply the config and any</para>
        /// <para>associated LUT files directly, without relying on the standard file system.</para>
        /// </summary>
        /// <remarks>The OCIOZ archive feature is implemented using this mechanism.</remarks>
        public unsafe abstract partial class ConfigIOProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_ConfigIOProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ConfigIOProxy@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ConfigIOProxy@OpenColorIO_v2_4@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ConfigIOProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ConfigIOProxyInternal(native.ToPointer(), skipVTables);
            }

            internal static ConfigIOProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ConfigIOProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ConfigIOProxy __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ConfigIOProxy)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ConfigIOProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ConfigIOProxyInternal(native, skipVTables);
            }

            protected ConfigIOProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ConfigIOProxy()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy");
            }

            protected ConfigIOProxy(global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Provide a fast unique ID for a LUT file.</summary>
            /// <param name="filepath">Fully resolve the path to the &quot;file.&quot;</param>
            /// <returns>The file hash string.</returns>
            /// <remarks>
            /// <para>This is intended to supply the string that will be used in OCIO's FileCacheMap.</para>
            /// <para>This should be highly performant and typically should not require extensive</para>
            /// <para>computation such as calculating the md5 hash of the file, unless it is pre-computed.</para>
            /// <para>If the &quot;file&quot; does not exist, in other words, if the proxy is unable to supply the requested</para>
            /// <para>file contents, the function must return an empty string.</para>
            /// <para>The file path is based on the Config's current working directory and is the same absolute</para>
            /// <para>path that would have been provided to the file system.</para>
            /// </remarks>
            public abstract string GetFastLutFileHash(string filepath);

            /// <summary>Provide the config file Yaml to be parsed.</summary>
            /// <returns>String with the config Yaml.</returns>
            public abstract string ConfigData
            {
                get;
            }

            #region Virtual table interop

            // virtual ~ConfigIOProxy() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // std::string getConfigData() const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr _GetConfigDataDelegateInstance;

            private static void _GetConfigDataDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy.__GetInstance(__instance);
                var ___ret = __target.ConfigData;
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            // std::string getFastLutFileHash(const char * filepath) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr_string8 _GetFastLutFileHashDelegateInstance;

            private static void _GetFastLutFileHashDelegateHook(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filepath)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy.__GetInstance(__instance);
                var ___ret = __target.GetFastLutFileHash(filepath);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetConfigDataDelegateInstance += _GetConfigDataDelegateHook;
                    _GetFastLutFileHashDelegateInstance += _GetFastLutFileHashDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetConfigDataDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetFastLutFileHashDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class NamedTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.NamedTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal NamedTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal NamedTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Return empty string if idx is  out of range.</summary>
            public override string GetAlias(ulong idx)
            {
                var ___GetAliasDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 4);
                var ___ret = ___GetAliasDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Return true if alias exists.</summary>
            public override bool HasAlias(string alias)
            {
                var ___HasAliasDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr_string8>(0, 5);
                var ___ret = ___HasAliasDelegate(__Instance, alias);
                return ___ret;
            }

            /// <summary>
            /// <para>Nothing is done if alias is NULL or empty, if it is already there, or if it is already</para>
            /// <para>the named transform name.</para>
            /// </summary>
            public override void AddAlias(string alias)
            {
                var ___AddAliasDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 6);
                ___AddAliasDelegate(__Instance, alias);
            }

            /// <summary>Does nothing if alias is not present.</summary>
            public override void RemoveAlias(string alias)
            {
                var ___RemoveAliasDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 7);
                ___RemoveAliasDelegate(__Instance, alias);
            }

            public override void ClearAliases()
            {
                var ___ClearAliasesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 8);
                ___ClearAliasesDelegate(__Instance);
            }

            /// <remarks>ColorSpace::hasCategory</remarks>
            public override bool HasCategory(string category)
            {
                var ___HasCategoryDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr_string8>(0, 13);
                var ___ret = ___HasCategoryDelegate(__Instance, category);
                return ___ret;
            }

            /// <remarks>ColorSpace::addCategory</remarks>
            public override void AddCategory(string category)
            {
                var ___AddCategoryDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 14);
                ___AddCategoryDelegate(__Instance, category);
            }

            /// <remarks>ColorSpace::removeCategory</remarks>
            public override void RemoveCategory(string category)
            {
                var ___RemoveCategoryDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 15);
                ___RemoveCategoryDelegate(__Instance, category);
            }

            /// <remarks>ColorSpace::getCategory</remarks>
            public override string GetCategory(int index)
            {
                var ___GetCategoryDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int>(0, 17);
                var ___ret = ___GetCategoryDelegate(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <remarks>ColorSpace::clearCategories</remarks>
            public override void ClearCategories()
            {
                var ___ClearCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 18);
                ___ClearCategoriesDelegate(__Instance);
            }

            public override string Name
            {
                get
                {
                    var ___GetNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetNameDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 2);
                    ___SetNameDelegate(__Instance, value);
                }
            }

            /// <summary>Aliases can be used instead of the name. They must be unique within the config.</summary>
            public override ulong NumAliases
            {
                get
                {
                    var ___GetNumAliasesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 3);
                    var ___ret = ___GetNumAliasesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <remarks>
            /// <para>ColorSpace::getFamily</para>
            /// <para>ColorSpace::setFamily</para>
            /// </remarks>
            public override string Family
            {
                get
                {
                    var ___GetFamilyDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 9);
                    var ___ret = ___GetFamilyDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetFamilyDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 10);
                    ___SetFamilyDelegate(__Instance, value);
                }
            }

            public override string Description
            {
                get
                {
                    var ___GetDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 11);
                    var ___ret = ___GetDescriptionDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 12);
                    ___SetDescriptionDelegate(__Instance, value);
                }
            }

            /// <remarks>ColorSpace::getNumCategories</remarks>
            public override int NumCategories
            {
                get
                {
                    var ___GetNumCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 16);
                    var ___ret = ___GetNumCategoriesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>A NamedTransform is not a color space and does not have an encoding in the same sense.</para>
            /// <para>However, it may be useful to associate a color space encoding that the transform is intended</para>
            /// <para>to be used with, for organizational purposes.</para>
            /// </summary>
            public override string Encoding
            {
                get
                {
                    var ___GetEncodingDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 19);
                    var ___ret = ___GetEncodingDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetEncodingDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 20);
                    ___SetEncodingDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class ImageDescInternal : global::OpenColorIO.OpenColorIO_v2_4.ImageDesc, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ImageDescInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ImageDescInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Get a pointer to the red channel of the first pixel.</summary>
            public override __IntPtr RData
            {
                get
                {
                    var ___GetRDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 1);
                    var ___ret = ___GetRDataDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get a pointer to the green channel of the first pixel.</summary>
            public override __IntPtr GData
            {
                get
                {
                    var ___GetGDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetGDataDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get a pointer to the blue channel of the first pixel.</summary>
            public override __IntPtr BData
            {
                get
                {
                    var ___GetBDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetBDataDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Get a pointer to the alpha channel of the first pixel</para>
            /// <para>or null as alpha channel is optional.</para>
            /// </summary>
            public override __IntPtr AData
            {
                get
                {
                    var ___GetADataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 4);
                    var ___ret = ___GetADataDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the bit-depth.</summary>
            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepth
            {
                get
                {
                    var ___GetBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 5);
                    var ___ret = ___GetBitDepthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the width to process (where x position starts at 0 and ends at width-1).</summary>
            public override int Width
            {
                get
                {
                    var ___GetWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 6);
                    var ___ret = ___GetWidthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the height to process (where y position starts at 0 and ends at height-1).</summary>
            public override int Height
            {
                get
                {
                    var ___GetHeightDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 7);
                    var ___ret = ___GetHeightDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the step in bytes to find the same color channel of the next pixel.</summary>
            public override long XStrideBytes
            {
                get
                {
                    var ___GetXStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 8);
                    var ___ret = ___GetXStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Get the step in bytes to find the same color channel</para>
            /// <para>of the pixel at the same position in the next line.</para>
            /// </summary>
            public override long YStrideBytes
            {
                get
                {
                    var ___GetYStrideBytesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_long___IntPtr>(0, 9);
                    var ___ret = ___GetYStrideBytesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Is the image buffer in packed mode with the 4 color channels?</para>
            /// <para>(&quot;Packed&quot; here means that XStrideBytes is 4x the bytes per channel, so it is more specific</para>
            /// <para>than simply any PackedImageDesc.)</para>
            /// </summary>
            public override bool IsRGBAPacked
            {
                get
                {
                    var ___IsRGBAPackedDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 10);
                    var ___ret = ___IsRGBAPackedDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Is the image buffer 32-bit float?</summary>
            public override bool IsFloat
            {
                get
                {
                    var ___IsFloatDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 11);
                    var ___ret = ___IsFloatDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class GpuShaderCreatorInternal : global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GpuShaderCreatorInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GpuShaderCreatorInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Add a 1D or 2D texture</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the LUT data which must be used as-is as the dimensions and</para>
            /// <para>origin are hard-coded in the fragment shader program. So, it means one GPU texture per entry.</para>
            /// </remarks>
            public override void AddTexture(string textureName, string samplerName, uint width, uint height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values)
            {
                var ___AddTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr>(0, 13);
                fixed (float* __values7 = &values)
                {
                    var __arg7 = __values7;
                    ___AddTextureDelegate(__Instance, textureName, samplerName, width, height, channel, dimensions, interpolation, __arg7);
                }
            }

            /// <summary>Add a 3D texture with RGB channel type.</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the 3D LUT data which must be used as-is as the dimension</para>
            /// <para>and origin are hard-coded in the fragment shader program. So, it means one GPU 3D texture</para>
            /// <para>per entry.</para>
            /// </remarks>
            public override void Add3DTexture(string textureName, string samplerName, uint edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values)
            {
                var ___Add3DTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr>(0, 14);
                fixed (float* __values4 = &values)
                {
                    var __arg4 = __values4;
                    ___Add3DTextureDelegate(__Instance, textureName, samplerName, edgelen, interpolation, __arg4);
                }
            }

            public override uint TextureMaxWidth
            {
                get
                {
                    var ___GetTextureMaxWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 5);
                    var ___ret = ___GetTextureMaxWidthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetTextureMaxWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint>(0, 4);
                    ___SetTextureMaxWidthDelegate(__Instance, value);
                }
            }

            public override bool AllowTexture1D
            {
                get
                {
                    var ___GetAllowTexture1DDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 7);
                    var ___ret = ___GetAllowTexture1DDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetAllowTexture1DDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 6);
                    ___SetAllowTexture1DDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GpuShaderDescInternal : global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GpuShaderDescInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GpuShaderDescInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Returns name of uniform and data as parameter.</summary>
            public override string GetUniform(uint index, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderDesc.UniformData data)
            {
                var ___GetUniformDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_uint___IntPtr>(0, 24);
                if (ReferenceEquals(data, null))
                    throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = data.__Instance;
                var ___ret = ___GetUniformDelegate(__Instance, index, __arg1);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public override void GetTexture(uint index, string textureName, string samplerName, ref uint width, ref uint height, ref global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, ref global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, ref global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation)
            {
                var ___GetTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureTypePtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensionsPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr>(0, 26);
                var __bytes1 = global::System.Text.Encoding.UTF8.GetBytes(textureName);
                var __bytePtr1 = Marshal.AllocHGlobal(__bytes1.Length + 1);
                Marshal.Copy(__bytes1, 0, __bytePtr1, __bytes1.Length);
                Marshal.WriteByte(__bytePtr1 + __bytes1.Length, 0);
                var __arg1 = textureName;
                var __bytes2 = global::System.Text.Encoding.UTF8.GetBytes(samplerName);
                var __bytePtr2 = Marshal.AllocHGlobal(__bytes2.Length + 1);
                Marshal.Copy(__bytes2, 0, __bytePtr2, __bytes2.Length);
                Marshal.WriteByte(__bytePtr2 + __bytes2.Length, 0);
                var __arg2 = samplerName;
                fixed (uint* __width3 = &width)
                {
                    var __arg3 = __width3;
                    fixed (uint* __height4 = &height)
                    {
                        var __arg4 = __height4;
                        fixed (global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType* __channel5 = &channel)
                        {
                            var __arg5 = __channel5;
                            fixed (global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions* __dimensions6 = &dimensions)
                            {
                                var __arg6 = __dimensions6;
                                fixed (global::OpenColorIO.OpenColorIO_v2_4.Interpolation* __interpolation7 = &interpolation)
                                {
                                    var __arg7 = __interpolation7;
                                    ___GetTextureDelegate(__Instance, index, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);
                                }
                            }
                        }
                    }
                }
            }

            public override void GetTextureValues(uint index, float* values)
            {
                var ___GetTextureValuesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtrPtr>(0, 27);
                var __arg1 = &values;
                ___GetTextureValuesDelegate(__Instance, index, __arg1);
            }

            public override void Get3DTexture(uint index, string textureName, string samplerName, ref uint edgelen, ref global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation)
            {
                var ___Get3DTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr>(0, 29);
                var __bytes1 = global::System.Text.Encoding.UTF8.GetBytes(textureName);
                var __bytePtr1 = Marshal.AllocHGlobal(__bytes1.Length + 1);
                Marshal.Copy(__bytes1, 0, __bytePtr1, __bytes1.Length);
                Marshal.WriteByte(__bytePtr1 + __bytes1.Length, 0);
                var __arg1 = textureName;
                var __bytes2 = global::System.Text.Encoding.UTF8.GetBytes(samplerName);
                var __bytePtr2 = Marshal.AllocHGlobal(__bytes2.Length + 1);
                Marshal.Copy(__bytes2, 0, __bytePtr2, __bytes2.Length);
                Marshal.WriteByte(__bytePtr2 + __bytes2.Length, 0);
                var __arg2 = samplerName;
                fixed (uint* __edgelen3 = &edgelen)
                {
                    var __arg3 = __edgelen3;
                    fixed (global::OpenColorIO.OpenColorIO_v2_4.Interpolation* __interpolation4 = &interpolation)
                    {
                        var __arg4 = __interpolation4;
                        ___Get3DTextureDelegate(__Instance, index, __arg1, __arg2, __arg3, __arg4);
                    }
                }
            }

            public override void Get3DTextureValues(uint index, float* values)
            {
                var ___Get3DTextureValuesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtrPtr>(0, 30);
                var __arg1 = &values;
                ___Get3DTextureValuesDelegate(__Instance, index, __arg1);
            }

            /// <summary>Add a 1D or 2D texture</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the LUT data which must be used as-is as the dimensions and</para>
            /// <para>origin are hard-coded in the fragment shader program. So, it means one GPU texture per entry.</para>
            /// </remarks>
            public override void AddTexture(string textureName, string samplerName, uint width, uint height, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType channel, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions dimensions, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values)
            {
                var ___AddTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr>(0, 13);
                fixed (float* __values7 = &values)
                {
                    var __arg7 = __values7;
                    ___AddTextureDelegate(__Instance, textureName, samplerName, width, height, channel, dimensions, interpolation, __arg7);
                }
            }

            /// <summary>Add a 3D texture with RGB channel type.</summary>
            /// <remarks>
            /// <para>The 'values' parameter contains the 3D LUT data which must be used as-is as the dimension</para>
            /// <para>and origin are hard-coded in the fragment shader program. So, it means one GPU 3D texture</para>
            /// <para>per entry.</para>
            /// </remarks>
            public override void Add3DTexture(string textureName, string samplerName, uint edgelen, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interpolation, ref float values)
            {
                var ___Add3DTextureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr>(0, 14);
                fixed (float* __values4 = &values)
                {
                    var __arg4 = __values4;
                    ___Add3DTextureDelegate(__Instance, textureName, samplerName, edgelen, interpolation, __arg4);
                }
            }

            public override uint NumUniforms
            {
                get
                {
                    var ___GetNumUniformsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 23);
                    var ___ret = ___GetNumUniformsDelegate(__Instance);
                    return ___ret;
                }
            }

            public override uint NumTextures
            {
                get
                {
                    var ___GetNumTexturesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 25);
                    var ___ret = ___GetNumTexturesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override uint Num3DTextures
            {
                get
                {
                    var ___GetNum3DTexturesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 28);
                    var ___ret = ___GetNum3DTexturesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override uint TextureMaxWidth
            {
                get
                {
                    var ___GetTextureMaxWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 5);
                    var ___ret = ___GetTextureMaxWidthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetTextureMaxWidthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint>(0, 4);
                    ___SetTextureMaxWidthDelegate(__Instance, value);
                }
            }

            public override bool AllowTexture1D
            {
                get
                {
                    var ___GetAllowTexture1DDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 7);
                    var ___ret = ___GetAllowTexture1DDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetAllowTexture1DDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 6);
                    ___SetAllowTexture1DDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class BuiltinTransformRegistryInternal : global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransformRegistry, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal BuiltinTransformRegistryInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal BuiltinTransformRegistryInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>
            /// <para>Get the style string for the i-th built-in transform.</para>
            /// <para>The style is the ID string that identifies a given transform.</para>
            /// </summary>
            public override string GetBuiltinStyle(ulong index)
            {
                var ___GetBuiltinStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 1);
                var ___ret = ___GetBuiltinStyleDelegate(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the description string for the i-th built-in transform.</summary>
            public override string GetBuiltinDescription(ulong index)
            {
                var ___GetBuiltinDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 2);
                var ___ret = ___GetBuiltinDescriptionDelegate(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the number of built-in transforms available.</summary>
            public override ulong NumBuiltins
            {
                get
                {
                    var ___GetNumBuiltinsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 0);
                    var ___ret = ___GetNumBuiltinsDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class BuiltinConfigRegistryInternal : global::OpenColorIO.OpenColorIO_v2_4.BuiltinConfigRegistry, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal BuiltinConfigRegistryInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal BuiltinConfigRegistryInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>
            /// <para>Get the name of the config at the specified (zero-based) index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            public override string GetBuiltinConfigName(ulong configIndex)
            {
                var ___GetBuiltinConfigNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 1);
                var ___ret = ___GetBuiltinConfigNameDelegate(__Instance, configIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Throws for illegal index.</summary>
            public override string GetBuiltinConfigUIName(ulong configIndex)
            {
                var ___GetBuiltinConfigUINameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 2);
                var ___ret = ___GetBuiltinConfigUINameDelegate(__Instance, configIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get Yaml text of the built-in config at the specified index.</para>
            /// <para>Throws for illegal index.</para>
            /// </summary>
            public override string GetBuiltinConfig(ulong configIndex)
            {
                var ___GetBuiltinConfigDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 3);
                var ___ret = ___GetBuiltinConfigDelegate(__Instance, configIndex);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get the Yaml text of the built-in config with the specified name.</para>
            /// <para>Throws if the name is not found.</para>
            /// </summary>
            public override string GetBuiltinConfigByName(string configName)
            {
                var ___GetBuiltinConfigByNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8>(0, 4);
                var ___ret = ___GetBuiltinConfigByNameDelegate(__Instance, configName);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Check if a specific built-in config is recommended.</summary>
            /// <param name="configIndex">Index of built-in config.</param>
            /// <returns>true if the config is recommended.</returns>
            /// <remarks>
            /// <para>For backwards compatibility reasons, configs will remain in the registry even if they have</para>
            /// <para>been superseded. If an app is presenting a list of configs to users, it should not include</para>
            /// <para>configs that are no longer recommended.</para>
            /// <para>Throws if the name is not found.</para>
            /// </remarks>
            public override bool IsBuiltinConfigRecommended(ulong configIndex)
            {
                var ___IsBuiltinConfigRecommendedDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr_ulong>(0, 5);
                var ___ret = ___IsBuiltinConfigRecommendedDelegate(__Instance, configIndex);
                return ___ret;
            }

            /// <summary>Get the number of built-in configs available.</summary>
            public override ulong NumBuiltinConfigs
            {
                get
                {
                    var ___GetNumBuiltinConfigsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 0);
                    var ___ret = ___GetNumBuiltinConfigsDelegate(__Instance);
                    return ___ret;
                }
            }

            public override string DefaultBuiltinConfigName
            {
                get
                {
                    var ___GetDefaultBuiltinConfigNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetDefaultBuiltinConfigNameDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }
        }

        public unsafe partial class SystemMonitorsInternal : global::OpenColorIO.OpenColorIO_v2_4.SystemMonitors, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal SystemMonitorsInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal SystemMonitorsInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <remarks>
            /// <para>Get the monitor profile name.</para>
            /// <para>Get the string describing the monitor. It is used as an argument to instantiateDisplay. It</para>
            /// <para>may also be used in a UI to ask a user which of several monitors they want to instantiate a</para>
            /// <para>display for.</para>
            /// </remarks>
            public override string GetMonitorName(ulong idx)
            {
                var ___GetMonitorNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 2);
                var ___ret = ___GetMonitorNameDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the ICC profile path associated to the monitor.</summary>
            public override string GetProfileFilepath(ulong idx)
            {
                var ___GetProfileFilepathDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 3);
                var ___ret = ___GetProfileFilepathDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>True if the OS is able to provide ICC profiles for the attached monitors (macOS, Windows)</para>
            /// <para>and false otherwise.</para>
            /// </summary>
            public override bool IsSupported
            {
                get
                {
                    var ___IsSupportedDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 0);
                    var ___ret = ___IsSupportedDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of active monitors reported by the operating system.</summary>
            public override ulong NumMonitors
            {
                get
                {
                    var ___GetNumMonitorsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 1);
                    var ___ret = ___GetNumMonitorsDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class ConfigIOProxyInternal : global::OpenColorIO.OpenColorIO_v2_4.ConfigIOProxy, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ConfigIOProxyInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ConfigIOProxyInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Provide a fast unique ID for a LUT file.</summary>
            /// <param name="filepath">Fully resolve the path to the &quot;file.&quot;</param>
            /// <returns>The file hash string.</returns>
            /// <remarks>
            /// <para>This is intended to supply the string that will be used in OCIO's FileCacheMap.</para>
            /// <para>This should be highly performant and typically should not require extensive</para>
            /// <para>computation such as calculating the md5 hash of the file, unless it is pre-computed.</para>
            /// <para>If the &quot;file&quot; does not exist, in other words, if the proxy is unable to supply the requested</para>
            /// <para>file contents, the function must return an empty string.</para>
            /// <para>The file path is based on the Config's current working directory and is the same absolute</para>
            /// <para>path that would have been provided to the file system.</para>
            /// </remarks>
            public override string GetFastLutFileHash(string filepath)
            {
                var ___GetFastLutFileHashDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr_string8>(0, 3);
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFastLutFileHashDelegate(__Instance, new IntPtr(&___ret), filepath);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Provide the config file Yaml to be parsed.</summary>
            /// <returns>String with the config Yaml.</returns>
            public override string ConfigData
            {
                get
                {
                    var ___GetConfigDataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    ___GetConfigDataDelegate(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        public unsafe partial class OpenColorIO
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ClearAllCaches@OpenColorIO_v2_4@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearAllCaches();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetVersion@OpenColorIO_v2_4@@YAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVersion();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetVersionHex@OpenColorIO_v2_4@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetVersionHex();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetLoggingLevel@OpenColorIO_v2_4@@YA?AW4LoggingLevel@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel GetLoggingLevel();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?SetLoggingLevel@OpenColorIO_v2_4@@YAXW4LoggingLevel@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLoggingLevel(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ResetToDefaultLoggingFunction@OpenColorIO_v2_4@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetToDefaultLoggingFunction();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?LogMessage@OpenColorIO_v2_4@@YAXW4LoggingLevel@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogMessage(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ResetComputeHashFunction@OpenColorIO_v2_4@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetComputeHashFunction();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetEnvVariable@OpenColorIO_v2_4@@YAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEnvVariable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?SetEnvVariable@OpenColorIO_v2_4@@YAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetEnvVariable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?UnsetEnvVariable@OpenColorIO_v2_4@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UnsetEnvVariable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?IsEnvVariablePresent@OpenColorIO_v2_4@@YA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEnvVariablePresent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ResolveConfigPath@OpenColorIO_v2_4@@YAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ResolveConfigPath([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string originalPath);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ExtractOCIOZArchive@OpenColorIO_v2_4@@YAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExtractOCIOZArchive([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string archivePath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string destinationDir);
            }

            /// <summary>
            /// <para>During normal usage, OpenColorIO tends to cache certain global information (such</para>
            /// <para>as the contents of LUTs on disk, intermediate results, etc.). Calling this function will flush</para>
            /// <para>all such information. The global information are related to LUT file identifications, loaded LUT</para>
            /// <para>file content and CDL transforms from loaded CDL files.</para>
            /// </summary>
            /// <remarks>
            /// <para>Under normal usage, this is not necessary, but it can be helpful in particular instances,</para>
            /// <para>such as designing OCIO profiles, and wanting to re-read luts without restarting.</para>
            /// <para>This method does not apply to instance-specific caches such as the Processor cache in</para>
            /// <para>a Config instance or the GPU and CPU Processor caches in a Processor instance. So in cases</para>
            /// <para>where you still have a Config instance after calling ClearAllCaches, you should also call</para>
            /// <para>the Config's clearProcessorCache method.</para>
            /// </remarks>
            public static void ClearAllCaches()
            {
                __Internal.ClearAllCaches();
            }

            /// <summary>
            /// <para>Get the version number for the library, as a dot-delimited string</para>
            /// <para>(e.g., &quot;1.0.0&quot;).</para>
            /// </summary>
            /// <remarks>This is also available at compile time as OCIO_VERSION_FULL_STR.</remarks>
            public static string GetVersion()
            {
                var ___ret = __Internal.GetVersion();
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get the version number for the library, as a</para>
            /// <para>single 4-byte hex number (e.g., 0x01050200 for &quot;1.5.2&quot;), to be used</para>
            /// <para>for numeric comparisons.</para>
            /// </summary>
            /// <remarks>This is also at compile time as OCIO_VERSION_HEX.</remarks>
            public static int GetVersionHex()
            {
                var ___ret = __Internal.GetVersionHex();
                return ___ret;
            }

            /// <summary>Get the global logging level.</summary>
            /// <remarks>
            /// <para>You can override this at runtime using theenvironment variable. The client application that sets this should use</para>
            /// <para>and not the environment variable. The default value is INFO.</para>
            /// </remarks>
            public static global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel GetLoggingLevel()
            {
                var ___ret = __Internal.GetLoggingLevel();
                return ___ret;
            }

            /// <summary>Set the global logging level.</summary>
            public static void SetLoggingLevel(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level)
            {
                __Internal.SetLoggingLevel(level);
            }

            public static void ResetToDefaultLoggingFunction()
            {
                __Internal.ResetToDefaultLoggingFunction();
            }

            /// <summary>Log a message using the library logging function.</summary>
            public static void LogMessage(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level, string message)
            {
                __Internal.LogMessage(level, message);
            }

            public static void ResetComputeHashFunction()
            {
                __Internal.ResetComputeHashFunction();
            }

            /// <summary>
            /// <para>Another call modifies the string obtained from a previous call as the method always uses the</para>
            /// <para>same memory buffer.</para>
            /// </summary>
            public static string GetEnvVariable(string name)
            {
                var ___ret = __Internal.GetEnvVariable(name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <remarks>This method is not thread safe.</remarks>
            public static void SetEnvVariable(string name, string value)
            {
                __Internal.SetEnvVariable(name, value);
            }

            /// <remarks>This method is not thread safe.</remarks>
            public static void UnsetEnvVariable(string name)
            {
                __Internal.UnsetEnvVariable(name);
            }

            /// <summary>cpp:function::</summary>
            public static bool IsEnvVariablePresent(string name)
            {
                var ___ret = __Internal.IsEnvVariablePresent(name);
                return ___ret;
            }

            /// <summary>
            /// <para>Make a config path forward-compatible by replacing special built-in config names</para>
            /// <para>with the current name.</para>
            /// </summary>
            /// <returns>Resolved path if possible. Otherwise, the original path is returned unmodified.</returns>
            /// <remarks>
            /// <para>Application developers should call this function on any config path they intend to persist</para>
            /// <para>(e.g., to include in a file saved from a DCC).</para>
            /// <para>As the built-in config collection evolves, special names such as &quot;ocio://default&quot; and</para>
            /// <para>&quot;ocio://studio-config-latest&quot; will point to newer versions of those configs. Therefore, it is</para>
            /// <para>recommended that application developers not save those strings and instead save the string that</para>
            /// <para>refers to the current version of that config. That way, it's guaranteed that there will be no</para>
            /// <para>change of behavior in the future. For example, as of OCIO 2.4, &quot;ocio://default&quot; should be saved</para>
            /// <para>as &quot;ocio://cg-config-v2.2.0_aces-v1.3_ocio-v2.4&quot;.</para>
            /// <para>Note that there is no validation done on the path. That is left to the application since</para>
            /// <para>typically the application will load the config before attempting to save its path</para>
            /// <para>and therefore catch, for example, a badly formed URI such as &quot;ocio:default&quot;.</para>
            /// </remarks>
            public static string ResolveConfigPath(string originalPath)
            {
                var ___ret = __Internal.ResolveConfigPath(originalPath);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Extract an OCIO Config archive.</summary>
            /// <param name="archivePath">Absolute path to the .ocioz file.</param>
            /// <param name="destinationDir">
            /// <para>Absolute path of the directory you want to be created to contain the</para>
            /// <para>contents of the unarchived config.</para>
            /// </param>
            /// <remarks>
            /// <para>Converts an archived config file (.ocioz file) back to its original form as a config file</para>
            /// <para>and associated LUT files.  This creates destinationDir and then creates a config.ocio file</para>
            /// <para>at the root of that working directory and then unpacks the LUT files into their relative</para>
            /// <para>locations relative to that working directory, creating any necessary sub-directories in the</para>
            /// <para>process.  Note that configs which contain LUT files outside the working directory are not</para>
            /// <para>archivable, and so this function will not create directories outside the working directory.</para>
            /// <para>Exception If the archive is not found or there is a problem extracting it.</para>
            /// </remarks>
            public static void ExtractOCIOZArchive(string archivePath, string destinationDir)
            {
                __Internal.ExtractOCIOZArchive(archivePath, destinationDir);
            }

            /// <summary>////////////////////////////////////////////////////////////////////////</summary>
            public const long AutoStride = -9223372036854775808;        }
    }

    namespace OpenColorIO_v2_4
    {
        /// <summary>Controls which environment variables are loaded into a Context object.</summary>
        public enum EnvironmentMode
        {
            ENV_ENVIRONMENT_UNKNOWN = 0,
            /// <summary>Only load vars in the config's environment section</summary>
            ENV_ENVIRONMENT_LOAD_PREDEFINED = 1,
            /// <summary>Load all env. vars (note: may reduce performance)</summary>
            ENV_ENVIRONMENT_LOAD_ALL = 2
        }

        /// <summary>
        /// <para>OCIO does not mandate the image state of the main reference space and it is not</para>
        /// <para>required to be scene-referred.  This enum is used in connection with the display color space</para>
        /// <para>and view transform features which do assume that the main reference space is scene-referred</para>
        /// <para>and the display reference space is display-referred.  If a config used a non-scene-referred</para>
        /// <para>reference space, presumably it would not use either display color spaces or view transforms,</para>
        /// <para>so this enum becomes irrelevant.</para>
        /// </summary>
        public enum ReferenceSpaceType
        {
            /// <summary>the main scene reference space</summary>
            REFERENCE_SPACE_SCENE = 0,
            /// <summary>the reference space for display color spaces</summary>
            REFERENCE_SPACE_DISPLAY = 1
        }

        /// <summary>
        /// <para>Used in a configuration file to indicate the bit-depth of a color space,</para>
        /// <para>and by theto specify the input and output bit-depths of</para>
        /// <para>images to process.</para>
        /// <para>Note thatonly supports: UINT8, UINT10, UINT12, UINT16, F16 and F32.</para>
        /// </summary>
        public enum BitDepth
        {
            BIT_DEPTH_UNKNOWN = 0,
            BIT_DEPTH_UINT8 = 1,
            BIT_DEPTH_UINT10 = 2,
            BIT_DEPTH_UINT12 = 3,
            BIT_DEPTH_UINT14 = 4,
            BIT_DEPTH_UINT16 = 5,
            /// <summary>Here for historical reason but that's not supported.</summary>
            BIT_DEPTH_UINT32 = 6,
            BIT_DEPTH_F16 = 7,
            BIT_DEPTH_F32 = 8
        }

        public enum Allocation
        {
            ALLOCATION_UNKNOWN = 0,
            ALLOCATION_UNIFORM = 1,
            ALLOCATION_LG2 = 2
        }

        public enum TransformDirection
        {
            TRANSFORM_DIR_FORWARD = 0,
            TRANSFORM_DIR_INVERSE = 1
        }

        public enum TransformType
        {
            TRANSFORM_TYPE_ALLOCATION = 0,
            TRANSFORM_TYPE_BUILTIN = 1,
            TRANSFORM_TYPE_CDL = 2,
            TRANSFORM_TYPE_COLORSPACE = 3,
            TRANSFORM_TYPE_DISPLAY_VIEW = 4,
            TRANSFORM_TYPE_EXPONENT = 5,
            TRANSFORM_TYPE_EXPONENT_WITH_LINEAR = 6,
            TRANSFORM_TYPE_EXPOSURE_CONTRAST = 7,
            TRANSFORM_TYPE_FILE = 8,
            TRANSFORM_TYPE_FIXED_FUNCTION = 9,
            TRANSFORM_TYPE_GRADING_PRIMARY = 10,
            TRANSFORM_TYPE_GRADING_RGB_CURVE = 11,
            TRANSFORM_TYPE_GRADING_TONE = 12,
            TRANSFORM_TYPE_GROUP = 13,
            TRANSFORM_TYPE_LOG_AFFINE = 14,
            TRANSFORM_TYPE_LOG_CAMERA = 15,
            TRANSFORM_TYPE_LOG = 16,
            TRANSFORM_TYPE_LOOK = 17,
            TRANSFORM_TYPE_LUT1D = 18,
            TRANSFORM_TYPE_LUT3D = 19,
            TRANSFORM_TYPE_MATRIX = 20,
            TRANSFORM_TYPE_RANGE = 21
        }

        public enum ColorSpaceDirection
        {
            COLORSPACE_DIR_TO_REFERENCE = 0,
            COLORSPACE_DIR_FROM_REFERENCE = 1
        }

        public enum SearchReferenceSpaceType
        {
            SEARCH_REFERENCE_SPACE_SCENE = 0,
            SEARCH_REFERENCE_SPACE_DISPLAY = 1,
            SEARCH_REFERENCE_SPACE_ALL = 2
        }

        public enum ColorSpaceVisibility
        {
            COLORSPACE_ACTIVE = 0,
            COLORSPACE_INACTIVE = 1,
            COLORSPACE_ALL = 2
        }

        public enum ViewType
        {
            VIEW_SHARED = 0,
            VIEW_DISPLAY_DEFINED = 1
        }

        public enum ViewTransformDirection
        {
            VIEWTRANSFORM_DIR_TO_REFERENCE = 0,
            VIEWTRANSFORM_DIR_FROM_REFERENCE = 1
        }

        public enum NamedTransformVisibility
        {
            NAMEDTRANSFORM_ACTIVE = 0,
            NAMEDTRANSFORM_INACTIVE = 1,
            NAMEDTRANSFORM_ALL = 2
        }

        /// <summary>Types for dynamic properties.</summary>
        public enum DynamicPropertyType
        {
            /// <summary>Image exposure value (double floating point value)</summary>
            DYNAMIC_PROPERTY_EXPOSURE = 0,
            /// <summary>Image contrast value (double floating point value)</summary>
            DYNAMIC_PROPERTY_CONTRAST = 1,
            /// <summary>Image gamma value (double floating point value)</summary>
            DYNAMIC_PROPERTY_GAMMA = 2,
            /// <summary>Used by GradingPrimaryTransform</summary>
            DYNAMIC_PROPERTY_GRADING_PRIMARY = 3,
            /// <summary>Used by GradingRGBCurveTransform</summary>
            DYNAMIC_PROPERTY_GRADING_RGBCURVE = 4,
            /// <summary>Used by GradingToneTransform</summary>
            DYNAMIC_PROPERTY_GRADING_TONE = 5
        }

        /// <summary>Provides control over how the ops in a Processor are combined in order to improve performance.</summary>
        public enum OptimizationFlags : uint
        {
            /// <summary>Do not optimize.</summary>
            OPTIMIZATION_NONE = 0x0,
            /// <summary>Replace identity ops (other than gamma).</summary>
            OPTIMIZATION_IDENTITY = 0x1,
            /// <summary>Replace identity gamma ops.</summary>
            OPTIMIZATION_IDENTITY_GAMMA = 0x2,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_CDL = 0x40,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_EXPOSURE_CONTRAST = 0x80,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_FIXED_FUNCTION = 0x100,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_GAMMA = 0x200,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LUT1D = 0x400,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LUT3D = 0x800,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LOG = 0x1000,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_GRADING = 0x2000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_EXPONENT = 0x40000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_GAMMA = 0x80000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_MATRIX = 0x100000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_LUT1D = 0x200000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_LUT3D = 0x400000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_RANGE = 0x800000,
            /// <summary>
            /// <para>For integer and half bit-depths only, replace separable ops (i.e. no channel crosstalk</para>
            /// <para>ops) by a single 1D LUT of input bit-depth domain.</para>
            /// </summary>
            OPTIMIZATION_COMP_SEPARABLE_PREFIX = 0x1000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_LUT_INV_FAST = 0x2000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_FAST_LOG_EXP_POW = 0x4000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_SIMPLIFY_OPS = 0x8000000,
            /// <summary>
            /// <para>Turn off dynamic control of any ops that offer adjustment of parameter values after</para>
            /// <para>finalization (e.g. ExposureContrast).</para>
            /// </summary>
            OPTIMIZATION_NO_DYNAMIC_PROPERTIES = 0x10000000,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_ALL = 0xffffffff,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_LOSSLESS = 144457667,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_VERY_GOOD = 263995331,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_GOOD = 268189635,
            /// <summary>For quite lossy optimizations.</summary>
            OPTIMIZATION_DRAFT = 4294967295,
            /// <summary>For quite lossy optimizations.</summary>
            OPTIMIZATION_DEFAULT = 263995331
        }

        /// <summary>Used when there is a choice of hardware shader language.</summary>
        public enum GpuLanguage
        {
            /// <summary>Nvidia Cg shader</summary>
            GPU_LANGUAGE_CG = 0,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_1_2 = 1,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_1_3 = 2,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_4_0 = 3,
            /// <summary>DirectX Shading Language</summary>
            GPU_LANGUAGE_HLSL_DX11 = 4,
            /// <summary>Open Shading Language</summary>
            LANGUAGE_OSL_1 = 5,
            /// <summary>OpenGL ES Shading Language</summary>
            GPU_LANGUAGE_GLSL_ES_1_0 = 6,
            /// <summary>OpenGL ES Shading Language</summary>
            GPU_LANGUAGE_GLSL_ES_3_0 = 7,
            /// <summary>Metal Shading Language</summary>
            GPU_LANGUAGE_MSL_2_0 = 8
        }

        /// <summary>
        /// <para>Specify the interpolation type to use</para>
        /// <para>If the specified interpolation type is not supported in the requested</para>
        /// <para>context (for example, using tetrahedral interpolationon 1D LUTs)</para>
        /// <para>an exception will be thrown.</para>
        /// </summary>
        /// <remarks>
        /// <para>INTERP_DEFAULT will choose the default interpolation type for the requested</para>
        /// <para>context:</para>
        /// <para>1D LUT INTERP_DEFAULT: LINEAR</para>
        /// <para>3D LUT INTERP_DEFAULT: LINEAR</para>
        /// <para>INTERP_BEST will choose the best interpolation type for the requested</para>
        /// <para>context:</para>
        /// <para>1D LUT INTERP_BEST: LINEAR</para>
        /// <para>3D LUT INTERP_BEST: TETRAHEDRAL</para>
        /// <para>Note: INTERP_BEST and INTERP_DEFAULT are subject to change in minor</para>
        /// <para>releases, so if you care about locking off on a specific interpolation</para>
        /// <para>type, we'd recommend directly specifying it.</para>
        /// </remarks>
        public enum Interpolation
        {
            INTERP_UNKNOWN = 0,
            /// <summary>nearest neighbor</summary>
            INTERP_NEAREST = 1,
            /// <summary>linear interpolation (trilinear for Lut3D)</summary>
            INTERP_LINEAR = 2,
            /// <summary>tetrahedral interpolation (Lut3D only)</summary>
            INTERP_TETRAHEDRAL = 3,
            /// <summary>cubic interpolation (not supported)</summary>
            INTERP_CUBIC = 4,
            /// <summary>the default interpolation type</summary>
            INTERP_DEFAULT = 254,
            /// <summary>the 'best' suitable interpolation type</summary>
            INTERP_BEST = 255
        }

        /// <summary>Types for uniform data.</summary>
        public enum UniformDataType
        {
            UNIFORM_DOUBLE = 0,
            UNIFORM_BOOL = 1,
            /// <summary>Array of 3 floats.</summary>
            UNIFORM_FLOAT3 = 2,
            /// <summary>Vector of floats (size is set by uniform).</summary>
            UNIFORM_VECTOR_FLOAT = 3,
            /// <summary>Vector of int pairs (size is set by uniform).</summary>
            UNIFORM_VECTOR_INT = 4,
            UNIFORM_UNKNOWN = 5
        }

        /// <summary>cpp:type:: Enum to control the behavior of the internal caches e.g. the processor cache in</summary>
        public enum ProcessorCacheFlags : uint
        {
            PROCESSOR_CACHE_OFF = 0x0,
            PROCESSOR_CACHE_ENABLED = 0x1,
            PROCESSOR_CACHE_SHARE_DYN_PROPERTIES = 0x2,
            PROCESSOR_CACHE_DEFAULT = 3
        }

        /// <summary>Styles for grading transforms.</summary>
        public enum GradingStyle
        {
            /// <summary>Algorithms for Logarithmic color spaces.</summary>
            GRADING_LOG = 0,
            /// <summary>Algorithms for Scene Linear color spaces.</summary>
            GRADING_LIN = 1,
            /// <summary>Algorithms for Video color spaces.</summary>
            GRADING_VIDEO = 2
        }

        /// <summary>Types for GradingRGBCurve.</summary>
        public enum RGBCurveType
        {
            RGB_RED = 0,
            RGB_GREEN = 1,
            RGB_BLUE = 2,
            RGB_MASTER = 3,
            RGB_NUM_CURVES = 4
        }

        /// <summary>Enumeration of the :cpp:class:`CDLTransform` transform algorithms.</summary>
        /// <remarks>
        /// <para>The default for reading .cc/.ccc/.cdl files, config file YAML, and CDLTransform is no-clamp,</para>
        /// <para>since that is what is primarily desired in VFX.  However, the CLF format default is ASC.</para>
        /// </remarks>
        public enum CDLStyle
        {
            /// <summary>ASC CDL specification v1.2</summary>
            CDL_ASC = 0,
            /// <summary>CDL that does not clamp</summary>
            CDL_NO_CLAMP = 1,
            CDL_TRANSFORM_DEFAULT = 1
        }

        /// <summary>
        /// <para>Negative values handling style forand</para>
        /// <para>transform algorithms.</para>
        /// </summary>
        public enum NegativeStyle
        {
            /// <summary>Clamp negative values</summary>
            NEGATIVE_CLAMP = 0,
            /// <summary>Positive curve is rotated 180 degrees around the origin to handle negatives.</summary>
            NEGATIVE_MIRROR = 1,
            /// <summary>Negative values are passed through unchanged.</summary>
            NEGATIVE_PASS_THRU = 2,
            /// <summary>Linearly extrapolate the curve for negative values.</summary>
            NEGATIVE_LINEAR = 3
        }

        /// <summary>Enumeration of the :cpp:class:`ExposureContrastTransform` transform algorithms.</summary>
        public enum ExposureContrastStyle
        {
            /// <summary>E/C to be applied to a linear space image</summary>
            EXPOSURE_CONTRAST_LINEAR = 0,
            /// <summary>E/C to be applied to a video space image</summary>
            EXPOSURE_CONTRAST_VIDEO = 1,
            /// <summary>E/C to be applied to a log space image</summary>
            EXPOSURE_CONTRAST_LOGARITHMIC = 2
        }

        /// <summary>Enumeration of the :cpp:class:`FixedFunctionTransform` transform algorithms.</summary>
        public enum FixedFunctionStyle
        {
            /// <summary>Red modifier (ACES 0.3/0.7)</summary>
            FIXED_FUNCTION_ACES_RED_MOD_03 = 0,
            /// <summary>Red modifier (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_RED_MOD_10 = 1,
            /// <summary>Glow function (ACES 0.3/0.7)</summary>
            FIXED_FUNCTION_ACES_GLOW_03 = 2,
            /// <summary>Glow function (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_GLOW_10 = 3,
            /// <summary>Dark to dim surround correction (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_DARK_TO_DIM_10 = 4,
            /// <summary>Rec.2100 surround correction (takes one double for the gamma param)</summary>
            FIXED_FUNCTION_REC2100SURROUND = 5,
            /// <summary>Classic RGB to HSV function</summary>
            FIXED_FUNCTION_RGB_TO_HSV = 6,
            /// <summary>CIE XYZ to 1931 xy chromaticity coordinates</summary>
            FIXED_FUNCTION_XYZ_TO_xyY = 7,
            /// <summary>CIE XYZ to 1976 u'v' chromaticity coordinates</summary>
            FIXED_FUNCTION_XYZ_TO_uvY = 8,
            /// <summary>CIE XYZ to 1976 CIELUV colour space (D65 white)</summary>
            FIXED_FUNCTION_XYZ_TO_LUV = 9,
            /// <summary>ACES 0.2 Gamut clamping algorithm -- NOT IMPLEMENTED YET</summary>
            FIXED_FUNCTION_ACES_GAMUTMAP_02 = 10,
            /// <summary>ACES 0.7 Gamut clamping algorithm -- NOT IMPLEMENTED YET</summary>
            FIXED_FUNCTION_ACES_GAMUTMAP_07 = 11,
            /// <summary>ACES 1.3 Parametric Gamut Compression (expects ACEScg values)</summary>
            FIXED_FUNCTION_ACES_GAMUT_COMP_13 = 12,
            /// <summary>SMPTE ST-2084 OETF, scaled with 100 nits at 1.0 (neg vals mirrored)</summary>
            FIXED_FUNCTION_LIN_TO_PQ = 13,
            /// <summary>Parametrized gamma and log segments with mirroring</summary>
            FIXED_FUNCTION_LIN_TO_GAMMA_LOG = 14,
            /// <summary>Two parameterized LogAffineTransforms with a middle linear segment</summary>
            FIXED_FUNCTION_LIN_TO_DOUBLE_LOG = 15,
            /// <summary>ACES 2.0 Display Rendering -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_OUTPUT_TRANSFORM_20 = 16,
            /// <summary>ACES 2.0 RGB to JMh -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_RGB_TO_JMH_20 = 17,
            /// <summary>ACES 2.0 Tonescale and chroma compression -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_TONESCALE_COMPRESS_20 = 18,
            /// <summary>ACES 2.0 Gamut compression -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_GAMUT_COMPRESS_20 = 19
        }

        /// <summary>Used by :cpp:class`Lut1DTransform` to control optional hue restoration algorithm.</summary>
        public enum Lut1DHueAdjust
        {
            /// <summary>No adjustment.</summary>
            HUE_NONE = 0,
            /// <summary>Algorithm used in ACES Output Transforms through v0.7.</summary>
            HUE_DW3 = 1,
            /// <summary>Weighted Yellow Power Norm -- NOT IMPLEMENTED YET</summary>
            HUE_WYPN = 2
        }

        /// <summary>A RangeTransform may be set to clamp the values, or not.</summary>
        public enum RangeStyle
        {
            RANGE_NO_CLAMP = 0,
            RANGE_CLAMP = 1
        }

        public enum LoggingLevel
        {
            LOGGING_LEVEL_NONE = 0,
            LOGGING_LEVEL_WARNING = 1,
            LOGGING_LEVEL_INFO = 2,
            LOGGING_LEVEL_DEBUG = 3,
            LOGGING_LEVEL_UNKNOWN = 255,
            LOGGING_LEVEL_DEFAULT = 2
        }

        /// <summary>Used byto indicate the channel ordering of the image to process.</summary>
        public enum ChannelOrdering
        {
            CHANNEL_ORDERING_RGBA = 0,
            CHANNEL_ORDERING_BGRA = 1,
            CHANNEL_ORDERING_ABGR = 2,
            CHANNEL_ORDERING_RGB = 3,
            CHANNEL_ORDERING_BGR = 4
        }

        /// <summary>Define the logging function signature.</summary>
        /// <summary>Define Compute Hash function signature.</summary>
        public unsafe partial class OpenColorTypes
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BoolToString@OpenColorIO_v2_4@@YAPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr BoolToString(bool val);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BoolFromString@OpenColorIO_v2_4@@YA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BoolFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?LoggingLevelToString@OpenColorIO_v2_4@@YAPEBDW4LoggingLevel@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr LoggingLevelToString(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?LoggingLevelFromString@OpenColorIO_v2_4@@YA?AW4LoggingLevel@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel LoggingLevelFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?TransformDirectionToString@OpenColorIO_v2_4@@YAPEBDW4TransformDirection@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr TransformDirectionToString(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?TransformDirectionFromString@OpenColorIO_v2_4@@YA?AW4TransformDirection@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.TransformDirection TransformDirectionFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetInverseTransformDirection@OpenColorIO_v2_4@@YA?AW4TransformDirection@1@W421@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.TransformDirection GetInverseTransformDirection(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?CombineTransformDirections@OpenColorIO_v2_4@@YA?AW4TransformDirection@1@W421@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.TransformDirection CombineTransformDirections(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection d1, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection d2);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BitDepthToString@OpenColorIO_v2_4@@YAPEBDW4BitDepth@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr BitDepthToString(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BitDepthFromString@OpenColorIO_v2_4@@YA?AW4BitDepth@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepthFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BitDepthIsFloat@OpenColorIO_v2_4@@YA_NW4BitDepth@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BitDepthIsFloat(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?BitDepthToInt@OpenColorIO_v2_4@@YAHW4BitDepth@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int BitDepthToInt(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?AllocationToString@OpenColorIO_v2_4@@YAPEBDW4Allocation@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AllocationToString(global::OpenColorIO.OpenColorIO_v2_4.Allocation allocation);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?AllocationFromString@OpenColorIO_v2_4@@YA?AW4Allocation@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.Allocation AllocationFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?InterpolationToString@OpenColorIO_v2_4@@YAPEBDW4Interpolation@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr InterpolationToString(global::OpenColorIO.OpenColorIO_v2_4.Interpolation interp);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?InterpolationFromString@OpenColorIO_v2_4@@YA?AW4Interpolation@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.Interpolation InterpolationFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GpuLanguageToString@OpenColorIO_v2_4@@YAPEBDW4GpuLanguage@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GpuLanguageToString(global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage language);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GpuLanguageFromString@OpenColorIO_v2_4@@YA?AW4GpuLanguage@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage GpuLanguageFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?EnvironmentModeToString@OpenColorIO_v2_4@@YAPEBDW4EnvironmentMode@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr EnvironmentModeToString(global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode mode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?EnvironmentModeFromString@OpenColorIO_v2_4@@YA?AW4EnvironmentMode@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode EnvironmentModeFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?CDLStyleToString@OpenColorIO_v2_4@@YAPEBDW4CDLStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr CDLStyleToString(global::OpenColorIO.OpenColorIO_v2_4.CDLStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?CDLStyleFromString@OpenColorIO_v2_4@@YA?AW4CDLStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.CDLStyle CDLStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?RangeStyleToString@OpenColorIO_v2_4@@YAPEBDW4RangeStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr RangeStyleToString(global::OpenColorIO.OpenColorIO_v2_4.RangeStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?RangeStyleFromString@OpenColorIO_v2_4@@YA?AW4RangeStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.RangeStyle RangeStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?FixedFunctionStyleToString@OpenColorIO_v2_4@@YAPEBDW4FixedFunctionStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FixedFunctionStyleToString(global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?FixedFunctionStyleFromString@OpenColorIO_v2_4@@YA?AW4FixedFunctionStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle FixedFunctionStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GradingStyleToString@OpenColorIO_v2_4@@YAPEBDW4GradingStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GradingStyleToString(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GradingStyleFromString@OpenColorIO_v2_4@@YA?AW4GradingStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.GradingStyle GradingStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ExposureContrastStyleToString@OpenColorIO_v2_4@@YAPEBDW4ExposureContrastStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ExposureContrastStyleToString(global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?ExposureContrastStyleFromString@OpenColorIO_v2_4@@YA?AW4ExposureContrastStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle ExposureContrastStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?NegativeStyleToString@OpenColorIO_v2_4@@YAPEBDW4NegativeStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NegativeStyleToString(global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?NegativeStyleFromString@OpenColorIO_v2_4@@YA?AW4NegativeStyle@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyleFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style);
            }

            public static string BoolToString(bool val)
            {
                var ___ret = __Internal.BoolToString(val);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static bool BoolFromString(string s)
            {
                var ___ret = __Internal.BoolFromString(s);
                return ___ret;
            }

            public static string LoggingLevelToString(global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel level)
            {
                var ___ret = __Internal.LoggingLevelToString(level);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.LoggingLevel LoggingLevelFromString(string s)
            {
                var ___ret = __Internal.LoggingLevelFromString(s);
                return ___ret;
            }

            public static string TransformDirectionToString(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var ___ret = __Internal.TransformDirectionToString(dir);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Will throw if string is not recognized.</summary>
            public static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection TransformDirectionFromString(string s)
            {
                var ___ret = __Internal.TransformDirectionFromString(s);
                return ___ret;
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection GetInverseTransformDirection(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var ___ret = __Internal.GetInverseTransformDirection(dir);
                return ___ret;
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection CombineTransformDirections(global::OpenColorIO.OpenColorIO_v2_4.TransformDirection d1, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection d2)
            {
                var ___ret = __Internal.CombineTransformDirections(d1, d2);
                return ___ret;
            }

            public static string BitDepthToString(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var ___ret = __Internal.BitDepthToString(bitDepth);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.BitDepth BitDepthFromString(string s)
            {
                var ___ret = __Internal.BitDepthFromString(s);
                return ___ret;
            }

            public static bool BitDepthIsFloat(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var ___ret = __Internal.BitDepthIsFloat(bitDepth);
                return ___ret;
            }

            public static int BitDepthToInt(global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var ___ret = __Internal.BitDepthToInt(bitDepth);
                return ___ret;
            }

            public static string AllocationToString(global::OpenColorIO.OpenColorIO_v2_4.Allocation allocation)
            {
                var ___ret = __Internal.AllocationToString(allocation);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.Allocation AllocationFromString(string s)
            {
                var ___ret = __Internal.AllocationFromString(s);
                return ___ret;
            }

            public static string InterpolationToString(global::OpenColorIO.OpenColorIO_v2_4.Interpolation interp)
            {
                var ___ret = __Internal.InterpolationToString(interp);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.Interpolation InterpolationFromString(string s)
            {
                var ___ret = __Internal.InterpolationFromString(s);
                return ___ret;
            }

            public static string GpuLanguageToString(global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage language)
            {
                var ___ret = __Internal.GpuLanguageToString(language);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.GpuLanguage GpuLanguageFromString(string s)
            {
                var ___ret = __Internal.GpuLanguageFromString(s);
                return ___ret;
            }

            public static string EnvironmentModeToString(global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode mode)
            {
                var ___ret = __Internal.EnvironmentModeToString(mode);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.EnvironmentMode EnvironmentModeFromString(string s)
            {
                var ___ret = __Internal.EnvironmentModeFromString(s);
                return ___ret;
            }

            public static string CDLStyleToString(global::OpenColorIO.OpenColorIO_v2_4.CDLStyle style)
            {
                var ___ret = __Internal.CDLStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.CDLStyle CDLStyleFromString(string style)
            {
                var ___ret = __Internal.CDLStyleFromString(style);
                return ___ret;
            }

            public static string RangeStyleToString(global::OpenColorIO.OpenColorIO_v2_4.RangeStyle style)
            {
                var ___ret = __Internal.RangeStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.RangeStyle RangeStyleFromString(string style)
            {
                var ___ret = __Internal.RangeStyleFromString(style);
                return ___ret;
            }

            public static string FixedFunctionStyleToString(global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle style)
            {
                var ___ret = __Internal.FixedFunctionStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle FixedFunctionStyleFromString(string style)
            {
                var ___ret = __Internal.FixedFunctionStyleFromString(style);
                return ___ret;
            }

            public static string GradingStyleToString(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                var ___ret = __Internal.GradingStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.GradingStyle GradingStyleFromString(string s)
            {
                var ___ret = __Internal.GradingStyleFromString(s);
                return ___ret;
            }

            public static string ExposureContrastStyleToString(global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle style)
            {
                var ___ret = __Internal.ExposureContrastStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle ExposureContrastStyleFromString(string style)
            {
                var ___ret = __Internal.ExposureContrastStyleFromString(style);
                return ___ret;
            }

            public static string NegativeStyleToString(global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle style)
            {
                var ___ret = __Internal.NegativeStyleToString(style);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyleFromString(string style)
            {
                var ___ret = __Internal.NegativeStyleFromString(style);
                return ___ret;
            }

            /// <summary>The envvar 'OCIO' provides a path to the config file used by</summary>
            public static string OCIO_CONFIG_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The envvar 'OCIO_ACTIVE_DISPLAYS' provides a list of displays overriding the 'active_displays'</para>
            /// <para>list from the config file.</para>
            /// </summary>
            public static string OCIO_ACTIVE_DISPLAYS_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_ACTIVE_DISPLAYS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_ACTIVE_DISPLAYS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The envvar 'OCIO_ACTIVE_VIEWS' provides a list of views overriding the 'active_views'</para>
            /// <para>list from the config file.</para>
            /// </summary>
            public static string OCIO_ACTIVE_VIEWS_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_ACTIVE_VIEWS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_ACTIVE_VIEWS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The envvar 'OCIO_INACTIVE_COLORSPACES' provides a list of inactive color spaces</para>
            /// <para>overriding the 'inactive_color_spaces' list from the config file.</para>
            /// </summary>
            public static string OCIO_INACTIVE_COLORSPACES_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_INACTIVE_COLORSPACES_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_INACTIVE_COLORSPACES_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The envvar 'OCIO_OPTIMIZATION_FLAGS' provides a way to force a given optimization level.</para>
            /// <para>Remove the variable or set the value to empty to not use it. Set the value of the variable</para>
            /// <para>to the desired optimization level as either an integer or hexadecimal value.</para>
            /// <para>Ex: OCIO_OPTIMIZATION_FLAGS=&quot;144457667&quot; or &quot;0x89c3fc3&quot; for OPTIMIZATION_LOSSLESS.</para>
            /// </summary>
            public static string OCIO_OPTIMIZATION_FLAGS_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_OPTIMIZATION_FLAGS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_OPTIMIZATION_FLAGS_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The envvar 'OCIO_USER_CATEGORIES' allows the end-user to filter color spaces shown by</para>
            /// <para>applications.  Only color spaces that include at least one of the supplied categories will be</para>
            /// <para>shown in application menus.  Note that applications may also impose their own category filtering</para>
            /// <para>in addition to the user-supplied categories.  For example, an application may filter by</para>
            /// <para>'working-space' for a menu to select a working space while the user may also filter by</para>
            /// <para>'3d-basic' to only show spaces intended for 3d artists who should see the basic set of color</para>
            /// <para>spaces. The categories will be ignored if they would result in no color spaces being found.</para>
            /// </summary>
            public static string OCIO_USER_CATEGORIES_ENVVAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_USER_CATEGORIES_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_USER_CATEGORIES_ENVVAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;default&quot;</summary>
            public static string ROLE_DEFAULT
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_DEFAULT_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_DEFAULT_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;reference&quot;</summary>
            public static string ROLE_REFERENCE
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_REFERENCE_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_REFERENCE_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;data&quot;</summary>
            public static string ROLE_DATA
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_DATA_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_DATA_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;color_picking&quot;</summary>
            public static string ROLE_COLOR_PICKING
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COLOR_PICKING_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COLOR_PICKING_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;scene_linear&quot;</summary>
            public static string ROLE_SCENE_LINEAR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_SCENE_LINEAR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_SCENE_LINEAR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;compositing_log&quot;</summary>
            public static string ROLE_COMPOSITING_LOG
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COMPOSITING_LOG_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COMPOSITING_LOG_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>&quot;color_timing&quot;</summary>
            public static string ROLE_COLOR_TIMING
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COLOR_TIMING_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_COLOR_TIMING_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>This role defines the transform for painting textures. In some</para>
            /// <para>workflows this is just a inverse display gamma with some limits</para>
            /// </summary>
            public static string ROLE_TEXTURE_PAINT
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_TEXTURE_PAINT_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_TEXTURE_PAINT_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>This role defines the transform for matte painting. In some workflows</para>
            /// <para>this is a 1D HDR to LDR allocation. It is normally combined with</para>
            /// <para>another display transform in the host app for preview.</para>
            /// </summary>
            public static string ROLE_MATTE_PAINT
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_MATTE_PAINT_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_MATTE_PAINT_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The rendering role may be used to identify a specific color space to be used by CGI renderers.</para>
            /// <para>This is typically a scene-linear space but the primaries also matter since they influence the</para>
            /// <para>resulting color, especially in areas of indirect illumination.</para>
            /// </summary>
            public static string ROLE_RENDERING
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_RENDERING_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_RENDERING_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The aces_interchange role is used to specify which color space in the config implements the</para>
            /// <para>standard ACES2065-1 color space (SMPTE ST2065-1).  This may be used when converting</para>
            /// <para>scene-referred colors from one config to another.</para>
            /// </summary>
            public static string ROLE_INTERCHANGE_SCENE
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_INTERCHANGE_SCENE_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_INTERCHANGE_SCENE_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>The cie_xyz_d65_interchange role is used to specify which color space in the config implements</para>
            /// <para>CIE XYZ colorimetry with the neutral axis at D65.  This may be used when converting</para>
            /// <para>display-referred colors from one config to another.</para>
            /// </summary>
            public static string ROLE_INTERCHANGE_DISPLAY
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_INTERCHANGE_DISPLAY_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._ROLE_INTERCHANGE_DISPLAY_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A shared view using this for the color space name will use a display color space that</para>
            /// <para>has the same name as the display the shared view is used by.</para>
            /// </summary>
            public static string OCIO_VIEW_USE_DISPLAY_NAME
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_VIEW_USE_DISPLAY_NAME_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_VIEW_USE_DISPLAY_NAME_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A description string -- used as the &quot;Description&quot; element in CLF/CTF and CDL, and to</para>
            /// <para>hold comments for other LUT formats when baking.</para>
            /// </summary>
            public static string METADATA_DESCRIPTION
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_DESCRIPTION_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_DESCRIPTION_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A block of informative metadata such as the &quot;Info&quot; element in CLF/CTF.</para>
            /// <para>Usually contains child elements.</para>
            /// </summary>
            public static string METADATA_INFO
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_INFO_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_INFO_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A string describing the expected input color space -- used as the &quot;InputDescriptor&quot;</para>
            /// <para>element in CLF/CTF and the &quot;InputDescription&quot; in CDL.</para>
            /// </summary>
            public static string METADATA_INPUT_DESCRIPTOR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_INPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_INPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A string describing the output color space -- used as the &quot;OutputDescriptor&quot; element</para>
            /// <para>in CLF/CTF and the &quot;OutputDescription&quot; in CDL.</para>
            /// </summary>
            public static string METADATA_OUTPUT_DESCRIPTOR
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_OUTPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_OUTPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>A name string -- used as a &quot;name&quot; attribute in CLF/CTF elements.  Use on a GroupTransform</para>
            /// <para>to get/set the name for the CLF/CTF ProcessList.  Use on an individual Transform</para>
            /// <para>(i.e. MatrixTransform, etc.) to get/set the name of the corresponding process node.</para>
            /// </summary>
            public static string METADATA_NAME
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_NAME_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_NAME_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>
            /// <para>An ID string -- used as an &quot;id&quot; attribute in CLF/CTF elements.  Use on a GroupTransform</para>
            /// <para>to get/set the id for the CLF/CTF ProcessList.  Use on an individual Transform</para>
            /// <para>(i.e. MatrixTransform, etc.) to get/set the id of the corresponding process node.</para>
            /// </summary>
            public static string METADATA_ID
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_ID_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._METADATA_ID_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>rst::</summary>
            public static string OCIO_DISABLE_ALL_CACHES
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_ALL_CACHES_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_ALL_CACHES_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>rst::</summary>
            public static string OCIO_DISABLE_PROCESSOR_CACHES
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_PROCESSOR_CACHES_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_PROCESSOR_CACHES_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            /// <summary>rst::</summary>
            public static string OCIO_DISABLE_CACHE_FALLBACK
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_CACHE_FALLBACK_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_DISABLE_CACHE_FALLBACK_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            public static string OCIO_CONFIG_DEFAULT_NAME
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_DEFAULT_NAME_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_DEFAULT_NAME_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            public static string OCIO_CONFIG_DEFAULT_FILE_EXT
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_DEFAULT_FILE_EXT_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_DEFAULT_FILE_EXT_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            public static string OCIO_CONFIG_ARCHIVE_FILE_EXT
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_ARCHIVE_FILE_EXT_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_CONFIG_ARCHIVE_FILE_EXT_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }

            public static string OCIO_BUILTIN_URI_PREFIX
            {
                get
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_BUILTIN_URI_PREFIX_OpenColorIO_v2_4__3PEBDEB;
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, *(__IntPtr*)(__ptr));
                }

                set
                {
                    var __ptr = (__IntPtr*)global::OpenColorIO.__Symbols.OpenColorIO._OCIO_BUILTIN_URI_PREFIX_OpenColorIO_v2_4__3PEBDEB;
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    *__ptr = __bytePtr0;
                }
            }
        }
    }

    namespace OpenColorIO_v2_4
    {
        /// <summary>
        /// <para>The FormatMetadata class is intended to be a generic container to hold metadata from various</para>
        /// <para>file formats.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class provides a hierarchical metadata container. A metadata object is similar to an</para>
        /// <para>element in XML. The top level element is named &quot;ROOT&quot; and can't be renamed. Several transforms</para>
        /// <para>have a FormatMetadata.</para>
        /// <para>The root element and all of the sub-elements may contain:</para>
        /// <para>* A name string (e.g. &quot;ROOT&quot;, &quot;Description&quot;...). Name can't be empty.</para>
        /// <para>* A value string (e.g. &quot;updated viewing LUT&quot;). Value can be empty.</para>
        /// <para>* A list of attributes (name, value) string pairs (e.g. &quot;version&quot;, &quot;1.5&quot;). There are helper</para>
        /// <para>functions to get and set &quot;id&quot; and &quot;name&quot; attributes. Attribute names are unique.</para>
        /// <para>* And a list of child sub-elements, which are also objects implementing FormatMetadata. There</para>
        /// <para>can be several sub-elements with the same name.</para>
        /// </remarks>
        public unsafe abstract partial class FormatMetadata : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_FormatMetadata;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0FormatMetadata@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static FormatMetadata __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new FormatMetadataInternal(native.ToPointer(), skipVTables);
            }

            internal static FormatMetadata __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (FormatMetadata)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static FormatMetadata __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (FormatMetadata)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static FormatMetadata __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FormatMetadataInternal(native, skipVTables);
            }

            protected FormatMetadata(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected FormatMetadata()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.FormatMetadata");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the name of a attribute (&quot;&quot; if attribute does not exist).</summary>
            public abstract string GetAttributeName(int i);

            /// <summary>Get the value of a attribute (&quot;&quot; if attribute does not exist).</summary>
            public abstract string GetAttributeValue(int i);

            /// <summary>Get the value of a attribute of a given name (&quot;&quot; if attribute does not exist).</summary>
            public abstract string GetAttributeValue(string name);

            /// <summary>
            /// <para>Add an attribute with a given name and value. If an attribute with the same name already</para>
            /// <para>exists, its value is replaced. Throw if name is NULL or empty.</para>
            /// </summary>
            public abstract void AddAttribute(string name, string value);

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata GetChildElement(int i);

            /// <summary>Add a child element with a given name and value.</summary>
            /// <remarks>
            /// <para>Name has to be non-empty. Value may be empty, particularly if this element will have</para>
            /// <para>children. Element is added after all existing children. Use</para>
            /// <para>getChildElement(getNumChildrenElements()-1) to access the added element.</para>
            /// </remarks>
            public abstract void AddChildElement(string name, string value);

            /// <summary>Remove all children, all attributes and the value.</summary>
            public abstract void Clear();

            public abstract string ElementName
            {
                get;

                set;
            }

            public abstract string ElementValue
            {
                get;

                set;
            }

            public abstract int NumAttributes
            {
                get;
            }

            public abstract int NumChildrenElements
            {
                get;
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'name' attribute.  This corresponds to the</para>
            /// <para>ProcessNode name attribute from a CLF / CTF file or the name key of a transform in the</para>
            /// <para>config YAML.</para>
            /// </summary>
            public abstract string Name
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'id' attribute.  This corresponds to the</para>
            /// <para>ProcessNode id attribute from a CLF/CTF file or the ColorCorrection id attribute from a</para>
            /// <para>CC/CCC/CDL file.</para>
            /// </summary>
            public abstract string ID
            {
                get;

                set;
            }

            #region Virtual table interop

            // char * getElementName() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetElementNameDelegateInstance;

            private static __IntPtr _GetElementNameDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.ElementName;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setElementName(const char *) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetElementNameDelegateInstance;

            private static void _SetElementNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _0)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.ElementName = _0;
            }

            // char * getElementValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetElementValueDelegateInstance;

            private static __IntPtr _GetElementValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.ElementValue;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setElementValue(const char *) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetElementValueDelegateInstance;

            private static void _SetElementValueDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _0)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.ElementValue = _0;
            }

            // int getNumAttributes() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetNumAttributesDelegateInstance;

            private static int _GetNumAttributesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.NumAttributes;
                return ___ret;
            }

            // char * getAttributeName(int i) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int _GetAttributeNameDelegateInstance;

            private static __IntPtr _GetAttributeNameDelegateHook(__IntPtr __instance, int i)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.GetAttributeName(i);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getAttributeValue(const char * name) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8 _GetAttributeValue_1DelegateInstance;

            private static __IntPtr _GetAttributeValue_1DelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.GetAttributeValue(name);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getAttributeValue(int i) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int _GetAttributeValueDelegateInstance;

            private static __IntPtr _GetAttributeValueDelegateHook(__IntPtr __instance, int i)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.GetAttributeValue(i);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void addAttribute(const char * name, const char * value) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8 _AddAttributeDelegateInstance;

            private static void _AddAttributeDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.AddAttribute(name, value);
            }

            // int getNumChildrenElements() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetNumChildrenElementsDelegateInstance;

            private static int _GetNumChildrenElementsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.NumChildrenElements;
                return ___ret;
            }

            // FormatMetadata & getChildElement(int i) = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int _GetChildElementDelegateInstance;

            private static __IntPtr _GetChildElementDelegateHook(__IntPtr __instance, int i)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.GetChildElement(i);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void addChildElement(const char * name, const char * value) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8_string8 _AddChildElementDelegateInstance;

            private static void _AddChildElementDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.AddChildElement(name, value);
            }

            // void clear() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ClearDelegateInstance;

            private static void _ClearDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.Clear();
            }

            // char * getName() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetNameDelegateInstance;

            private static __IntPtr _GetNameDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.Name;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setName(const char * name) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetNameDelegateInstance;

            private static void _SetNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.Name = name;
            }

            // char * getID() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetIDDelegateInstance;

            private static __IntPtr _GetIDDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                var ___ret = __target.ID;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setID(const char * id) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetIDDelegateInstance;

            private static void _SetIDDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.ID = id;
            }

            // virtual ~FormatMetadata() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[18];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetElementNameDelegateInstance += _GetElementNameDelegateHook;
                    _SetElementNameDelegateInstance += _SetElementNameDelegateHook;
                    _GetElementValueDelegateInstance += _GetElementValueDelegateHook;
                    _SetElementValueDelegateInstance += _SetElementValueDelegateHook;
                    _GetNumAttributesDelegateInstance += _GetNumAttributesDelegateHook;
                    _GetAttributeNameDelegateInstance += _GetAttributeNameDelegateHook;
                    _GetAttributeValue_1DelegateInstance += _GetAttributeValue_1DelegateHook;
                    _GetAttributeValueDelegateInstance += _GetAttributeValueDelegateHook;
                    _AddAttributeDelegateInstance += _AddAttributeDelegateHook;
                    _GetNumChildrenElementsDelegateInstance += _GetNumChildrenElementsDelegateHook;
                    _GetChildElementDelegateInstance += _GetChildElementDelegateHook;
                    _AddChildElementDelegateInstance += _AddChildElementDelegateHook;
                    _ClearDelegateInstance += _ClearDelegateHook;
                    _GetNameDelegateInstance += _GetNameDelegateHook;
                    _SetNameDelegateInstance += _SetNameDelegateHook;
                    _GetIDDelegateInstance += _GetIDDelegateHook;
                    _SetIDDelegateInstance += _SetIDDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetElementNameDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetElementNameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetElementValueDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetElementValueDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNumAttributesDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetAttributeNameDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetAttributeValue_1DelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetAttributeValueDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_AddAttributeDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetNumChildrenElementsDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetChildElementDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_AddChildElementDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetNameDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetIDDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SetIDDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 20, 0);
                                ManagedVTablesDtorOnly[0][19] = Thunks[17];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 20, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][12] = Thunks[11];
                                ManagedVTables[0][13] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                VTables.Methods[0] = new Delegate[20];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Base class for all the transform classes</summary>
        public unsafe abstract partial class Transform : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0Transform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Transform> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.Transform>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.Transform managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.Transform managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Transform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TransformInternal(native.ToPointer(), skipVTables);
            }

            internal static Transform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Transform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Transform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Transform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Transform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransformInternal(native, skipVTables);
            }

            protected Transform(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Transform()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.Transform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.Transform");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Will throw if data is not valid.</summary>
            public virtual void Validate()
            {
                var ___ValidateDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 4);
                ___ValidateDelegate(__Instance);
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Transform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Transform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Transform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Transform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~Transform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Transform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Forward direction wraps the 'expanded' range into the</para>
        /// <para>specified, often compressed, range.</para>
        /// </summary>
        public unsafe partial class AllocationTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getVars@AllocationTransform@OpenColorIO_v2_4@@QEBAXPEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetVars(__IntPtr __instance, float* vars);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setVars@AllocationTransform@OpenColorIO_v2_4@@QEAAXHPEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVars(__IntPtr __instance, int numvars, float* vars);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getAllocation@AllocationTransform@OpenColorIO_v2_4@@QEBA?AW4Allocation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.Allocation GetAllocation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setAllocation@AllocationTransform@OpenColorIO_v2_4@@QEAAXW4Allocation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAllocation(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Allocation allocation);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getNumVars@AllocationTransform@OpenColorIO_v2_4@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumVars(__IntPtr __instance);
            }

            internal static new AllocationTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AllocationTransform(native.ToPointer(), skipVTables);
            }

            internal static new AllocationTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AllocationTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AllocationTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AllocationTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AllocationTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AllocationTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private AllocationTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AllocationTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 5);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Will throw if data is not valid.</summary>
            public override void Validate()
            {
                base.Validate();
            }

            public void GetVars(ref float vars)
            {
                fixed (float* __vars0 = &vars)
                {
                    var __arg0 = __vars0;
                    __Internal.GetVars(__Instance, __arg0);
                }
            }

            public void SetVars(int numvars, ref float vars)
            {
                fixed (float* __vars1 = &vars)
                {
                    var __arg1 = __vars1;
                    __Internal.SetVars(__Instance, numvars, __arg1);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.Allocation Allocation
            {
                get
                {
                    var ___ret = __Internal.GetAllocation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAllocation(__Instance, value);
                }
            }

            public int NumVars
            {
                get
                {
                    var ___ret = __Internal.GetNumVars(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.AllocationTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept override
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.AllocationTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.AllocationTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const override
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.AllocationTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~AllocationTransform()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.AllocationTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>A built-in transform is similar to a FileTransform, but without the file.</para>
        /// <para>OCIO knows how to build a set of commonly used transforms on-demand, thus avoiding the need</para>
        /// <para>for external files and simplifying config authoring.</para>
        /// </summary>
        public unsafe abstract partial class BuiltinTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0BuiltinTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new BuiltinTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BuiltinTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new BuiltinTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BuiltinTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new BuiltinTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BuiltinTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BuiltinTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BuiltinTransformInternal(native, skipVTables);
            }

            protected BuiltinTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected BuiltinTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.BuiltinTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract string Style
            {
                get;

                set;
            }

            public abstract string Description
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~BuiltinTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char * getStyle() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetStyleDelegateInstance;

            private static __IntPtr _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setStyle(const char * style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // char * getDescription() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetDescriptionDelegateInstance;

            private static __IntPtr _GetDescriptionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform.__GetInstance(__instance);
                var ___ret = __target.Description;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[8];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetDescriptionDelegateInstance += _GetDescriptionDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetDescriptionDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 9, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][8] = Thunks[7];
                                VTables.Methods[0] = new Delegate[9];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>An implementation of the ASC Color Decision List (CDL), based on the ASC v1.2</para>
        /// <para>specification.</para>
        /// </summary>
        /// <remarks>
        /// <para>**ASC_SOP**</para>
        /// <para>Slope, offset, power::</para>
        /// <para>out = clamp( (in * slope) + offset ) ^ power</para>
        /// <para>​</para>
        /// <para>If the config version is 1, negative values are clamped if the power is not 1.0.</para>
        /// <para>For config version 2 and higher, the negative handling is controlled by the CDL style.</para>
        /// </remarks>
        public unsafe abstract partial class CDLTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0CDLTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new CDLTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CDLTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new CDLTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CDLTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new CDLTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CDLTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CDLTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CDLTransformInternal(native, skipVTables);
            }

            protected CDLTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CDLTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.CDLTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.CDLTransform other);

            public abstract void GetSlope(ref double rgb);

            public abstract void SetSlope(ref double rgb);

            public abstract void GetOffset(ref double rgb);

            public abstract void SetOffset(ref double rgb);

            public abstract void GetPower(ref double rgb);

            public abstract void SetPower(ref double rgb);

            public abstract void GetSOP(ref double vec9);

            public abstract void SetSOP(ref double vec9);

            /// <summary>These are hard-coded, by spec, to r709.</summary>
            public abstract void GetSatLumaCoefs(ref double rgb);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.CDLStyle Style
            {
                get;

                set;
            }

            public abstract double Sat
            {
                get;

                set;
            }

            /// <summary>
            /// <para>The get/setID methods are now deprecated. The preferred way of interacting with the ID is</para>
            /// <para>now via the transform's formatMetadata.</para>
            /// </summary>
            public abstract string ID
            {
                get;

                set;
            }

            public abstract string FirstSOPDescription
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~CDLTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const CDLTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // CDLStyle getStyle() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_CDLStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.CDLStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(CDLStyle style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_CDLStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.CDLStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // void getSlope(double * rgb) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetSlopeDelegateInstance;

            private static void _GetSlopeDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.GetSlope(ref *rgb);
            }

            // void setSlope(const double * rgb) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetSlopeDelegateInstance;

            private static void _SetSlopeDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.SetSlope(ref *rgb);
            }

            // void getOffset(double * rgb) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetOffsetDelegateInstance;

            private static void _GetOffsetDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.GetOffset(ref *rgb);
            }

            // void setOffset(const double * rgb) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetOffsetDelegateInstance;

            private static void _SetOffsetDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.SetOffset(ref *rgb);
            }

            // void getPower(double * rgb) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetPowerDelegateInstance;

            private static void _GetPowerDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.GetPower(ref *rgb);
            }

            // void setPower(const double * rgb) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetPowerDelegateInstance;

            private static void _SetPowerDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.SetPower(ref *rgb);
            }

            // void getSOP(double * vec9) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetSOPDelegateInstance;

            private static void _GetSOPDelegateHook(__IntPtr __instance, double* vec9)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.GetSOP(ref *vec9);
            }

            // void setSOP(const double * vec9) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetSOPDelegateInstance;

            private static void _SetSOPDelegateHook(__IntPtr __instance, double* vec9)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.SetSOP(ref *vec9);
            }

            // double getSat() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetSatDelegateInstance;

            private static double _GetSatDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.Sat;
                return ___ret;
            }

            // void setSat(double sat) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetSatDelegateInstance;

            private static void _SetSatDelegateHook(__IntPtr __instance, double sat)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.Sat = sat;
            }

            // void getSatLumaCoefs(double * rgb) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetSatLumaCoefsDelegateInstance;

            private static void _GetSatLumaCoefsDelegateHook(__IntPtr __instance, double* rgb)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.GetSatLumaCoefs(ref *rgb);
            }

            // char * getID() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetIDDelegateInstance;

            private static __IntPtr _GetIDDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.ID;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setID(const char * id) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetIDDelegateInstance;

            private static void _SetIDDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.ID = id;
            }

            // char * getFirstSOPDescription() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFirstSOPDescriptionDelegateInstance;

            private static __IntPtr _GetFirstSOPDescriptionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                var ___ret = __target.FirstSOPDescription;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setFirstSOPDescription(const char * description) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetFirstSOPDescriptionDelegateInstance;

            private static void _SetFirstSOPDescriptionDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string description)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.CDLTransform.__GetInstance(__instance);
                __target.FirstSOPDescription = description;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[24];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetSlopeDelegateInstance += _GetSlopeDelegateHook;
                    _SetSlopeDelegateInstance += _SetSlopeDelegateHook;
                    _GetOffsetDelegateInstance += _GetOffsetDelegateHook;
                    _SetOffsetDelegateInstance += _SetOffsetDelegateHook;
                    _GetPowerDelegateInstance += _GetPowerDelegateHook;
                    _SetPowerDelegateInstance += _SetPowerDelegateHook;
                    _GetSOPDelegateInstance += _GetSOPDelegateHook;
                    _SetSOPDelegateInstance += _SetSOPDelegateHook;
                    _GetSatDelegateInstance += _GetSatDelegateHook;
                    _SetSatDelegateInstance += _SetSatDelegateHook;
                    _GetSatLumaCoefsDelegateInstance += _GetSatLumaCoefsDelegateHook;
                    _GetIDDelegateInstance += _GetIDDelegateHook;
                    _SetIDDelegateInstance += _SetIDDelegateHook;
                    _GetFirstSOPDescriptionDelegateInstance += _GetFirstSOPDescriptionDelegateHook;
                    _SetFirstSOPDescriptionDelegateInstance += _SetFirstSOPDescriptionDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetSlopeDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetSlopeDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetOffsetDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetOffsetDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetPowerDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetPowerDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetSOPDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SetSOPDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetSatDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_SetSatDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetSatLumaCoefsDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_GetIDDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_SetIDDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_GetFirstSOPDescriptionDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_SetFirstSOPDescriptionDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 26, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 26, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][7] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                ManagedVTables[0][23] = Thunks[21];
                                ManagedVTables[0][24] = Thunks[22];
                                ManagedVTables[0][25] = Thunks[23];
                                VTables.Methods[0] = new Delegate[26];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ColorSpaceTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSrc@ColorSpaceTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSrc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSrc@ColorSpaceTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSrc(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDst@ColorSpaceTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDst(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDst@ColorSpaceTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDst(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDataBypass@ColorSpaceTransform@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetDataBypass(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDataBypass@ColorSpaceTransform@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDataBypass(__IntPtr __instance, bool enabled);
            }

            internal static new ColorSpaceTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ColorSpaceTransform(native.ToPointer(), skipVTables);
            }

            internal static new ColorSpaceTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ColorSpaceTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ColorSpaceTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ColorSpaceTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ColorSpaceTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ColorSpaceTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ColorSpaceTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ColorSpaceTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 5);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override void Validate()
            {
                base.Validate();
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public string Src
            {
                get
                {
                    var ___ret = __Internal.GetSrc(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSrc(__Instance, value);
                }
            }

            public string Dst
            {
                get
                {
                    var ___ret = __Internal.GetDst(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDst(__Instance, value);
                }
            }

            /// <summary>Data color spaces do not get processed when true (which is the default).</summary>
            public bool DataBypass
            {
                get
                {
                    var ___ret = __Internal.GetDataBypass(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDataBypass(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept override
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const override
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~ColorSpaceTransform()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class DisplayViewTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSrc@DisplayViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSrc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSrc@DisplayViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSrc(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDisplay@DisplayViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDisplay(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDisplay@DisplayViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDisplay(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string display);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getView@DisplayViewTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetView(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setView@DisplayViewTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetView(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string view);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLooksBypass@DisplayViewTransform@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetLooksBypass(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setLooksBypass@DisplayViewTransform@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLooksBypass(__IntPtr __instance, bool bypass);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDataBypass@DisplayViewTransform@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetDataBypass(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDataBypass@DisplayViewTransform@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDataBypass(__IntPtr __instance, bool bypass);
            }

            internal static new DisplayViewTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DisplayViewTransform(native.ToPointer(), skipVTables);
            }

            internal static new DisplayViewTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DisplayViewTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DisplayViewTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DisplayViewTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DisplayViewTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DisplayViewTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DisplayViewTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DisplayViewTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 5);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Will throw if data is not valid.</summary>
            public override void Validate()
            {
                base.Validate();
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public string Src
            {
                get
                {
                    var ___ret = __Internal.GetSrc(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSrc(__Instance, value);
                }
            }

            public string Display
            {
                get
                {
                    var ___ret = __Internal.GetDisplay(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDisplay(__Instance, value);
                }
            }

            public string View
            {
                get
                {
                    var ___ret = __Internal.GetView(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetView(__Instance, value);
                }
            }

            public bool LooksBypass
            {
                get
                {
                    var ___ret = __Internal.GetLooksBypass(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLooksBypass(__Instance, value);
                }
            }

            public bool DataBypass
            {
                get
                {
                    var ___ret = __Internal.GetDataBypass(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDataBypass(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DisplayViewTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept override
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DisplayViewTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DisplayViewTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const override
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DisplayViewTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~DisplayViewTransform()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DisplayViewTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Used by the grading transforms to hold the red, green, blue, and master components</para>
        /// <para>of a single parameter.  The master component affects all three channels (RGB).</para>
        /// </summary>
        public unsafe partial class GradingRGBM : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal double m_red;
                internal double m_green;
                internal double m_blue;
                internal double m_master;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBM@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBM@OpenColorIO_v2_4@@QEAA@NNNN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double red, double green, double blue, double master);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBM@OpenColorIO_v2_4@@QEAA@AEAY03$$CBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double[] rgbm);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBM@OpenColorIO_v2_4@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBUGradingRGBM@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBUGradingRGBM@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingRGBM __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingRGBM(native.ToPointer(), skipVTables);
            }

            internal static GradingRGBM __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingRGBM)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingRGBM __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingRGBM(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GradingRGBM(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GradingRGBM(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GradingRGBM()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public GradingRGBM(double red, double green, double blue, double master)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, red, green, blue, master);
            }

            public GradingRGBM(double[] rgbm)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (rgbm == null || rgbm.Length != 4)
                    throw new ArgumentOutOfRangeException("rgbm", "The dimensions of the provided array don't match the required size.");
                __Internal.ctor(__Instance, rgbm);
            }

            public GradingRGBM(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) __Instance) = *((global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM(double[] rgbm)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM(rgbm);
            }

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public double MRed
            {
                get
                {
                    return ((__Internal*)__Instance)->m_red;
                }

                set
                {
                    ((__Internal*)__Instance)->m_red = value;
                }
            }

            public double MGreen
            {
                get
                {
                    return ((__Internal*)__Instance)->m_green;
                }

                set
                {
                    ((__Internal*)__Instance)->m_green = value;
                }
            }

            public double MBlue
            {
                get
                {
                    return ((__Internal*)__Instance)->m_blue;
                }

                set
                {
                    ((__Internal*)__Instance)->m_blue = value;
                }
            }

            public double MMaster
            {
                get
                {
                    return ((__Internal*)__Instance)->m_master;
                }

                set
                {
                    ((__Internal*)__Instance)->m_master = value;
                }
            }
        }

        /// <summary>Grading primary values.</summary>
        public unsafe partial class GradingPrimary : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 272)]
            public partial struct __Internal
            {
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_brightness;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_contrast;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_gamma;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_offset;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_exposure;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_lift;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal m_gain;
                internal double m_saturation;
                internal double m_pivot;
                internal double m_pivotBlack;
                internal double m_pivotWhite;
                internal double m_clampBlack;
                internal double m_clampWhite;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingPrimary@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingPrimary@OpenColorIO_v2_4@@QEAA@W4GradingStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingPrimary@OpenColorIO_v2_4@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?validate@GradingPrimary@OpenColorIO_v2_4@@QEBAXW4GradingStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Validate(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBUGradingPrimary@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBUGradingPrimary@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?NoClampBlack@GradingPrimary@OpenColorIO_v2_4@@SANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double NoClampBlack();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?NoClampWhite@GradingPrimary@OpenColorIO_v2_4@@SANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double NoClampWhite();
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingPrimary __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingPrimary(native.ToPointer(), skipVTables);
            }

            internal static GradingPrimary __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingPrimary)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingPrimary __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingPrimary(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GradingPrimary(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GradingPrimary(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GradingPrimary()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public GradingPrimary(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, style);
            }

            public GradingPrimary(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal*) __Instance) = *((global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The valid range for each parameter varies.</summary>
            public void Validate(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                __Internal.Validate(__Instance, style);
            }

            public static explicit operator global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary(style);
            }

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MBrightness
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_brightness));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_brightness = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MContrast
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_contrast));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_contrast = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MGamma
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_gamma));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_gamma = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MOffset
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_offset));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_offset = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MExposure
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_exposure));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_exposure = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MLift
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_lift));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_lift = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM MGain
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_gain));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_gain = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBM.__Internal*) value.__Instance;
                }
            }

            public double MSaturation
            {
                get
                {
                    return ((__Internal*)__Instance)->m_saturation;
                }

                set
                {
                    ((__Internal*)__Instance)->m_saturation = value;
                }
            }

            public double MPivot
            {
                get
                {
                    return ((__Internal*)__Instance)->m_pivot;
                }

                set
                {
                    ((__Internal*)__Instance)->m_pivot = value;
                }
            }

            public double MPivotBlack
            {
                get
                {
                    return ((__Internal*)__Instance)->m_pivotBlack;
                }

                set
                {
                    ((__Internal*)__Instance)->m_pivotBlack = value;
                }
            }

            public double MPivotWhite
            {
                get
                {
                    return ((__Internal*)__Instance)->m_pivotWhite;
                }

                set
                {
                    ((__Internal*)__Instance)->m_pivotWhite = value;
                }
            }

            public double MClampBlack
            {
                get
                {
                    return ((__Internal*)__Instance)->m_clampBlack;
                }

                set
                {
                    ((__Internal*)__Instance)->m_clampBlack = value;
                }
            }

            public double MClampWhite
            {
                get
                {
                    return ((__Internal*)__Instance)->m_clampWhite;
                }

                set
                {
                    ((__Internal*)__Instance)->m_clampWhite = value;
                }
            }

            public static double NoClampBlack
            {
                get
                {
                    var ___ret = __Internal.NoClampBlack();
                    return ___ret;
                }
            }

            public static double NoClampWhite
            {
                get
                {
                    var ___ret = __Internal.NoClampWhite();
                    return ___ret;
                }
            }
        }

        /// <summary>2D control point used by</summary>
        public unsafe partial class GradingControlPoint : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal float m_x;
                internal float m_y;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingControlPoint@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingControlPoint@OpenColorIO_v2_4@@QEAA@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, float x, float y);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingControlPoint@OpenColorIO_v2_4@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBUGradingControlPoint@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBUGradingControlPoint@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingControlPoint __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingControlPoint(native.ToPointer(), skipVTables);
            }

            internal static GradingControlPoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingControlPoint)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingControlPoint __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingControlPoint(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GradingControlPoint(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GradingControlPoint(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GradingControlPoint()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public GradingControlPoint(float x, float y)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, x, y);
            }

            public GradingControlPoint(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal*) __Instance) = *((global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public float MX
            {
                get
                {
                    return ((__Internal*)__Instance)->m_x;
                }

                set
                {
                    ((__Internal*)__Instance)->m_x = value;
                }
            }

            public float MY
            {
                get
                {
                    return ((__Internal*)__Instance)->m_y;
                }

                set
                {
                    ((__Internal*)__Instance)->m_y = value;
                }
            }
        }

        /// <summary>A BSpline curve defined with</summary>
        public unsafe abstract partial class GradingBSplineCurve : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GradingBSplineCurve;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingBSplineCurve@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBVGradingBSplineCurve@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBVGradingBSplineCurve@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingBSplineCurve __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingBSplineCurveInternal(native.ToPointer(), skipVTables);
            }

            internal static GradingBSplineCurve __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingBSplineCurve)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingBSplineCurve __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GradingBSplineCurve)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GradingBSplineCurve __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingBSplineCurveInternal(native, skipVTables);
            }

            protected GradingBSplineCurve(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GradingBSplineCurve()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint GetControlPoint(ulong index);

            public abstract float GetSlope(ulong index);

            public abstract void SetSlope(ulong index, float slope);

            public abstract void Validate();

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public abstract ulong NumControlPoints
            {
                get;

                set;
            }

            public abstract bool SlopesAreDefault
            {
                get;
            }

            #region Virtual table interop

            // size_t getNumControlPoints() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumControlPointsDelegateInstance;

            private static ulong _GetNumControlPointsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                var ___ret = __target.NumControlPoints;
                return ___ret;
            }

            // void setNumControlPoints(size_t size) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_ulong _SetNumControlPointsDelegateInstance;

            private static void _SetNumControlPointsDelegateHook(__IntPtr __instance, ulong size)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                __target.NumControlPoints = size;
            }

            // GradingControlPoint & getControlPoint(size_t index) = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetControlPointDelegateInstance;

            private static __IntPtr _GetControlPointDelegateHook(__IntPtr __instance, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                var ___ret = __target.GetControlPoint(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // float getSlope(size_t index) const = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr_ulong _GetSlopeDelegateInstance;

            private static float _GetSlopeDelegateHook(__IntPtr __instance, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                var ___ret = __target.GetSlope(index);
                return ___ret;
            }

            // void setSlope(size_t index, float slope) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_ulong_float _SetSlopeDelegateInstance;

            private static void _SetSlopeDelegateHook(__IntPtr __instance, ulong index, float slope)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                __target.SetSlope(index, slope);
            }

            // bool slopesAreDefault() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _SlopesAreDefaultDelegateInstance;

            private static bool _SlopesAreDefaultDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                var ___ret = __target.SlopesAreDefault;
                return ___ret;
            }

            // void validate() const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~GradingBSplineCurve() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[8];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNumControlPointsDelegateInstance += _GetNumControlPointsDelegateHook;
                    _SetNumControlPointsDelegateInstance += _SetNumControlPointsDelegateHook;
                    _GetControlPointDelegateInstance += _GetControlPointDelegateHook;
                    _GetSlopeDelegateInstance += _GetSlopeDelegateHook;
                    _SetSlopeDelegateInstance += _SetSlopeDelegateHook;
                    _SlopesAreDefaultDelegateInstance += _SlopesAreDefaultDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNumControlPointsDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetNumControlPointsDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetControlPointDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSlopeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetSlopeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_SlopesAreDefaultDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 10, 0);
                                ManagedVTablesDtorOnly[0][9] = Thunks[7];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 10, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][5] = Thunks[3];
                                ManagedVTables[0][6] = Thunks[4];
                                ManagedVTables[0][7] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                VTables.Methods[0] = new Delegate[10];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>A set of red, green, blue and master curves. It is used by RGBCurveTransform and can be used as</para>
        /// <para>a dynamic property (see</para>
        /// </summary>
        public unsafe abstract partial class GradingRGBCurve : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GradingRGBCurve;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBCurve@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBCurve@OpenColorIO_v2_4@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBVGradingRGBCurve@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBVGradingRGBCurve@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingRGBCurve __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingRGBCurveInternal(native.ToPointer(), skipVTables);
            }

            internal static GradingRGBCurve __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingRGBCurve)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingRGBCurve __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GradingRGBCurve)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GradingRGBCurve __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingRGBCurveInternal(native, skipVTables);
            }

            protected GradingRGBCurve(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GradingRGBCurve()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve");
            }

            protected GradingRGBCurve(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract void Validate();

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public abstract bool IsIdentity
            {
                get;
            }

            #region Virtual table interop

            // void validate() const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__GetInstance(__instance);
                __target.Validate();
            }

            // bool isIdentity() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsIdentityDelegateInstance;

            private static bool _IsIdentityDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__GetInstance(__instance);
                var ___ret = __target.IsIdentity;
                return ___ret;
            }

            // virtual ~GradingRGBCurve() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _IsIdentityDelegateInstance += _IsIdentityDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsIdentityDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[2];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][5] = Thunks[2];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Used by the grading tone transforms to hold the red, green, blue, master, start,</para>
        /// <para>and width components of a single parameter.  The master component affects all three channels</para>
        /// <para>(RGB).  The start and width components control the range of tones affected. Although this</para>
        /// <para>struct simply uses &quot;start&quot; and &quot;width&quot; for all the range values, the actual user-facing name</para>
        /// <para>changes based on the parameter.</para>
        /// </summary>
        public unsafe partial class GradingRGBMSW : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal double m_red;
                internal double m_green;
                internal double m_blue;
                internal double m_master;
                internal double m_start;
                internal double m_width;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBMSW@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBMSW@OpenColorIO_v2_4@@QEAA@NNNNNN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double red, double green, double blue, double master, double start, double width);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBMSW@OpenColorIO_v2_4@@QEAA@AEAY05$$CBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double[] rgbmsw);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBMSW@OpenColorIO_v2_4@@QEAA@NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double start, double width);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBMSW@OpenColorIO_v2_4@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBUGradingRGBMSW@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBUGradingRGBMSW@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingRGBMSW __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingRGBMSW(native.ToPointer(), skipVTables);
            }

            internal static GradingRGBMSW __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingRGBMSW)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingRGBMSW __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingRGBMSW(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GradingRGBMSW(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GradingRGBMSW(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GradingRGBMSW()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public GradingRGBMSW(double red, double green, double blue, double master, double start, double width)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, red, green, blue, master, start, width);
            }

            public GradingRGBMSW(double[] rgbmsw)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (rgbmsw == null || rgbmsw.Length != 6)
                    throw new ArgumentOutOfRangeException("rgbmsw", "The dimensions of the provided array don't match the required size.");
                __Internal.ctor(__Instance, rgbmsw);
            }

            public GradingRGBMSW(double start, double width)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, start, width);
            }

            public GradingRGBMSW(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) __Instance) = *((global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW(double[] rgbmsw)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW(rgbmsw);
            }

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public double MRed
            {
                get
                {
                    return ((__Internal*)__Instance)->m_red;
                }

                set
                {
                    ((__Internal*)__Instance)->m_red = value;
                }
            }

            public double MGreen
            {
                get
                {
                    return ((__Internal*)__Instance)->m_green;
                }

                set
                {
                    ((__Internal*)__Instance)->m_green = value;
                }
            }

            public double MBlue
            {
                get
                {
                    return ((__Internal*)__Instance)->m_blue;
                }

                set
                {
                    ((__Internal*)__Instance)->m_blue = value;
                }
            }

            public double MMaster
            {
                get
                {
                    return ((__Internal*)__Instance)->m_master;
                }

                set
                {
                    ((__Internal*)__Instance)->m_master = value;
                }
            }

            public double MStart
            {
                get
                {
                    return ((__Internal*)__Instance)->m_start;
                }

                set
                {
                    ((__Internal*)__Instance)->m_start = value;
                }
            }

            public double MWidth
            {
                get
                {
                    return ((__Internal*)__Instance)->m_width;
                }

                set
                {
                    ((__Internal*)__Instance)->m_width = value;
                }
            }
        }

        /// <summary>Grading tone values.</summary>
        public unsafe partial class GradingTone : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 248)]
            public partial struct __Internal
            {
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal m_blacks;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal m_shadows;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal m_midtones;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal m_highlights;
                internal global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal m_whites;
                internal double m_scontrast;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingTone@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingTone@OpenColorIO_v2_4@@QEAA@W4GradingStyle@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingTone@OpenColorIO_v2_4@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?validate@GradingTone@OpenColorIO_v2_4@@QEBAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Validate(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??8OpenColorIO_v2_4@@YA_NAEBUGradingTone@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??9OpenColorIO_v2_4@@YA_NAEBUGradingTone@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingTone> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.GradingTone>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.GradingTone managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.GradingTone managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GradingTone __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingTone(native.ToPointer(), skipVTables);
            }

            internal static GradingTone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingTone)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GradingTone __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingTone(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GradingTone(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GradingTone(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GradingTone()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public GradingTone(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, style);
            }

            public GradingTone(global::OpenColorIO.OpenColorIO_v2_4.GradingTone _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal*) __Instance) = *((global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>The valid range for each parameter varies. The client is expected to enforce</para>
            /// <para>these bounds in the UI.</para>
            /// </summary>
            public void Validate()
            {
                __Internal.Validate(__Instance);
            }

            public static explicit operator global::OpenColorIO.OpenColorIO_v2_4.GradingTone(global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                return new global::OpenColorIO.OpenColorIO_v2_4.GradingTone(style);
            }

            public static bool operator ==(global::OpenColorIO.OpenColorIO_v2_4.GradingTone lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingTone rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenColorIO.OpenColorIO_v2_4.GradingTone;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenColorIO.OpenColorIO_v2_4.GradingTone lhs, global::OpenColorIO.OpenColorIO_v2_4.GradingTone rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW MBlacks
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_blacks));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_blacks = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW MShadows
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_shadows));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_shadows = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW MMidtones
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_midtones));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_midtones = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW MHighlights
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_highlights));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_highlights = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) value.__Instance;
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW MWhites
            {
                get
                {
                    return global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_whites));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_whites = *(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBMSW.__Internal*) value.__Instance;
                }
            }

            public double MScontrast
            {
                get
                {
                    return ((__Internal*)__Instance)->m_scontrast;
                }

                set
                {
                    ((__Internal*)__Instance)->m_scontrast = value;
                }
            }
        }

        /// <summary>
        /// <para>Allows transform parameter values to be set on-the-fly (after finalization).  For</para>
        /// <para>example, to modify the exposure in a viewport.  Dynamic properties can be accessed from the</para>
        /// <para>`CPUProcessor` or `GpuShaderCreator` to change values between processing.</para>
        /// </summary>
        public unsafe abstract partial class DynamicProperty : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_DynamicProperty;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0DynamicProperty@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DynamicProperty __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DynamicPropertyInternal(native.ToPointer(), skipVTables);
            }

            internal static DynamicProperty __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DynamicProperty)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DynamicProperty __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DynamicProperty)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DynamicProperty __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicPropertyInternal(native, skipVTables);
            }

            protected DynamicProperty(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected DynamicProperty()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.DynamicProperty");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType Type
            {
                get;
            }

            #region Virtual table interop

            // DynamicPropertyType getType() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_DynamicPropertyType___IntPtr _GetTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType _GetTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty.__GetInstance(__instance);
                var ___ret = __target.Type;
                return ___ret;
            }

            // virtual ~DynamicProperty() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetTypeDelegateInstance += _GetTypeDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetTypeDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][1] = Thunks[1];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Interface used to access dynamic property double value.</summary>
        public unsafe abstract partial class DynamicPropertyDouble : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_DynamicPropertyDouble;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0DynamicPropertyDouble@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DynamicPropertyDouble __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DynamicPropertyDoubleInternal(native.ToPointer(), skipVTables);
            }

            internal static DynamicPropertyDouble __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DynamicPropertyDouble)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DynamicPropertyDouble __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DynamicPropertyDouble)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DynamicPropertyDouble __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicPropertyDoubleInternal(native, skipVTables);
            }

            protected DynamicPropertyDouble(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected DynamicPropertyDouble()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract double Value
            {
                get;

                set;
            }

            #region Virtual table interop

            // double getValue() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetValueDelegateInstance;

            private static double _GetValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble.__GetInstance(__instance);
                var ___ret = __target.Value;
                return ___ret;
            }

            // void setValue(double value) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, double value)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble.__GetInstance(__instance);
                __target.Value = value;
            }

            // virtual ~DynamicPropertyDouble() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][2] = Thunks[2];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Interface used to access dynamic property GradingPrimary value.</summary>
        public unsafe abstract partial class DynamicPropertyGradingPrimary : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_DynamicPropertyGradingPrimary;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0DynamicPropertyGradingPrimary@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DynamicPropertyGradingPrimary __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DynamicPropertyGradingPrimaryInternal(native.ToPointer(), skipVTables);
            }

            internal static DynamicPropertyGradingPrimary __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DynamicPropertyGradingPrimary)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DynamicPropertyGradingPrimary __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DynamicPropertyGradingPrimary)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DynamicPropertyGradingPrimary __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicPropertyGradingPrimaryInternal(native, skipVTables);
            }

            protected DynamicPropertyGradingPrimary(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected DynamicPropertyGradingPrimary()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary Value
            {
                get;

                set;
            }

            #region Virtual table interop

            // GradingPrimary & getValue() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetValueDelegateInstance;

            private static __IntPtr _GetValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary.__GetInstance(__instance);
                var ___ret = __target.Value;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setValue(const GradingPrimary & value) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, __IntPtr value)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__GetOrCreateInstance(value, false);
                __target.Value = __result0;
            }

            // virtual ~DynamicPropertyGradingPrimary() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][2] = Thunks[2];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Interface used to access dynamic property ConstGradingRGBCurveRcPtr value.</summary>
        public unsafe abstract partial class DynamicPropertyGradingRGBCurve : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_DynamicPropertyGradingRGBCurve;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0DynamicPropertyGradingRGBCurve@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DynamicPropertyGradingRGBCurve __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DynamicPropertyGradingRGBCurveInternal(native.ToPointer(), skipVTables);
            }

            internal static DynamicPropertyGradingRGBCurve __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DynamicPropertyGradingRGBCurve)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DynamicPropertyGradingRGBCurve __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DynamicPropertyGradingRGBCurve)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DynamicPropertyGradingRGBCurve __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicPropertyGradingRGBCurveInternal(native, skipVTables);
            }

            protected DynamicPropertyGradingRGBCurve(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected DynamicPropertyGradingRGBCurve()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // virtual ~DynamicPropertyGradingRGBCurve() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][2] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][2] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Interface used to access dynamic property GradingTone value.</summary>
        public unsafe abstract partial class DynamicPropertyGradingTone : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_DynamicPropertyGradingTone;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0DynamicPropertyGradingTone@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DynamicPropertyGradingTone __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DynamicPropertyGradingToneInternal(native.ToPointer(), skipVTables);
            }

            internal static DynamicPropertyGradingTone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DynamicPropertyGradingTone)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DynamicPropertyGradingTone __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DynamicPropertyGradingTone)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DynamicPropertyGradingTone __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicPropertyGradingToneInternal(native, skipVTables);
            }

            protected DynamicPropertyGradingTone(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected DynamicPropertyGradingTone()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingTone Value
            {
                get;

                set;
            }

            #region Virtual table interop

            // GradingTone & getValue() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetValueDelegateInstance;

            private static __IntPtr _GetValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone.__GetInstance(__instance);
                var ___ret = __target.Value;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setValue(const GradingTone & value) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, __IntPtr value)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__GetOrCreateInstance(value, false);
                __target.Value = __result0;
            }

            // virtual ~DynamicPropertyGradingTone() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[3];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTablesDtorOnly[0][2] = Thunks[2];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents exponent transform: pow( clamp(color), value ).</summary>
        /// <remarks>
        /// <para>For configs with version == 1: Negative style is ignored and if the exponent is 1.0,</para>
        /// <para>this will not clamp. Otherwise, the input color will be clamped between [0.0, inf].</para>
        /// <para>For configs with version &gt; 1: Negative value handling may be specified via setNegativeStyle.</para>
        /// </remarks>
        public unsafe abstract partial class ExponentTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExponentTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new ExponentTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ExponentTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new ExponentTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ExponentTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ExponentTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ExponentTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ExponentTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ExponentTransformInternal(native, skipVTables);
            }

            protected ExponentTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ExponentTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ExponentTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform other);

            public abstract void GetValue(double[] vec4);

            public abstract void SetValue(double[] vec4);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_CLAMP -- Clamp negative values (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// <para>* NEGATIVE_PASS_THRU -- Negative values are passed through unchanged.</para>
            /// </remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyle
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~ExponentTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const ExponentTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // void getValue(double(&vec4)[4]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetValueDelegateInstance;

            private static void _GetValueDelegateHook(__IntPtr __instance, double[] vec4)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.GetValue(vec4);
            }

            // void setValue(const double(&vec4)[4]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, double[] vec4)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.SetValue(vec4);
            }

            // NegativeStyle getNegativeStyle() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr _GetNegativeStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle _GetNegativeStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                var ___ret = __target.NegativeStyle;
                return ___ret;
            }

            // void setNegativeStyle(NegativeStyle style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle _SetNegativeStyleDelegateInstance;

            private static void _SetNegativeStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform.__GetInstance(__instance);
                __target.NegativeStyle = style;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[11];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _GetNegativeStyleDelegateInstance += _GetNegativeStyleDelegateHook;
                    _SetNegativeStyleDelegateInstance += _SetNegativeStyleDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetNegativeStyleDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetNegativeStyleDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 13, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 13, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                VTables.Methods[0] = new Delegate[13];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Represents power functions with a linear section in the shadows</para>
        /// <para>such as sRGB and L*.</para>
        /// </summary>
        /// <remarks>
        /// <para>The basic formula is::</para>
        /// <para>pow( (x + offset)/(1 + offset), gamma )</para>
        /// <para>with the breakpoint at offset/(gamma - 1).</para>
        /// <para>Negative values are never clamped.</para>
        /// </remarks>
        public unsafe abstract partial class ExponentWithLinearTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExponentWithLinearTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new ExponentWithLinearTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ExponentWithLinearTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new ExponentWithLinearTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ExponentWithLinearTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ExponentWithLinearTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ExponentWithLinearTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ExponentWithLinearTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ExponentWithLinearTransformInternal(native, skipVTables);
            }

            protected ExponentWithLinearTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ExponentWithLinearTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform other);

            public abstract void GetGamma(double[] values);

            /// <summary>Set the exponent value for the power function for R, G, B, A.</summary>
            /// <remarks>
            /// <para>The gamma values must be in the range of [1, 10]. Set the transform direction</para>
            /// <para>to inverse to obtain the effect of values less than 1.</para>
            /// </remarks>
            public abstract void SetGamma(double[] values);

            public abstract void GetOffset(double[] values);

            /// <summary>Set the offset value for the power function for R, G, B, A.</summary>
            /// <remarks>The offset values must be in the range [0, 0.9].</remarks>
            public abstract void SetOffset(double[] values);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_LINEAR -- Linear segment continues into negatives (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// </remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyle
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~ExponentWithLinearTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const ExponentWithLinearTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // void getGamma(double(&values)[4]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetGammaDelegateInstance;

            private static void _GetGammaDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.GetGamma(values);
            }

            // void setGamma(const double(&values)[4]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetGammaDelegateInstance;

            private static void _SetGammaDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.SetGamma(values);
            }

            // void getOffset(double(&values)[4]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetOffsetDelegateInstance;

            private static void _GetOffsetDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.GetOffset(values);
            }

            // void setOffset(const double(&values)[4]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetOffsetDelegateInstance;

            private static void _SetOffsetDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.SetOffset(values);
            }

            // NegativeStyle getNegativeStyle() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr _GetNegativeStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle _GetNegativeStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                var ___ret = __target.NegativeStyle;
                return ___ret;
            }

            // void setNegativeStyle(NegativeStyle style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle _SetNegativeStyleDelegateInstance;

            private static void _SetNegativeStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform.__GetInstance(__instance);
                __target.NegativeStyle = style;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[13];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetGammaDelegateInstance += _GetGammaDelegateHook;
                    _SetGammaDelegateInstance += _SetGammaDelegateHook;
                    _GetOffsetDelegateInstance += _GetOffsetDelegateHook;
                    _SetOffsetDelegateInstance += _SetOffsetDelegateHook;
                    _GetNegativeStyleDelegateInstance += _GetNegativeStyleDelegateHook;
                    _SetNegativeStyleDelegateInstance += _SetNegativeStyleDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetGammaDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetGammaDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetOffsetDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetOffsetDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetNegativeStyleDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetNegativeStyleDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 15, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 15, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                VTables.Methods[0] = new Delegate[15];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Applies exposure, gamma, and pivoted contrast adjustments.</para>
        /// <para>Adjusts the math to be appropriate for linear, logarithmic, or video</para>
        /// <para>color spaces.</para>
        /// </summary>
        public unsafe abstract partial class ExposureContrastTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ExposureContrastTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new ExposureContrastTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ExposureContrastTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new ExposureContrastTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ExposureContrastTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ExposureContrastTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ExposureContrastTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ExposureContrastTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ExposureContrastTransformInternal(native, skipVTables);
            }

            protected ExposureContrastTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ExposureContrastTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform other);

            public abstract void MakeExposureDynamic();

            public abstract void MakeExposureNonDynamic();

            public abstract void MakeContrastDynamic();

            public abstract void MakeContrastNonDynamic();

            public abstract void MakeGammaDynamic();

            public abstract void MakeGammaNonDynamic();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle Style
            {
                get;

                set;
            }

            public abstract double Exposure
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Exposure can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic exposure.</para>
            /// </summary>
            public abstract bool IsExposureDynamic
            {
                get;
            }

            public abstract double Contrast
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Contrast can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic contrast.</para>
            /// </summary>
            public abstract bool IsContrastDynamic
            {
                get;
            }

            public abstract double Gamma
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Gamma can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic gamma.</para>
            /// </summary>
            public abstract bool IsGammaDynamic
            {
                get;
            }

            public abstract double Pivot
            {
                get;

                set;
            }

            public abstract double LogExposureStep
            {
                get;

                set;
            }

            public abstract double LogMidGray
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~ExposureContrastTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const ExposureContrastTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // ExposureContrastStyle getStyle() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(ExposureContrastStyle style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // double getExposure() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetExposureDelegateInstance;

            private static double _GetExposureDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Exposure;
                return ___ret;
            }

            // void setExposure(double exposure) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetExposureDelegateInstance;

            private static void _SetExposureDelegateHook(__IntPtr __instance, double exposure)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Exposure = exposure;
            }

            // bool isExposureDynamic() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsExposureDynamicDelegateInstance;

            private static bool _IsExposureDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.IsExposureDynamic;
                return ___ret;
            }

            // void makeExposureDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeExposureDynamicDelegateInstance;

            private static void _MakeExposureDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeExposureDynamic();
            }

            // void makeExposureNonDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeExposureNonDynamicDelegateInstance;

            private static void _MakeExposureNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeExposureNonDynamic();
            }

            // double getContrast() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetContrastDelegateInstance;

            private static double _GetContrastDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Contrast;
                return ___ret;
            }

            // void setContrast(double contrast) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetContrastDelegateInstance;

            private static void _SetContrastDelegateHook(__IntPtr __instance, double contrast)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Contrast = contrast;
            }

            // bool isContrastDynamic() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsContrastDynamicDelegateInstance;

            private static bool _IsContrastDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.IsContrastDynamic;
                return ___ret;
            }

            // void makeContrastDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeContrastDynamicDelegateInstance;

            private static void _MakeContrastDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeContrastDynamic();
            }

            // void makeContrastNonDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeContrastNonDynamicDelegateInstance;

            private static void _MakeContrastNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeContrastNonDynamic();
            }

            // double getGamma() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetGammaDelegateInstance;

            private static double _GetGammaDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Gamma;
                return ___ret;
            }

            // void setGamma(double gamma) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetGammaDelegateInstance;

            private static void _SetGammaDelegateHook(__IntPtr __instance, double gamma)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Gamma = gamma;
            }

            // bool isGammaDynamic() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsGammaDynamicDelegateInstance;

            private static bool _IsGammaDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.IsGammaDynamic;
                return ___ret;
            }

            // void makeGammaDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeGammaDynamicDelegateInstance;

            private static void _MakeGammaDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeGammaDynamic();
            }

            // void makeGammaNonDynamic() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeGammaNonDynamicDelegateInstance;

            private static void _MakeGammaNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.MakeGammaNonDynamic();
            }

            // double getPivot() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetPivotDelegateInstance;

            private static double _GetPivotDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.Pivot;
                return ___ret;
            }

            // void setPivot(double pivot) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetPivotDelegateInstance;

            private static void _SetPivotDelegateHook(__IntPtr __instance, double pivot)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.Pivot = pivot;
            }

            // double getLogExposureStep() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetLogExposureStepDelegateInstance;

            private static double _GetLogExposureStepDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.LogExposureStep;
                return ___ret;
            }

            // void setLogExposureStep(double logExposureStep) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetLogExposureStepDelegateInstance;

            private static void _SetLogExposureStepDelegateHook(__IntPtr __instance, double logExposureStep)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.LogExposureStep = logExposureStep;
            }

            // double getLogMidGray() const = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetLogMidGrayDelegateInstance;

            private static double _GetLogMidGrayDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                var ___ret = __target.LogMidGray;
                return ___ret;
            }

            // void setLogMidGray(double logMidGray) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetLogMidGrayDelegateInstance;

            private static void _SetLogMidGrayDelegateHook(__IntPtr __instance, double logMidGray)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform.__GetInstance(__instance);
                __target.LogMidGray = logMidGray;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[30];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetExposureDelegateInstance += _GetExposureDelegateHook;
                    _SetExposureDelegateInstance += _SetExposureDelegateHook;
                    _IsExposureDynamicDelegateInstance += _IsExposureDynamicDelegateHook;
                    _MakeExposureDynamicDelegateInstance += _MakeExposureDynamicDelegateHook;
                    _MakeExposureNonDynamicDelegateInstance += _MakeExposureNonDynamicDelegateHook;
                    _GetContrastDelegateInstance += _GetContrastDelegateHook;
                    _SetContrastDelegateInstance += _SetContrastDelegateHook;
                    _IsContrastDynamicDelegateInstance += _IsContrastDynamicDelegateHook;
                    _MakeContrastDynamicDelegateInstance += _MakeContrastDynamicDelegateHook;
                    _MakeContrastNonDynamicDelegateInstance += _MakeContrastNonDynamicDelegateHook;
                    _GetGammaDelegateInstance += _GetGammaDelegateHook;
                    _SetGammaDelegateInstance += _SetGammaDelegateHook;
                    _IsGammaDynamicDelegateInstance += _IsGammaDynamicDelegateHook;
                    _MakeGammaDynamicDelegateInstance += _MakeGammaDynamicDelegateHook;
                    _MakeGammaNonDynamicDelegateInstance += _MakeGammaNonDynamicDelegateHook;
                    _GetPivotDelegateInstance += _GetPivotDelegateHook;
                    _SetPivotDelegateInstance += _SetPivotDelegateHook;
                    _GetLogExposureStepDelegateInstance += _GetLogExposureStepDelegateHook;
                    _SetLogExposureStepDelegateInstance += _SetLogExposureStepDelegateHook;
                    _GetLogMidGrayDelegateInstance += _GetLogMidGrayDelegateHook;
                    _SetLogMidGrayDelegateInstance += _SetLogMidGrayDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetExposureDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetExposureDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsExposureDynamicDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_MakeExposureDynamicDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_MakeExposureNonDynamicDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetContrastDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SetContrastDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_IsContrastDynamicDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_MakeContrastDynamicDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_MakeContrastNonDynamicDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetGammaDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_SetGammaDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_IsGammaDynamicDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_MakeGammaDynamicDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_MakeGammaNonDynamicDelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_GetPivotDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_SetPivotDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetLogExposureStepDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_SetLogExposureStepDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetLogMidGrayDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_SetLogMidGrayDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                ManagedVTables[0][23] = Thunks[21];
                                ManagedVTables[0][24] = Thunks[22];
                                ManagedVTables[0][25] = Thunks[23];
                                ManagedVTables[0][26] = Thunks[24];
                                ManagedVTables[0][27] = Thunks[25];
                                ManagedVTables[0][28] = Thunks[26];
                                ManagedVTables[0][29] = Thunks[27];
                                ManagedVTables[0][30] = Thunks[28];
                                ManagedVTables[0][31] = Thunks[29];
                                VTables.Methods[0] = new Delegate[32];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class FileTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetFormatNameByIndex@FileTransform@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatNameByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetFormatExtensionByIndex@FileTransform@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatExtensionByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?IsFormatExtensionSupported@FileTransform@OpenColorIO_v2_4@@SA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFormatExtensionSupported([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string extension);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSrc@FileTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSrc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSrc@FileTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSrc(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCCCId@FileTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCCCId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setCCCId@FileTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCCCId(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getCDLStyle@FileTransform@OpenColorIO_v2_4@@QEBA?AW4CDLStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.CDLStyle GetCDLStyle(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setCDLStyle@FileTransform@OpenColorIO_v2_4@@QEAAXW4CDLStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCDLStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.CDLStyle _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getInterpolation@FileTransform@OpenColorIO_v2_4@@QEBA?AW4Interpolation@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenColorIO.OpenColorIO_v2_4.Interpolation GetInterpolation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setInterpolation@FileTransform@OpenColorIO_v2_4@@QEAAXW4Interpolation@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInterpolation(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Interpolation interp);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetNumFormats@FileTransform@OpenColorIO_v2_4@@SAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumFormats();
            }

            internal static new FileTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new FileTransform(native.ToPointer(), skipVTables);
            }

            internal static new FileTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (FileTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new FileTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (FileTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static FileTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FileTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FileTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected FileTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 5);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Will throw if data is not valid.</summary>
            public override void Validate()
            {
                base.Validate();
            }

            /// <summary>Get the LUT readers at index, return empty string if an invalid index is specified.</summary>
            public static string GetFormatNameByIndex(int index)
            {
                var ___ret = __Internal.GetFormatNameByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the LUT reader extension at index, return empty string if an invalid index is specified.</summary>
            public static string GetFormatExtensionByIndex(int index)
            {
                var ___ret = __Internal.GetFormatExtensionByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Returns true if the extension corresponds to a format supported by FileTransform.</para>
            /// <para>The argument is case-insensitive, and a leading dot, if present, is ignored.</para>
            /// <para>Note that FileTransform will attempt all format readers on a given file until it is</para>
            /// <para>successful, even files that contain an unsupported extension or no extension.</para>
            /// <para>However, this function is useful for applications that want to know which files are likely</para>
            /// <para>to be LUT files, based on their extension.</para>
            /// </summary>
            public static bool IsFormatExtensionSupported(string extension)
            {
                var ___ret = __Internal.IsFormatExtensionSupported(extension);
                return ___ret;
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public string Src
            {
                get
                {
                    var ___ret = __Internal.GetSrc(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSrc(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The cccid can be the ID of a CDL or the index of the CDL (as string). If cccid is NULL or</para>
            /// <para>empty the first CDL is returned.  The cccid is case-sensitive.</para>
            /// </summary>
            public string CCCId
            {
                get
                {
                    var ___ret = __Internal.GetCCCId(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetCCCId(__Instance, value);
                }
            }

            public global::OpenColorIO.OpenColorIO_v2_4.CDLStyle CDLStyle
            {
                get
                {
                    var ___ret = __Internal.GetCDLStyle(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCDLStyle(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The file parsers that care about interpolation (LUTs) will try to make use of the requested</para>
            /// <para>interpolation method when loading the file.  In these cases, if the requested method could</para>
            /// <para>not be used, a warning is logged.  If no method is provided, or a method cannot be used,</para>
            /// <para>INTERP_DEFAULT is used.</para>
            /// </summary>
            public global::OpenColorIO.OpenColorIO_v2_4.Interpolation Interpolation
            {
                get
                {
                    var ___ret = __Internal.GetInterpolation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetInterpolation(__Instance, value);
                }
            }

            /// <summary>Get the number of LUT readers.</summary>
            public static int NumFormats
            {
                get
                {
                    var ___ret = __Internal.GetNumFormats();
                    return ___ret;
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept override
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const override
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~FileTransform()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FileTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Provides a set of hard-coded algorithmic building blocks</para>
        /// <para>that are needed to accurately implement various common color transformations.</para>
        /// </summary>
        public unsafe abstract partial class FixedFunctionTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0FixedFunctionTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new FixedFunctionTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new FixedFunctionTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new FixedFunctionTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (FixedFunctionTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new FixedFunctionTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (FixedFunctionTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static FixedFunctionTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FixedFunctionTransformInternal(native, skipVTables);
            }

            protected FixedFunctionTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected FixedFunctionTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform other);

            public abstract void GetParams(ref double @params);

            /// <summary>Set the parameters (for functions that require them).</summary>
            public abstract void SetParams(ref double @params, ulong num);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle Style
            {
                get;

                set;
            }

            public abstract ulong NumParams
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~FixedFunctionTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const FixedFunctionTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // FixedFunctionStyle getStyle() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(FixedFunctionStyle style) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // size_t getNumParams() const = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumParamsDelegateInstance;

            private static ulong _GetNumParamsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                var ___ret = __target.NumParams;
                return ___ret;
            }

            // void getParams(double * params) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetParamsDelegateInstance;

            private static void _GetParamsDelegateHook(__IntPtr __instance, double* @params)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.GetParams(ref *@params);
            }

            // void setParams(const double * params, size_t num) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr_ulong _SetParamsDelegateInstance;

            private static void _SetParamsDelegateHook(__IntPtr __instance, double* @params, ulong num)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform.__GetInstance(__instance);
                __target.SetParams(ref *@params, num);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetNumParamsDelegateInstance += _GetNumParamsDelegateHook;
                    _GetParamsDelegateInstance += _GetParamsDelegateHook;
                    _SetParamsDelegateInstance += _SetParamsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetNumParamsDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetParamsDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SetParamsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 14, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 14, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                VTables.Methods[0] = new Delegate[14];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Primary color correction controls.</summary>
        /// <remarks>
        /// <para>This transform is for making basic color correction adjustments to an image such as brightness,</para>
        /// <para>contrast, or saturation.</para>
        /// <para>The controls are customized for linear, logarithmic, and video color encodings.</para>
        /// <para>* Linear controls: Exposure, Contrast, Pivot, Offset, Saturation, Black Clip, White Clip.</para>
        /// <para>* Log controls: Brightness, Contrast, Pivot, Log Gamma, Saturation, Black Clip, White Clip,</para>
        /// <para>Black Pivot White Pivot.</para>
        /// <para>* Video controls : Lift, Gamma, Gain, Offset, Saturation, Black Clip, White Clip,</para>
        /// <para>Black Pivot White Pivot.</para>
        /// <para>The controls are dynamic, so they may be adjusted even after the Transform has been included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public unsafe abstract partial class GradingPrimaryTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingPrimaryTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new GradingPrimaryTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingPrimaryTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new GradingPrimaryTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingPrimaryTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GradingPrimaryTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GradingPrimaryTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GradingPrimaryTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingPrimaryTransformInternal(native, skipVTables);
            }

            protected GradingPrimaryTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GradingPrimaryTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform other);

            public abstract void MakeDynamic();

            public abstract void MakeNonDynamic();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary Value
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingPrimaryTransform only one can have dynamic parameters.</para>
            /// </summary>
            public abstract bool IsDynamic
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~GradingPrimaryTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const GradingPrimaryTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // GradingStyle getStyle() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.GradingStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(GradingStyle style) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // GradingPrimary & getValue() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetValueDelegateInstance;

            private static __IntPtr _GetValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.Value;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setValue(const GradingPrimary & values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, __IntPtr values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__GetOrCreateInstance(values, false);
                __target.Value = __result0;
            }

            // bool isDynamic() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsDynamicDelegateInstance;

            private static bool _IsDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                var ___ret = __target.IsDynamic;
                return ___ret;
            }

            // void makeDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeDynamicDelegateInstance;

            private static void _MakeDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.MakeDynamic();
            }

            // void makeNonDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeNonDynamicDelegateInstance;

            private static void _MakeNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform.__GetInstance(__instance);
                __target.MakeNonDynamic();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[14];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _IsDynamicDelegateInstance += _IsDynamicDelegateHook;
                    _MakeDynamicDelegateInstance += _MakeDynamicDelegateHook;
                    _MakeNonDynamicDelegateInstance += _MakeNonDynamicDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsDynamicDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_MakeDynamicDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_MakeNonDynamicDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                VTables.Methods[0] = new Delegate[16];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>RGB curve color correction controls.</summary>
        /// <remarks>
        /// <para>This transform allows for modifying tone reproduction via B-spline curves.</para>
        /// <para>There is an R, G, and B curve along with a Master curve (that applies to R, G, and B).  Each</para>
        /// <para>curve is specified via the x and y coordinates of its control points.  A monotonic spline is</para>
        /// <para>fit to the control points.  The x coordinates must be non-decreasing. When the grading style</para>
        /// <para>is linear, the units for the control points are photographic stops relative to 0.18.</para>
        /// <para>The control points are dynamic, so they may be adjusted even after the Transform is included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public unsafe abstract partial class GradingRGBCurveTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingRGBCurveTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new GradingRGBCurveTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingRGBCurveTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new GradingRGBCurveTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingRGBCurveTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GradingRGBCurveTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GradingRGBCurveTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GradingRGBCurveTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingRGBCurveTransformInternal(native, skipVTables);
            }

            protected GradingRGBCurveTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GradingRGBCurveTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform other);

            /// <summary>
            /// <para>It is possible to provide a desired slope value for each control point.  The number of slopes is</para>
            /// <para>always the same as the number of control points and so the control points must be set before</para>
            /// <para>setting the slopes.  The slopes are primarily intended for use by config authors looking to match</para>
            /// <para>a specific shape with as few control points as possible, they are not intended to be exposed to</para>
            /// <para>a user interface for direct manipulation.  When a curve is being generated for creative purposes</para>
            /// <para>it is better to let OCIO calculate the slopes automatically.</para>
            /// </summary>
            public abstract float GetSlope(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index);

            public abstract void SetSlope(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index, float slope);

            public abstract bool SlopesAreDefault(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c);

            public abstract void MakeDynamic();

            public abstract void MakeNonDynamic();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get;

                set;
            }

            /// <summary>
            /// <para>The scene-linear grading style applies a lin-to-log transform to the pixel</para>
            /// <para>values before going through the curve.  However, in some cases (e.g. drawing curves in a UI)</para>
            /// <para>it may be useful to bypass the lin-to-log. Default value is false.</para>
            /// </summary>
            public abstract bool BypassLinToLog
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingRGBCurveTransform only one can have dynamic parameters.</para>
            /// </summary>
            public abstract bool IsDynamic
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~GradingRGBCurveTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const GradingRGBCurveTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // GradingStyle getStyle() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.GradingStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(GradingStyle style) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // float getSlope(RGBCurveType c, size_t index) const = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong _GetSlopeDelegateInstance;

            private static float _GetSlopeDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.GetSlope(c, index);
                return ___ret;
            }

            // void setSlope(RGBCurveType c, size_t index, float slope) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong_float _SetSlopeDelegateInstance;

            private static void _SetSlopeDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index, float slope)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.SetSlope(c, index, slope);
            }

            // bool slopesAreDefault(RGBCurveType c) const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType _SlopesAreDefaultDelegateInstance;

            private static bool _SlopesAreDefaultDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.SlopesAreDefault(c);
                return ___ret;
            }

            // bool getBypassLinToLog() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetBypassLinToLogDelegateInstance;

            private static bool _GetBypassLinToLogDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.BypassLinToLog;
                return ___ret;
            }

            // void setBypassLinToLog(bool bypass) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetBypassLinToLogDelegateInstance;

            private static void _SetBypassLinToLogDelegateHook(__IntPtr __instance, bool bypass)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.BypassLinToLog = bypass;
            }

            // bool isDynamic() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsDynamicDelegateInstance;

            private static bool _IsDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                var ___ret = __target.IsDynamic;
                return ___ret;
            }

            // void makeDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeDynamicDelegateInstance;

            private static void _MakeDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.MakeDynamic();
            }

            // void makeNonDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeNonDynamicDelegateInstance;

            private static void _MakeNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform.__GetInstance(__instance);
                __target.MakeNonDynamic();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[17];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetSlopeDelegateInstance += _GetSlopeDelegateHook;
                    _SetSlopeDelegateInstance += _SetSlopeDelegateHook;
                    _SlopesAreDefaultDelegateInstance += _SlopesAreDefaultDelegateHook;
                    _GetBypassLinToLogDelegateInstance += _GetBypassLinToLogDelegateHook;
                    _SetBypassLinToLogDelegateInstance += _SetBypassLinToLogDelegateHook;
                    _IsDynamicDelegateInstance += _IsDynamicDelegateHook;
                    _MakeDynamicDelegateInstance += _MakeDynamicDelegateHook;
                    _MakeNonDynamicDelegateInstance += _MakeNonDynamicDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetSlopeDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetSlopeDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SlopesAreDefaultDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_GetBypassLinToLogDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_SetBypassLinToLogDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_IsDynamicDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_MakeDynamicDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_MakeNonDynamicDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][13] = Thunks[9];
                                ManagedVTables[0][14] = Thunks[10];
                                ManagedVTables[0][15] = Thunks[11];
                                ManagedVTables[0][16] = Thunks[12];
                                ManagedVTables[0][17] = Thunks[13];
                                ManagedVTables[0][18] = Thunks[14];
                                ManagedVTables[0][19] = Thunks[15];
                                ManagedVTables[0][20] = Thunks[16];
                                VTables.Methods[0] = new Delegate[21];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Tonal color correction controls.</summary>
        /// <remarks>
        /// <para>This transform is for making fine adjustments to tone reproduction in specific tonal ranges.</para>
        /// <para>There are five tonal controls and each one has two parameters to control its range:</para>
        /// <para>* Blacks (start, width)</para>
        /// <para>* Shadows(start, pivot)</para>
        /// <para>* Midtones(center, width)</para>
        /// <para>* Highlights(start, pivot)</para>
        /// <para>* Whites(start, width)</para>
        /// <para>The transform has three styles that adjust the response and default ranges for linear,</para>
        /// <para>logarithimic, and video color encodings. The defaults vary based on the style.  When the</para>
        /// <para>style is linear, the units for start/width/etc. are photographic stops relative to 0.18.</para>
        /// <para>Each control allows R, G, B adjustments and a Master adjustment.</para>
        /// <para>There is also an S-contrast control for imparting an S-shape curve.</para>
        /// <para>The controls are dynamic, so they may be adjusted even after the Transform has been included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public unsafe abstract partial class GradingToneTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GradingToneTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new GradingToneTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GradingToneTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new GradingToneTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GradingToneTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GradingToneTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GradingToneTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GradingToneTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GradingToneTransformInternal(native, skipVTables);
            }

            protected GradingToneTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GradingToneTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GradingToneTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform other);

            public abstract void MakeDynamic();

            public abstract void MakeNonDynamic();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.GradingTone Value
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingToneTransform only one can have dynamic parameters.</para>
            /// </summary>
            public abstract bool IsDynamic
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~GradingToneTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const GradingToneTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // GradingStyle getStyle() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.GradingStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(GradingStyle style) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // GradingTone & getValue() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetValueDelegateInstance;

            private static __IntPtr _GetValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.Value;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void setValue(const GradingTone & values) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr___IntPtr _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, __IntPtr values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__GetOrCreateInstance(values, false);
                __target.Value = __result0;
            }

            // bool isDynamic() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsDynamicDelegateInstance;

            private static bool _IsDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                var ___ret = __target.IsDynamic;
                return ___ret;
            }

            // void makeDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeDynamicDelegateInstance;

            private static void _MakeDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.MakeDynamic();
            }

            // void makeNonDynamic() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _MakeNonDynamicDelegateInstance;

            private static void _MakeNonDynamicDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform.__GetInstance(__instance);
                __target.MakeNonDynamic();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[14];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _IsDynamicDelegateInstance += _IsDynamicDelegateHook;
                    _MakeDynamicDelegateInstance += _MakeDynamicDelegateHook;
                    _MakeNonDynamicDelegateInstance += _MakeNonDynamicDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_IsDynamicDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_MakeDynamicDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_MakeNonDynamicDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                VTables.Methods[0] = new Delegate[16];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe abstract partial class GroupTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0GroupTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetFormatNameByIndex@GroupTransform@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatNameByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetFormatExtensionByIndex@GroupTransform@OpenColorIO_v2_4@@SAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFormatExtensionByIndex(int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?GetNumWriteFormats@GroupTransform@OpenColorIO_v2_4@@SAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetNumWriteFormats();
            }

            internal static new GroupTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GroupTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new GroupTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GroupTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GroupTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GroupTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GroupTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GroupTransformInternal(native, skipVTables);
            }

            protected GroupTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected GroupTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.GroupTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the writer at index, return empty string if an invalid index is specified.</summary>
            public static string GetFormatNameByIndex(int index)
            {
                var ___ret = __Internal.GetFormatNameByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public static string GetFormatExtensionByIndex(int index)
            {
                var ___ret = __Internal.GetFormatExtensionByIndex(index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>Return number of transforms.</summary>
            public abstract int NumTransforms
            {
                get;
            }

            /// <summary>Get the number of writers.</summary>
            public static int NumWriteFormats
            {
                get
                {
                    var ___ret = __Internal.GetNumWriteFormats();
                    return ___ret;
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~GroupTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // int getNumTransforms() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_int___IntPtr _GetNumTransformsDelegateInstance;

            private static int _GetNumTransformsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.GroupTransform.__GetInstance(__instance);
                var ___ret = __target.NumTransforms;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _GetNumTransformsDelegateInstance += _GetNumTransformsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetNumTransformsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 14, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 14, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][10] = Thunks[6];
                                VTables.Methods[0] = new Delegate[14];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Applies a logarithm with an affine transform before and after.</para>
        /// <para>Represents the Cineon lin-to-log type transforms::</para>
        /// </summary>
        /// <remarks>
        /// <para>logSideSlope * log( linSideSlope * color + linSideOffset, base) + logSideOffset</para>
        /// <para>* Default values are: 1. * log( 1. * color + 0., 2.) + 0.</para>
        /// <para>* The alpha channel is not affected.</para>
        /// </remarks>
        public unsafe abstract partial class LogAffineTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0LogAffineTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new LogAffineTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LogAffineTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new LogAffineTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LogAffineTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LogAffineTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LogAffineTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LogAffineTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LogAffineTransformInternal(native, skipVTables);
            }

            protected LogAffineTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected LogAffineTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.LogAffineTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform other);

            public abstract void GetLogSideSlopeValue(double[] values);

            public abstract void SetLogSideSlopeValue(double[] values);

            public abstract void GetLogSideOffsetValue(double[] values);

            public abstract void SetLogSideOffsetValue(double[] values);

            public abstract void GetLinSideSlopeValue(double[] values);

            public abstract void SetLinSideSlopeValue(double[] values);

            public abstract void GetLinSideOffsetValue(double[] values);

            public abstract void SetLinSideOffsetValue(double[] values);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract double Base
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~LogAffineTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const LogAffineTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // double getBase() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetBaseDelegateInstance;

            private static double _GetBaseDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                var ___ret = __target.Base;
                return ___ret;
            }

            // void setBase(double base) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetBaseDelegateInstance;

            private static void _SetBaseDelegateHook(__IntPtr __instance, double @base)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.Base = @base;
            }

            // void getLogSideSlopeValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLogSideSlopeValueDelegateInstance;

            private static void _GetLogSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.GetLogSideSlopeValue(values);
            }

            // void setLogSideSlopeValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLogSideSlopeValueDelegateInstance;

            private static void _SetLogSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.SetLogSideSlopeValue(values);
            }

            // void getLogSideOffsetValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLogSideOffsetValueDelegateInstance;

            private static void _GetLogSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.GetLogSideOffsetValue(values);
            }

            // void setLogSideOffsetValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLogSideOffsetValueDelegateInstance;

            private static void _SetLogSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.SetLogSideOffsetValue(values);
            }

            // void getLinSideSlopeValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLinSideSlopeValueDelegateInstance;

            private static void _GetLinSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.GetLinSideSlopeValue(values);
            }

            // void setLinSideSlopeValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinSideSlopeValueDelegateInstance;

            private static void _SetLinSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.SetLinSideSlopeValue(values);
            }

            // void getLinSideOffsetValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLinSideOffsetValueDelegateInstance;

            private static void _GetLinSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.GetLinSideOffsetValue(values);
            }

            // void setLinSideOffsetValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinSideOffsetValueDelegateInstance;

            private static void _SetLinSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform.__GetInstance(__instance);
                __target.SetLinSideOffsetValue(values);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[17];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetBaseDelegateInstance += _GetBaseDelegateHook;
                    _SetBaseDelegateInstance += _SetBaseDelegateHook;
                    _GetLogSideSlopeValueDelegateInstance += _GetLogSideSlopeValueDelegateHook;
                    _SetLogSideSlopeValueDelegateInstance += _SetLogSideSlopeValueDelegateHook;
                    _GetLogSideOffsetValueDelegateInstance += _GetLogSideOffsetValueDelegateHook;
                    _SetLogSideOffsetValueDelegateInstance += _SetLogSideOffsetValueDelegateHook;
                    _GetLinSideSlopeValueDelegateInstance += _GetLinSideSlopeValueDelegateHook;
                    _SetLinSideSlopeValueDelegateInstance += _SetLinSideSlopeValueDelegateHook;
                    _GetLinSideOffsetValueDelegateInstance += _GetLinSideOffsetValueDelegateHook;
                    _SetLinSideOffsetValueDelegateInstance += _SetLinSideOffsetValueDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetBaseDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetBaseDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetLogSideSlopeValueDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetLogSideSlopeValueDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetLogSideOffsetValueDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetLogSideOffsetValueDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetLinSideSlopeValueDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetLinSideSlopeValueDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetLinSideOffsetValueDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SetLinSideOffsetValueDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                VTables.Methods[0] = new Delegate[19];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Same as LogAffineTransform but with the addition of a linear segment near black. This formula</para>
        /// <para>is used for many camera logs (e.g., LogC) as well as ACEScct.</para>
        /// </summary>
        /// <remarks>
        /// <para>* The linSideBreak specifies the point on the linear axis where the log and linear</para>
        /// <para>segments meet.  It must be set (there is no default).</para>
        /// <para>* The linearSlope specifies the slope of the linear segment of the forward (linToLog)</para>
        /// <para>transform.  By default it is set equal to the slope of the log curve at the break point.</para>
        /// </remarks>
        public unsafe abstract partial class LogCameraTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0LogCameraTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new LogCameraTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LogCameraTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new LogCameraTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LogCameraTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LogCameraTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LogCameraTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LogCameraTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LogCameraTransformInternal(native, skipVTables);
            }

            protected LogCameraTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected LogCameraTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.LogCameraTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform other);

            /// <summary>Get/Set values for the R, G, B components.</summary>
            public abstract void GetLogSideSlopeValue(double[] values);

            public abstract void SetLogSideSlopeValue(double[] values);

            public abstract void GetLogSideOffsetValue(double[] values);

            public abstract void SetLogSideOffsetValue(double[] values);

            public abstract void GetLinSideSlopeValue(double[] values);

            public abstract void SetLinSideSlopeValue(double[] values);

            public abstract void GetLinSideOffsetValue(double[] values);

            public abstract void SetLinSideOffsetValue(double[] values);

            public abstract void GetLinSideBreakValue(double[] values);

            public abstract void SetLinSideBreakValue(double[] values);

            /// <summary>Return true if LinearSlope values were set, false if they were not.</summary>
            public abstract bool GetLinearSlopeValue(double[] values);

            /// <summary>Set LinearSlope value.</summary>
            /// <remarks>You must call setLinSideBreakValue before calling this.</remarks>
            public abstract void SetLinearSlopeValue(double[] values);

            /// <summary>Remove LinearSlope values so that default values are used.</summary>
            public abstract void UnsetLinearSlopeValue();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract double Base
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~LogCameraTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const LogCameraTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // double getBase() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetBaseDelegateInstance;

            private static double _GetBaseDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var ___ret = __target.Base;
                return ___ret;
            }

            // void setBase(double base) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetBaseDelegateInstance;

            private static void _SetBaseDelegateHook(__IntPtr __instance, double @base)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.Base = @base;
            }

            // void getLogSideSlopeValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLogSideSlopeValueDelegateInstance;

            private static void _GetLogSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.GetLogSideSlopeValue(values);
            }

            // void setLogSideSlopeValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLogSideSlopeValueDelegateInstance;

            private static void _SetLogSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLogSideSlopeValue(values);
            }

            // void getLogSideOffsetValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLogSideOffsetValueDelegateInstance;

            private static void _GetLogSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.GetLogSideOffsetValue(values);
            }

            // void setLogSideOffsetValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLogSideOffsetValueDelegateInstance;

            private static void _SetLogSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLogSideOffsetValue(values);
            }

            // void getLinSideSlopeValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLinSideSlopeValueDelegateInstance;

            private static void _GetLinSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.GetLinSideSlopeValue(values);
            }

            // void setLinSideSlopeValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinSideSlopeValueDelegateInstance;

            private static void _SetLinSideSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLinSideSlopeValue(values);
            }

            // void getLinSideOffsetValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLinSideOffsetValueDelegateInstance;

            private static void _GetLinSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.GetLinSideOffsetValue(values);
            }

            // void setLinSideOffsetValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinSideOffsetValueDelegateInstance;

            private static void _SetLinSideOffsetValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLinSideOffsetValue(values);
            }

            // void getLinSideBreakValue(double(&values)[3]) const noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _GetLinSideBreakValueDelegateInstance;

            private static void _GetLinSideBreakValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.GetLinSideBreakValue(values);
            }

            // void setLinSideBreakValue(const double(&values)[3]) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinSideBreakValueDelegateInstance;

            private static void _SetLinSideBreakValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLinSideBreakValue(values);
            }

            // bool getLinearSlopeValue(double(&values)[3]) const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr_doubleArray _GetLinearSlopeValueDelegateInstance;

            private static bool _GetLinearSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                var ___ret = __target.GetLinearSlopeValue(values);
                return ___ret;
            }

            // void setLinearSlopeValue(const double(&values)[3]) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doubleArray _SetLinearSlopeValueDelegateInstance;

            private static void _SetLinearSlopeValueDelegateHook(__IntPtr __instance, double[] values)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.SetLinearSlopeValue(values);
            }

            // void unsetLinearSlopeValue() = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _UnsetLinearSlopeValueDelegateInstance;

            private static void _UnsetLinearSlopeValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform.__GetInstance(__instance);
                __target.UnsetLinearSlopeValue();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[22];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetBaseDelegateInstance += _GetBaseDelegateHook;
                    _SetBaseDelegateInstance += _SetBaseDelegateHook;
                    _GetLogSideSlopeValueDelegateInstance += _GetLogSideSlopeValueDelegateHook;
                    _SetLogSideSlopeValueDelegateInstance += _SetLogSideSlopeValueDelegateHook;
                    _GetLogSideOffsetValueDelegateInstance += _GetLogSideOffsetValueDelegateHook;
                    _SetLogSideOffsetValueDelegateInstance += _SetLogSideOffsetValueDelegateHook;
                    _GetLinSideSlopeValueDelegateInstance += _GetLinSideSlopeValueDelegateHook;
                    _SetLinSideSlopeValueDelegateInstance += _SetLinSideSlopeValueDelegateHook;
                    _GetLinSideOffsetValueDelegateInstance += _GetLinSideOffsetValueDelegateHook;
                    _SetLinSideOffsetValueDelegateInstance += _SetLinSideOffsetValueDelegateHook;
                    _GetLinSideBreakValueDelegateInstance += _GetLinSideBreakValueDelegateHook;
                    _SetLinSideBreakValueDelegateInstance += _SetLinSideBreakValueDelegateHook;
                    _GetLinearSlopeValueDelegateInstance += _GetLinearSlopeValueDelegateHook;
                    _SetLinearSlopeValueDelegateInstance += _SetLinearSlopeValueDelegateHook;
                    _UnsetLinearSlopeValueDelegateInstance += _UnsetLinearSlopeValueDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetBaseDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetBaseDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetLogSideSlopeValueDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetLogSideSlopeValueDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetLogSideOffsetValueDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetLogSideOffsetValueDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetLinSideSlopeValueDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetLinSideSlopeValueDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetLinSideOffsetValueDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SetLinSideOffsetValueDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetLinSideBreakValueDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_SetLinSideBreakValueDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetLinearSlopeValueDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_SetLinearSlopeValueDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_UnsetLinearSlopeValueDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 24, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 24, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                ManagedVTables[0][23] = Thunks[21];
                                VTables.Methods[0] = new Delegate[24];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents log transform: log(color, base)</summary>
        /// <remarks>
        /// <para>* The input will be clamped for negative numbers.</para>
        /// <para>* Default base is 2.0.</para>
        /// <para>* The alpha channel is not affected.</para>
        /// </remarks>
        public unsafe abstract partial class LogTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0LogTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new LogTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LogTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new LogTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LogTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LogTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LogTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LogTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LogTransformInternal(native, skipVTables);
            }

            protected LogTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected LogTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.LogTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogTransform other);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract double Base
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~LogTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const LogTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // double getBase() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetBaseDelegateInstance;

            private static double _GetBaseDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                var ___ret = __target.Base;
                return ___ret;
            }

            // void setBase(double val) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetBaseDelegateInstance;

            private static void _SetBaseDelegateHook(__IntPtr __instance, double val)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LogTransform.__GetInstance(__instance);
                __target.Base = val;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[9];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetBaseDelegateInstance += _GetBaseDelegateHook;
                    _SetBaseDelegateInstance += _SetBaseDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetBaseDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetBaseDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 11, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 11, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                VTables.Methods[0] = new Delegate[11];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class LookTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;
                internal __IntPtr m_impl;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSrc@LookTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSrc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSrc@LookTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSrc(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getDst@LookTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDst(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setDst@LookTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDst(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getLooks@LookTransform@OpenColorIO_v2_4@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLooks(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setLooks@LookTransform@OpenColorIO_v2_4@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetLooks(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?getSkipColorSpaceConversion@LookTransform@OpenColorIO_v2_4@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetSkipColorSpaceConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?setSkipColorSpaceConversion@LookTransform@OpenColorIO_v2_4@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSkipColorSpaceConversion(__IntPtr __instance, bool skip);
            }

            internal static new LookTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LookTransform(native.ToPointer(), skipVTables);
            }

            internal static new LookTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LookTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LookTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LookTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LookTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LookTransform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private LookTransform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected LookTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_int>(0, 5);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Will throw if data is not valid.</summary>
            public override void Validate()
            {
                base.Validate();
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public string Src
            {
                get
                {
                    var ___ret = __Internal.GetSrc(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetSrc(__Instance, value);
                }
            }

            public string Dst
            {
                get
                {
                    var ___ret = __Internal.GetDst(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetDst(__Instance, value);
                }
            }

            public string Looks
            {
                get
                {
                    var ___ret = __Internal.GetLooks(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    __Internal.SetLooks(__Instance, value);
                }
            }

            public bool SkipColorSpaceConversion
            {
                get
                {
                    var ___ret = __Internal.GetSkipColorSpaceConversion(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSkipColorSpaceConversion(__Instance, value);
                }
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LookTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept override
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LookTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LookTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const override
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LookTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~LookTransform()
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LookTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents a 1D-LUT transform.</summary>
        public unsafe abstract partial class Lut1DTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0Lut1DTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new Lut1DTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Lut1DTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new Lut1DTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Lut1DTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Lut1DTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Lut1DTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Lut1DTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Lut1DTransformInternal(native, skipVTables);
            }

            protected Lut1DTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Lut1DTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.Lut1DTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform other);

            public abstract void GetValue(uint index, ref float r, ref float g, ref float b);

            /// <summary>
            /// <para>Set the values of a LUT1D.  Will throw if the index</para>
            /// <para>is outside of the range from 0 to (length-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how</para>
            /// <para>the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The</para>
            /// <para>values here are unclamped and may extend outside [0,1].</para>
            /// <para>LUTs in various file formats may only provide values for one</para>
            /// <para>channel where R, G, B are the same. Even in that case, you should</para>
            /// <para>provide three equal values to the setter.</para>
            /// </remarks>
            public abstract void SetValue(uint index, float r, float g, float b);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract uint Length
            {
                get;

                set;
            }

            public abstract bool InputHalfDomain
            {
                get;

                set;
            }

            public abstract bool OutputRawHalfs
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust HueAdjust
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.Interpolation Interpolation
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~Lut1DTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // BitDepth getFileOutputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileOutputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileOutputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.FileOutputBitDepth;
                return ___ret;
            }

            // void setFileOutputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileOutputBitDepthDelegateInstance;

            private static void _SetFileOutputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.FileOutputBitDepth = bitDepth;
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const Lut1DTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // unsigned long getLength() const = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetLengthDelegateInstance;

            private static uint _GetLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.Length;
                return ___ret;
            }

            // void setLength(unsigned long length) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint _SetLengthDelegateInstance;

            private static void _SetLengthDelegateHook(__IntPtr __instance, uint length)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.Length = length;
            }

            // void getValue(unsigned long index, float & r, float & g, float & b) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtr_floatPtr_floatPtr _GetValueDelegateInstance;

            private static void _GetValueDelegateHook(__IntPtr __instance, uint index, float* r, float* g, float* b)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.GetValue(index, ref *r, ref *g, ref *b);
            }

            // void setValue(unsigned long index, float r, float g, float b) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_float_float_float _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, uint index, float r, float g, float b)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.SetValue(index, r, g, b);
            }

            // bool getInputHalfDomain() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetInputHalfDomainDelegateInstance;

            private static bool _GetInputHalfDomainDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.InputHalfDomain;
                return ___ret;
            }

            // void setInputHalfDomain(bool isHalfDomain) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetInputHalfDomainDelegateInstance;

            private static void _SetInputHalfDomainDelegateHook(__IntPtr __instance, bool isHalfDomain)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.InputHalfDomain = isHalfDomain;
            }

            // bool getOutputRawHalfs() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetOutputRawHalfsDelegateInstance;

            private static bool _GetOutputRawHalfsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.OutputRawHalfs;
                return ___ret;
            }

            // void setOutputRawHalfs(bool isRawHalfs) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetOutputRawHalfsDelegateInstance;

            private static void _SetOutputRawHalfsDelegateHook(__IntPtr __instance, bool isRawHalfs)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.OutputRawHalfs = isRawHalfs;
            }

            // Lut1DHueAdjust getHueAdjust() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust___IntPtr _GetHueAdjustDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust _GetHueAdjustDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.HueAdjust;
                return ___ret;
            }

            // void setHueAdjust(Lut1DHueAdjust algo) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust _SetHueAdjustDelegateInstance;

            private static void _SetHueAdjustDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust algo)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.HueAdjust = algo;
            }

            // Interpolation getInterpolation() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr _GetInterpolationDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.Interpolation _GetInterpolationDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                var ___ret = __target.Interpolation;
                return ___ret;
            }

            // void setInterpolation(Interpolation algo) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation _SetInterpolationDelegateInstance;

            private static void _SetInterpolationDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Interpolation algo)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform.__GetInstance(__instance);
                __target.Interpolation = algo;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[21];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFileOutputBitDepthDelegateInstance += _GetFileOutputBitDepthDelegateHook;
                    _SetFileOutputBitDepthDelegateInstance += _SetFileOutputBitDepthDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetLengthDelegateInstance += _GetLengthDelegateHook;
                    _SetLengthDelegateInstance += _SetLengthDelegateHook;
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _GetInputHalfDomainDelegateInstance += _GetInputHalfDomainDelegateHook;
                    _SetInputHalfDomainDelegateInstance += _SetInputHalfDomainDelegateHook;
                    _GetOutputRawHalfsDelegateInstance += _GetOutputRawHalfsDelegateHook;
                    _SetOutputRawHalfsDelegateInstance += _SetOutputRawHalfsDelegateHook;
                    _GetHueAdjustDelegateInstance += _GetHueAdjustDelegateHook;
                    _SetHueAdjustDelegateInstance += _SetHueAdjustDelegateHook;
                    _GetInterpolationDelegateInstance += _GetInterpolationDelegateHook;
                    _SetInterpolationDelegateInstance += _SetInterpolationDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFileOutputBitDepthDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetFileOutputBitDepthDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetLengthDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetLengthDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetInputHalfDomainDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetInputHalfDomainDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetOutputRawHalfsDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SetOutputRawHalfsDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetHueAdjustDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_SetHueAdjustDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetInterpolationDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_SetInterpolationDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][8] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                VTables.Methods[0] = new Delegate[23];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents a 3D-LUT transform.</summary>
        public unsafe abstract partial class Lut3DTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0Lut3DTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new Lut3DTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Lut3DTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new Lut3DTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Lut3DTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new Lut3DTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Lut3DTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Lut3DTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Lut3DTransformInternal(native, skipVTables);
            }

            protected Lut3DTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected Lut3DTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.Lut3DTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform other);

            public abstract void GetValue(uint indexR, uint indexG, uint indexB, ref float r, ref float g, ref float b);

            /// <summary>
            /// <para>Set the values of a 3D-LUT. Will throw if an index is</para>
            /// <para>outside of the range from 0 to (gridSize-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how the</para>
            /// <para>transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The values</para>
            /// <para>here are unclamped and may extend outside [0,1].</para>
            /// </remarks>
            public abstract void SetValue(uint indexR, uint indexG, uint indexB, float r, float g, float b);

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            public abstract uint GridSize
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.Interpolation Interpolation
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~Lut3DTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // BitDepth getFileOutputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileOutputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileOutputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.FileOutputBitDepth;
                return ___ret;
            }

            // void setFileOutputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileOutputBitDepthDelegateInstance;

            private static void _SetFileOutputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.FileOutputBitDepth = bitDepth;
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const Lut3DTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // unsigned long getGridSize() const = 0
            private static global::OpenColorIO.Delegates.Func_uint___IntPtr _GetGridSizeDelegateInstance;

            private static uint _GetGridSizeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.GridSize;
                return ___ret;
            }

            // void setGridSize(unsigned long gridSize) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint _SetGridSizeDelegateInstance;

            private static void _SetGridSizeDelegateHook(__IntPtr __instance, uint gridSize)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.GridSize = gridSize;
            }

            // void getValue(unsigned long indexR, unsigned long indexG, unsigned long indexB, float & r, float & g, float & b) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_uint_uint_floatPtr_floatPtr_floatPtr _GetValueDelegateInstance;

            private static void _GetValueDelegateHook(__IntPtr __instance, uint indexR, uint indexG, uint indexB, float* r, float* g, float* b)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.GetValue(indexR, indexG, indexB, ref *r, ref *g, ref *b);
            }

            // void setValue(unsigned long indexR, unsigned long indexG, unsigned long indexB, float r, float g, float b) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_uint_uint_uint_float_float_float _SetValueDelegateInstance;

            private static void _SetValueDelegateHook(__IntPtr __instance, uint indexR, uint indexG, uint indexB, float r, float g, float b)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.SetValue(indexR, indexG, indexB, r, g, b);
            }

            // Interpolation getInterpolation() const = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr _GetInterpolationDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.Interpolation _GetInterpolationDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                var ___ret = __target.Interpolation;
                return ___ret;
            }

            // void setInterpolation(Interpolation algo) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation _SetInterpolationDelegateInstance;

            private static void _SetInterpolationDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Interpolation algo)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform.__GetInstance(__instance);
                __target.Interpolation = algo;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[15];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFileOutputBitDepthDelegateInstance += _GetFileOutputBitDepthDelegateHook;
                    _SetFileOutputBitDepthDelegateInstance += _SetFileOutputBitDepthDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetGridSizeDelegateInstance += _GetGridSizeDelegateHook;
                    _SetGridSizeDelegateInstance += _SetGridSizeDelegateHook;
                    _GetValueDelegateInstance += _GetValueDelegateHook;
                    _SetValueDelegateInstance += _SetValueDelegateHook;
                    _GetInterpolationDelegateInstance += _GetInterpolationDelegateHook;
                    _SetInterpolationDelegateInstance += _SetInterpolationDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFileOutputBitDepthDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetFileOutputBitDepthDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetGridSizeDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetGridSizeDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetValueDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetInterpolationDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetInterpolationDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][8] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                VTables.Methods[0] = new Delegate[17];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents an MX+B Matrix transform.</summary>
        /// <remarks>For singular matrices, an inverse direction will throw an exception during finalization.</remarks>
        public unsafe abstract partial class MatrixTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0MatrixTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?Fit@MatrixTransform@OpenColorIO_v2_4@@SAXPEAN0PEBN111@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Fit(double* m44, double* offset4, double* oldmin4, double* oldmax4, double* newmin4, double* newmax4);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?Identity@MatrixTransform@OpenColorIO_v2_4@@SAXPEAN0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Identity(double* m44, double* offset4);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?Sat@MatrixTransform@OpenColorIO_v2_4@@SAXPEAN0NPEBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sat(double* m44, double* offset4, double sat, double* lumaCoef3);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?Scale@MatrixTransform@OpenColorIO_v2_4@@SAXPEAN0PEBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Scale(double* m44, double* offset4, double* scale4);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "?View@MatrixTransform@OpenColorIO_v2_4@@SAXPEAN0PEAHPEBN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void View(double* m44, double* offset4, int* channelHot4, double* lumaCoef3);
            }

            internal static new MatrixTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MatrixTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new MatrixTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MatrixTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new MatrixTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MatrixTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MatrixTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MatrixTransformInternal(native, skipVTables);
            }

            protected MatrixTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected MatrixTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.MatrixTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform other);

            public abstract void GetMatrix(ref double m44);

            /// <summary>
            /// <para>Get or set the values of a Matrix. Expects 16 values,</para>
            /// <para>where the first four are the coefficients to generate the R output</para>
            /// <para>channel from R, G, B, A input channels.</para>
            /// </summary>
            /// <remarks>
            /// <para>The Matrix values are always for the &quot;forward&quot; Matrix, regardless of</para>
            /// <para>how the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example in a CLF file using a &quot;32f&quot;</para>
            /// <para>input depth and &quot;10i&quot; output depth, a value of 1023 in the file</para>
            /// <para>is normalized to 1.0. The values here are unclamped and may</para>
            /// <para>extend outside [0,1].</para>
            /// </remarks>
            public abstract void SetMatrix(ref double m44);

            public abstract void GetOffset(ref double offset4);

            /// <summary>
            /// <para>Get or set the R, G, B, A offsets to be applied</para>
            /// <para>after the matrix.</para>
            /// </summary>
            /// <remarks>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example, in a CLF file using a</para>
            /// <para>&quot;10i&quot; output depth, a value of 1023 in the file is normalized</para>
            /// <para>to 1.0. The values here are unclamped and may extend</para>
            /// <para>outside [0,1].</para>
            /// </remarks>
            public abstract void SetOffset(ref double offset4);

            /// <summary>**Convenience functions**</summary>
            /// <remarks>
            /// <para>Build the matrix and offset corresponding to higher-level concepts.</para>
            /// <para>These can throw an exception if for any component</para>
            /// <para>``oldmin == oldmax. (divide by 0)``</para>
            /// </remarks>
            public static void Fit(ref double m44, ref double offset4, ref double oldmin4, ref double oldmax4, ref double newmin4, ref double newmax4)
            {
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    fixed (double* __offset41 = &offset4)
                    {
                        var __arg1 = __offset41;
                        fixed (double* __oldmin42 = &oldmin4)
                        {
                            var __arg2 = __oldmin42;
                            fixed (double* __oldmax43 = &oldmax4)
                            {
                                var __arg3 = __oldmax43;
                                fixed (double* __newmin44 = &newmin4)
                                {
                                    var __arg4 = __newmin44;
                                    fixed (double* __newmax45 = &newmax4)
                                    {
                                        var __arg5 = __newmax45;
                                        __Internal.Fit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            public static void Identity(ref double m44, ref double offset4)
            {
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    fixed (double* __offset41 = &offset4)
                    {
                        var __arg1 = __offset41;
                        __Internal.Identity(__arg0, __arg1);
                    }
                }
            }

            public static void Sat(ref double m44, ref double offset4, double sat, ref double lumaCoef3)
            {
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    fixed (double* __offset41 = &offset4)
                    {
                        var __arg1 = __offset41;
                        fixed (double* __lumaCoef33 = &lumaCoef3)
                        {
                            var __arg3 = __lumaCoef33;
                            __Internal.Sat(__arg0, __arg1, sat, __arg3);
                        }
                    }
                }
            }

            public static void Scale(ref double m44, ref double offset4, ref double scale4)
            {
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    fixed (double* __offset41 = &offset4)
                    {
                        var __arg1 = __offset41;
                        fixed (double* __scale42 = &scale4)
                        {
                            var __arg2 = __scale42;
                            __Internal.Scale(__arg0, __arg1, __arg2);
                        }
                    }
                }
            }

            public static void View(ref double m44, ref double offset4, ref int channelHot4, ref double lumaCoef3)
            {
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    fixed (double* __offset41 = &offset4)
                    {
                        var __arg1 = __offset41;
                        fixed (int* __channelHot42 = &channelHot4)
                        {
                            var __arg2 = __channelHot42;
                            fixed (double* __lumaCoef33 = &lumaCoef3)
                            {
                                var __arg3 = __lumaCoef33;
                                __Internal.View(__arg0, __arg1, __arg2, __arg3);
                            }
                        }
                    }
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the matrix values read from a</para>
            /// <para>file or set the bit-depths of values to be written to a file</para>
            /// <para>(for file formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            /// <remarks>
            /// <para>In a format such as CLF, the matrix values are scaled to take</para>
            /// <para>pixels at the specified inBitDepth to pixels at the specified</para>
            /// <para>outBitDepth.  This complicates the interpretation of the matrix</para>
            /// <para>values and so this object always holds normalized values and</para>
            /// <para>scaling is done on the way from or to file formats such as CLF.</para>
            /// </remarks>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileInputBitDepth
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get;

                set;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~MatrixTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const MatrixTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // void getMatrix(double * m44) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetMatrixDelegateInstance;

            private static void _GetMatrixDelegateHook(__IntPtr __instance, double* m44)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.GetMatrix(ref *m44);
            }

            // void setMatrix(const double * m44) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetMatrixDelegateInstance;

            private static void _SetMatrixDelegateHook(__IntPtr __instance, double* m44)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.SetMatrix(ref *m44);
            }

            // void getOffset(double * offset4) const = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _GetOffsetDelegateInstance;

            private static void _GetOffsetDelegateHook(__IntPtr __instance, double* offset4)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.GetOffset(ref *offset4);
            }

            // void setOffset(const double * offset4) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_doublePtr _SetOffsetDelegateInstance;

            private static void _SetOffsetDelegateHook(__IntPtr __instance, double* offset4)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.SetOffset(ref *offset4);
            }

            // BitDepth getFileInputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileInputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileInputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var ___ret = __target.FileInputBitDepth;
                return ___ret;
            }

            // void setFileInputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileInputBitDepthDelegateInstance;

            private static void _SetFileInputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.FileInputBitDepth = bitDepth;
            }

            // BitDepth getFileOutputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileOutputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileOutputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                var ___ret = __target.FileOutputBitDepth;
                return ___ret;
            }

            // void setFileOutputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileOutputBitDepthDelegateInstance;

            private static void _SetFileOutputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform.__GetInstance(__instance);
                __target.FileOutputBitDepth = bitDepth;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[15];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetMatrixDelegateInstance += _GetMatrixDelegateHook;
                    _SetMatrixDelegateInstance += _SetMatrixDelegateHook;
                    _GetOffsetDelegateInstance += _GetOffsetDelegateHook;
                    _SetOffsetDelegateInstance += _SetOffsetDelegateHook;
                    _GetFileInputBitDepthDelegateInstance += _GetFileInputBitDepthDelegateHook;
                    _SetFileInputBitDepthDelegateInstance += _SetFileInputBitDepthDelegateHook;
                    _GetFileOutputBitDepthDelegateInstance += _GetFileOutputBitDepthDelegateHook;
                    _SetFileOutputBitDepthDelegateInstance += _SetFileOutputBitDepthDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMatrixDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetMatrixDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetOffsetDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetOffsetDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetFileInputBitDepthDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetFileInputBitDepthDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetFileOutputBitDepthDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetFileOutputBitDepthDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                VTables.Methods[0] = new Delegate[17];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Represents a range transform</summary>
        /// <remarks>
        /// <para>The Range is used to apply an affine transform (scale&amp;offset) and</para>
        /// <para>clamps values to min/max bounds on all color components except the alpha.</para>
        /// <para>The scale and offset values are computed from the input and output bounds.</para>
        /// <para>Refer to section 7.2.4 in specification S-2014-006 &quot;A Common File Format</para>
        /// <para>for Look-Up Tables&quot; from the Academy of Motion Picture Arts and Sciences</para>
        /// <para>and the American Society of Cinematographers.</para>
        /// <para>The &quot;noClamp&quot; style described in the specification S-2014-006 becomes a</para>
        /// <para>MatrixOp at the processor level.</para>
        /// <para>Changing the transform direction does not modify the in/out values --</para>
        /// <para>they are always specified with respect to the &quot;forward&quot; direction.</para>
        /// </remarks>
        public unsafe abstract partial class RangeTransform : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_Transform;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0RangeTransform@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            internal static new RangeTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RangeTransformInternal(native.ToPointer(), skipVTables);
            }

            internal static new RangeTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RangeTransform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RangeTransform __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RangeTransform)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RangeTransform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RangeTransformInternal(native, skipVTables);
            }

            protected RangeTransform(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected RangeTransform()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.RangeTransform");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Checks if this equals other.</summary>
            public abstract bool Equals(global::OpenColorIO.OpenColorIO_v2_4.RangeTransform other);

            /// <summary>Unset the minimum value for the input</summary>
            public abstract void UnsetMinInValue();

            /// <summary>Unset the maximum value for the input.</summary>
            public abstract void UnsetMaxInValue();

            /// <summary>Unset the minimum value for the output.</summary>
            public abstract void UnsetMinOutValue();

            /// <summary>Unset the maximum value for the output.</summary>
            public abstract void UnsetMaxOutValue();

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.RangeStyle Style
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get;
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the range values read from a file</para>
            /// <para>or set the bit-depths of values to be written to a file (for file</para>
            /// <para>formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileInputBitDepth
            {
                get;

                set;
            }

            public abstract global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get;

                set;
            }

            /// <summary>Get the minimum value for the input.</summary>
            /// <remarks>Set the minimum value for the input.</remarks>
            public abstract double MinInValue
            {
                get;

                set;
            }

            /// <summary>Is the minimum value for the input set?</summary>
            public abstract bool HasMinInValue
            {
                get;
            }

            /// <summary>Get the maximum value for the input.</summary>
            /// <remarks>Set the maximum value for the input.</remarks>
            public abstract double MaxInValue
            {
                get;

                set;
            }

            /// <summary>Is the maximum value for the input set?</summary>
            public abstract bool HasMaxInValue
            {
                get;
            }

            /// <summary>Get the minimum value for the output.</summary>
            /// <remarks>Set the minimum value for the output.</remarks>
            public abstract double MinOutValue
            {
                get;

                set;
            }

            /// <summary>Is the minimum value for the output set?</summary>
            public abstract bool HasMinOutValue
            {
                get;
            }

            /// <summary>Get the maximum value for the output.</summary>
            /// <remarks>Set the maximum value for the output.</remarks>
            public abstract double MaxOutValue
            {
                get;

                set;
            }

            /// <summary>Is the maximum value for the output set?</summary>
            public abstract bool HasMaxOutValue
            {
                get;
            }

            #region Virtual table interop

            // TransformDirection getDirection() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr _GetDirectionDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformDirection _GetDirectionDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.Direction;
                return ___ret;
            }

            // void setDirection(TransformDirection dir) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection _SetDirectionDelegateInstance;

            private static void _SetDirectionDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection dir)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.Direction = dir;
            }

            // TransformType getTransformType() const noexcept override
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr _GetTransformTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.TransformType _GetTransformTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.TransformType;
                return ___ret;
            }

            // void validate() const
            private static global::OpenColorIO.Delegates.Action___IntPtr _ValidateDelegateInstance;

            private static void _ValidateDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.Validate();
            }

            // virtual ~RangeTransform() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // RangeStyle getStyle() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_RangeStyle___IntPtr _GetStyleDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.RangeStyle _GetStyleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.Style;
                return ___ret;
            }

            // void setStyle(RangeStyle style) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RangeStyle _SetStyleDelegateInstance;

            private static void _SetStyleDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RangeStyle style)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.Style = style;
            }

            // FormatMetadata & getFormatMetadata() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetFormatMetadataDelegateInstance;

            private static __IntPtr _GetFormatMetadataDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.FormatMetadata;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // bool equals(const RangeTransform & other) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr _EqualsDelegateInstance;

            private static bool _EqualsDelegateHook(__IntPtr __instance, __IntPtr other)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetOrCreateInstance(other, false, skipVTables: true);
                var ___ret = __target.Equals(__result0);
                return ___ret;
            }

            // BitDepth getFileInputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileInputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileInputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.FileInputBitDepth;
                return ___ret;
            }

            // void setFileInputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileInputBitDepthDelegateInstance;

            private static void _SetFileInputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.FileInputBitDepth = bitDepth;
            }

            // BitDepth getFileOutputBitDepth() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr _GetFileOutputBitDepthDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.BitDepth _GetFileOutputBitDepthDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.FileOutputBitDepth;
                return ___ret;
            }

            // void setFileOutputBitDepth(BitDepth bitDepth) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth _SetFileOutputBitDepthDelegateInstance;

            private static void _SetFileOutputBitDepthDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth bitDepth)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.FileOutputBitDepth = bitDepth;
            }

            // double getMinInValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetMinInValueDelegateInstance;

            private static double _GetMinInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.MinInValue;
                return ___ret;
            }

            // void setMinInValue(double val) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetMinInValueDelegateInstance;

            private static void _SetMinInValueDelegateHook(__IntPtr __instance, double val)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.MinInValue = val;
            }

            // bool hasMinInValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _HasMinInValueDelegateInstance;

            private static bool _HasMinInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.HasMinInValue;
                return ___ret;
            }

            // void unsetMinInValue() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _UnsetMinInValueDelegateInstance;

            private static void _UnsetMinInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.UnsetMinInValue();
            }

            // void setMaxInValue(double val) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetMaxInValueDelegateInstance;

            private static void _SetMaxInValueDelegateHook(__IntPtr __instance, double val)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.MaxInValue = val;
            }

            // double getMaxInValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetMaxInValueDelegateInstance;

            private static double _GetMaxInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.MaxInValue;
                return ___ret;
            }

            // bool hasMaxInValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _HasMaxInValueDelegateInstance;

            private static bool _HasMaxInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.HasMaxInValue;
                return ___ret;
            }

            // void unsetMaxInValue() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _UnsetMaxInValueDelegateInstance;

            private static void _UnsetMaxInValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.UnsetMaxInValue();
            }

            // void setMinOutValue(double val) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetMinOutValueDelegateInstance;

            private static void _SetMinOutValueDelegateHook(__IntPtr __instance, double val)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.MinOutValue = val;
            }

            // double getMinOutValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetMinOutValueDelegateInstance;

            private static double _GetMinOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.MinOutValue;
                return ___ret;
            }

            // bool hasMinOutValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _HasMinOutValueDelegateInstance;

            private static bool _HasMinOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.HasMinOutValue;
                return ___ret;
            }

            // void unsetMinOutValue() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _UnsetMinOutValueDelegateInstance;

            private static void _UnsetMinOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.UnsetMinOutValue();
            }

            // void setMaxOutValue(double val) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_double _SetMaxOutValueDelegateInstance;

            private static void _SetMaxOutValueDelegateHook(__IntPtr __instance, double val)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.MaxOutValue = val;
            }

            // double getMaxOutValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_double___IntPtr _GetMaxOutValueDelegateInstance;

            private static double _GetMaxOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.MaxOutValue;
                return ___ret;
            }

            // bool hasMaxOutValue() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _HasMaxOutValueDelegateInstance;

            private static bool _HasMaxOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                var ___ret = __target.HasMaxOutValue;
                return ___ret;
            }

            // void unsetMaxOutValue() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _UnsetMaxOutValueDelegateInstance;

            private static void _UnsetMaxOutValueDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.RangeTransform.__GetInstance(__instance);
                __target.UnsetMaxOutValue();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[29];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetDirectionDelegateInstance += _GetDirectionDelegateHook;
                    _SetDirectionDelegateInstance += _SetDirectionDelegateHook;
                    _GetTransformTypeDelegateInstance += _GetTransformTypeDelegateHook;
                    _ValidateDelegateInstance += _ValidateDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetStyleDelegateInstance += _GetStyleDelegateHook;
                    _SetStyleDelegateInstance += _SetStyleDelegateHook;
                    _GetFormatMetadataDelegateInstance += _GetFormatMetadataDelegateHook;
                    _EqualsDelegateInstance += _EqualsDelegateHook;
                    _GetFileInputBitDepthDelegateInstance += _GetFileInputBitDepthDelegateHook;
                    _SetFileInputBitDepthDelegateInstance += _SetFileInputBitDepthDelegateHook;
                    _GetFileOutputBitDepthDelegateInstance += _GetFileOutputBitDepthDelegateHook;
                    _SetFileOutputBitDepthDelegateInstance += _SetFileOutputBitDepthDelegateHook;
                    _GetMinInValueDelegateInstance += _GetMinInValueDelegateHook;
                    _SetMinInValueDelegateInstance += _SetMinInValueDelegateHook;
                    _HasMinInValueDelegateInstance += _HasMinInValueDelegateHook;
                    _UnsetMinInValueDelegateInstance += _UnsetMinInValueDelegateHook;
                    _SetMaxInValueDelegateInstance += _SetMaxInValueDelegateHook;
                    _GetMaxInValueDelegateInstance += _GetMaxInValueDelegateHook;
                    _HasMaxInValueDelegateInstance += _HasMaxInValueDelegateHook;
                    _UnsetMaxInValueDelegateInstance += _UnsetMaxInValueDelegateHook;
                    _SetMinOutValueDelegateInstance += _SetMinOutValueDelegateHook;
                    _GetMinOutValueDelegateInstance += _GetMinOutValueDelegateHook;
                    _HasMinOutValueDelegateInstance += _HasMinOutValueDelegateHook;
                    _UnsetMinOutValueDelegateInstance += _UnsetMinOutValueDelegateHook;
                    _SetMaxOutValueDelegateInstance += _SetMaxOutValueDelegateHook;
                    _GetMaxOutValueDelegateInstance += _GetMaxOutValueDelegateHook;
                    _HasMaxOutValueDelegateInstance += _HasMaxOutValueDelegateHook;
                    _UnsetMaxOutValueDelegateInstance += _UnsetMaxOutValueDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDirectionDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetDirectionDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetTransformTypeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ValidateDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetStyleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetStyleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetFormatMetadataDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_EqualsDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetFileInputBitDepthDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetFileInputBitDepthDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetFileOutputBitDepthDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetFileOutputBitDepthDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetMinInValueDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetMinInValueDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_HasMinInValueDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_UnsetMinInValueDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_SetMaxInValueDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetMaxInValueDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_HasMaxInValueDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_UnsetMaxInValueDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_SetMinOutValueDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_GetMinOutValueDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_HasMinOutValueDelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_UnsetMinOutValueDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_SetMaxOutValueDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetMaxOutValueDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_HasMaxOutValueDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_UnsetMaxOutValueDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 31, 0);
                                ManagedVTablesDtorOnly[0][5] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 31, 0);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][3] = Thunks[2];
                                ManagedVTables[0][4] = Thunks[3];
                                ManagedVTables[0][5] = Thunks[4];
                                ManagedVTables[0][6] = Thunks[5];
                                ManagedVTables[0][7] = Thunks[6];
                                ManagedVTables[0][8] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                ManagedVTables[0][23] = Thunks[21];
                                ManagedVTables[0][24] = Thunks[22];
                                ManagedVTables[0][25] = Thunks[23];
                                ManagedVTables[0][26] = Thunks[24];
                                ManagedVTables[0][27] = Thunks[25];
                                ManagedVTables[0][28] = Thunks[26];
                                ManagedVTables[0][29] = Thunks[27];
                                ManagedVTables[0][30] = Thunks[28];
                                VTables.Methods[0] = new Delegate[31];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class FormatMetadataInternal : global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal FormatMetadataInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal FormatMetadataInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Get the name of a attribute (&quot;&quot; if attribute does not exist).</summary>
            public override string GetAttributeName(int i)
            {
                var ___GetAttributeNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int>(0, 5);
                var ___ret = ___GetAttributeNameDelegate(__Instance, i);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the value of a attribute (&quot;&quot; if attribute does not exist).</summary>
            public override string GetAttributeValue(int i)
            {
                var ___GetAttributeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int>(0, 7);
                var ___ret = ___GetAttributeValueDelegate(__Instance, i);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the value of a attribute of a given name (&quot;&quot; if attribute does not exist).</summary>
            public override string GetAttributeValue(string name)
            {
                var ___GetAttributeValue_1Delegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8>(0, 6);
                var ___ret = ___GetAttributeValue_1Delegate(__Instance, name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Add an attribute with a given name and value. If an attribute with the same name already</para>
            /// <para>exists, its value is replaced. Throw if name is NULL or empty.</para>
            /// </summary>
            public override void AddAttribute(string name, string value)
            {
                var ___AddAttributeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8>(0, 8);
                ___AddAttributeDelegate(__Instance, name, value);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata GetChildElement(int i)
            {
                var ___GetChildElementDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_int>(0, 10);
                var ___ret = ___GetChildElementDelegate(__Instance, i);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Add a child element with a given name and value.</summary>
            /// <remarks>
            /// <para>Name has to be non-empty. Value may be empty, particularly if this element will have</para>
            /// <para>children. Element is added after all existing children. Use</para>
            /// <para>getChildElement(getNumChildrenElements()-1) to access the added element.</para>
            /// </remarks>
            public override void AddChildElement(string name, string value)
            {
                var ___AddChildElementDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8_string8>(0, 12);
                ___AddChildElementDelegate(__Instance, name, value);
            }

            /// <summary>Remove all children, all attributes and the value.</summary>
            public override void Clear()
            {
                var ___ClearDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 13);
                ___ClearDelegate(__Instance);
            }

            public override string ElementName
            {
                get
                {
                    var ___GetElementNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 0);
                    var ___ret = ___GetElementNameDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetElementNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 1);
                    ___SetElementNameDelegate(__Instance, value);
                }
            }

            public override string ElementValue
            {
                get
                {
                    var ___GetElementValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetElementValueDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetElementValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 3);
                    ___SetElementValueDelegate(__Instance, value);
                }
            }

            public override int NumAttributes
            {
                get
                {
                    var ___GetNumAttributesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 4);
                    var ___ret = ___GetNumAttributesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumChildrenElements
            {
                get
                {
                    var ___GetNumChildrenElementsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 9);
                    var ___ret = ___GetNumChildrenElementsDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'name' attribute.  This corresponds to the</para>
            /// <para>ProcessNode name attribute from a CLF / CTF file or the name key of a transform in the</para>
            /// <para>config YAML.</para>
            /// </summary>
            public override string Name
            {
                get
                {
                    var ___GetNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 15);
                    var ___ret = ___GetNameDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 16);
                    ___SetNameDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'id' attribute.  This corresponds to the</para>
            /// <para>ProcessNode id attribute from a CLF/CTF file or the ColorCorrection id attribute from a</para>
            /// <para>CC/CCC/CDL file.</para>
            /// </summary>
            public override string ID
            {
                get
                {
                    var ___GetIDDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 17);
                    var ___ret = ___GetIDDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetIDDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 18);
                    ___SetIDDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class TransformInternal : global::OpenColorIO.OpenColorIO_v2_4.Transform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal TransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal TransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class BuiltinTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.BuiltinTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal BuiltinTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal BuiltinTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override string Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 7);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override string Description
            {
                get
                {
                    var ___GetDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 8);
                    var ___ret = ___GetDescriptionDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class CDLTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.CDLTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CDLTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal CDLTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.CDLTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetSlope(ref double rgb)
            {
                var ___GetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 11);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___GetSlopeDelegate(__Instance, __arg0);
                }
            }

            public override void SetSlope(ref double rgb)
            {
                var ___SetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 12);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___SetSlopeDelegate(__Instance, __arg0);
                }
            }

            public override void GetOffset(ref double rgb)
            {
                var ___GetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 13);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___GetOffsetDelegate(__Instance, __arg0);
                }
            }

            public override void SetOffset(ref double rgb)
            {
                var ___SetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 14);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___SetOffsetDelegate(__Instance, __arg0);
                }
            }

            public override void GetPower(ref double rgb)
            {
                var ___GetPowerDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 15);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___GetPowerDelegate(__Instance, __arg0);
                }
            }

            public override void SetPower(ref double rgb)
            {
                var ___SetPowerDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 16);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___SetPowerDelegate(__Instance, __arg0);
                }
            }

            public override void GetSOP(ref double vec9)
            {
                var ___GetSOPDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 17);
                fixed (double* __vec90 = &vec9)
                {
                    var __arg0 = __vec90;
                    ___GetSOPDelegate(__Instance, __arg0);
                }
            }

            public override void SetSOP(ref double vec9)
            {
                var ___SetSOPDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 18);
                fixed (double* __vec90 = &vec9)
                {
                    var __arg0 = __vec90;
                    ___SetSOPDelegate(__Instance, __arg0);
                }
            }

            /// <summary>These are hard-coded, by spec, to r709.</summary>
            public override void GetSatLumaCoefs(ref double rgb)
            {
                var ___GetSatLumaCoefsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 21);
                fixed (double* __rgb0 = &rgb)
                {
                    var __arg0 = __rgb0;
                    ___GetSatLumaCoefsDelegate(__Instance, __arg0);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 7);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.CDLStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_CDLStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_CDLStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override double Sat
            {
                get
                {
                    var ___GetSatDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 19);
                    var ___ret = ___GetSatDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSatDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 20);
                    ___SetSatDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The get/setID methods are now deprecated. The preferred way of interacting with the ID is</para>
            /// <para>now via the transform's formatMetadata.</para>
            /// </summary>
            public override string ID
            {
                get
                {
                    var ___GetIDDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 22);
                    var ___ret = ___GetIDDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetIDDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 23);
                    ___SetIDDelegate(__Instance, value);
                }
            }

            public override string FirstSOPDescription
            {
                get
                {
                    var ___GetFirstSOPDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 24);
                    var ___ret = ___GetFirstSOPDescriptionDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetFirstSOPDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 25);
                    ___SetFirstSOPDescriptionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GradingBSplineCurveInternal : global::OpenColorIO.OpenColorIO_v2_4.GradingBSplineCurve, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GradingBSplineCurveInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GradingBSplineCurveInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint GetControlPoint(ulong index)
            {
                var ___GetControlPointDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 3);
                var ___ret = ___GetControlPointDelegate(__Instance, index);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingControlPoint.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public override float GetSlope(ulong index)
            {
                var ___GetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr_ulong>(0, 5);
                var ___ret = ___GetSlopeDelegate(__Instance, index);
                return ___ret;
            }

            public override void SetSlope(ulong index, float slope)
            {
                var ___SetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_ulong_float>(0, 6);
                ___SetSlopeDelegate(__Instance, index, slope);
            }

            public override void Validate()
            {
                var ___ValidateDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 8);
                ___ValidateDelegate(__Instance);
            }

            public override ulong NumControlPoints
            {
                get
                {
                    var ___GetNumControlPointsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 1);
                    var ___ret = ___GetNumControlPointsDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetNumControlPointsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_ulong>(0, 2);
                    ___SetNumControlPointsDelegate(__Instance, value);
                }
            }

            public override bool SlopesAreDefault
            {
                get
                {
                    var ___SlopesAreDefaultDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 7);
                    var ___ret = ___SlopesAreDefaultDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class GradingRGBCurveInternal : global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurve, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GradingRGBCurveInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GradingRGBCurveInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override void Validate()
            {
                var ___ValidateDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 1);
                ___ValidateDelegate(__Instance);
            }

            public override bool IsIdentity
            {
                get
                {
                    var ___IsIdentityDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 2);
                    var ___ret = ___IsIdentityDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class DynamicPropertyInternal : global::OpenColorIO.OpenColorIO_v2_4.DynamicProperty, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal DynamicPropertyInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal DynamicPropertyInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType Type
            {
                get
                {
                    var ___GetTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_DynamicPropertyType___IntPtr>(0, 0);
                    var ___ret = ___GetTypeDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class DynamicPropertyDoubleInternal : global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyDouble, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal DynamicPropertyDoubleInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal DynamicPropertyDoubleInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override double Value
            {
                get
                {
                    var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 0);
                    var ___ret = ___GetValueDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 1);
                    ___SetValueDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class DynamicPropertyGradingPrimaryInternal : global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingPrimary, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal DynamicPropertyGradingPrimaryInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal DynamicPropertyGradingPrimaryInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary Value
            {
                get
                {
                    var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 0);
                    var ___ret = ___GetValueDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }

                set
                {
                    var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetValueDelegate(__Instance, __arg0);
                }
            }
        }

        public unsafe partial class DynamicPropertyGradingRGBCurveInternal : global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingRGBCurve, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal DynamicPropertyGradingRGBCurveInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal DynamicPropertyGradingRGBCurveInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }
        }

        public unsafe partial class DynamicPropertyGradingToneInternal : global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyGradingTone, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal DynamicPropertyGradingToneInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal DynamicPropertyGradingToneInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.GradingTone Value
            {
                get
                {
                    var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 0);
                    var ___ret = ___GetValueDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }

                set
                {
                    var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetValueDelegate(__Instance, __arg0);
                }
            }
        }

        public unsafe partial class ExponentTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ExponentTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ExponentTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExponentTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetValue(double[] vec4)
            {
                var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 9);
                if (vec4 == null || vec4.Length != 4)
                    throw new ArgumentOutOfRangeException("vec4", "The dimensions of the provided array don't match the required size.");
                ___GetValueDelegate(__Instance, vec4);
            }

            public override void SetValue(double[] vec4)
            {
                var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 10);
                if (vec4 == null || vec4.Length != 4)
                    throw new ArgumentOutOfRangeException("vec4", "The dimensions of the provided array don't match the required size.");
                ___SetValueDelegate(__Instance, vec4);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_CLAMP -- Clamp negative values (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// <para>* NEGATIVE_PASS_THRU -- Negative values are passed through unchanged.</para>
            /// </remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyle
            {
                get
                {
                    var ___GetNegativeStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr>(0, 11);
                    var ___ret = ___GetNegativeStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetNegativeStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle>(0, 12);
                    ___SetNegativeStyleDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class ExponentWithLinearTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ExponentWithLinearTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ExponentWithLinearTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExponentWithLinearTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetGamma(double[] values)
            {
                var ___GetGammaDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 9);
                if (values == null || values.Length != 4)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetGammaDelegate(__Instance, values);
            }

            /// <summary>Set the exponent value for the power function for R, G, B, A.</summary>
            /// <remarks>
            /// <para>The gamma values must be in the range of [1, 10]. Set the transform direction</para>
            /// <para>to inverse to obtain the effect of values less than 1.</para>
            /// </remarks>
            public override void SetGamma(double[] values)
            {
                var ___SetGammaDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 10);
                if (values == null || values.Length != 4)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetGammaDelegate(__Instance, values);
            }

            public override void GetOffset(double[] values)
            {
                var ___GetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 11);
                if (values == null || values.Length != 4)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetOffsetDelegate(__Instance, values);
            }

            /// <summary>Set the offset value for the power function for R, G, B, A.</summary>
            /// <remarks>The offset values must be in the range [0, 0.9].</remarks>
            public override void SetOffset(double[] values)
            {
                var ___SetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 12);
                if (values == null || values.Length != 4)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetOffsetDelegate(__Instance, values);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_LINEAR -- Linear segment continues into negatives (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// </remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle NegativeStyle
            {
                get
                {
                    var ___GetNegativeStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr>(0, 13);
                    var ___ret = ___GetNegativeStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetNegativeStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle>(0, 14);
                    ___SetNegativeStyleDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class ExposureContrastTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ExposureContrastTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ExposureContrastTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void MakeExposureDynamic()
            {
                var ___MakeExposureDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 14);
                ___MakeExposureDynamicDelegate(__Instance);
            }

            public override void MakeExposureNonDynamic()
            {
                var ___MakeExposureNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 15);
                ___MakeExposureNonDynamicDelegate(__Instance);
            }

            public override void MakeContrastDynamic()
            {
                var ___MakeContrastDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 19);
                ___MakeContrastDynamicDelegate(__Instance);
            }

            public override void MakeContrastNonDynamic()
            {
                var ___MakeContrastNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 20);
                ___MakeContrastNonDynamicDelegate(__Instance);
            }

            public override void MakeGammaDynamic()
            {
                var ___MakeGammaDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 24);
                ___MakeGammaDynamicDelegate(__Instance);
            }

            public override void MakeGammaNonDynamic()
            {
                var ___MakeGammaNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 25);
                ___MakeGammaNonDynamicDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override double Exposure
            {
                get
                {
                    var ___GetExposureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 11);
                    var ___ret = ___GetExposureDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetExposureDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 12);
                    ___SetExposureDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Exposure can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic exposure.</para>
            /// </summary>
            public override bool IsExposureDynamic
            {
                get
                {
                    var ___IsExposureDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 13);
                    var ___ret = ___IsExposureDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override double Contrast
            {
                get
                {
                    var ___GetContrastDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 16);
                    var ___ret = ___GetContrastDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetContrastDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 17);
                    ___SetContrastDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Contrast can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic contrast.</para>
            /// </summary>
            public override bool IsContrastDynamic
            {
                get
                {
                    var ___IsContrastDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 18);
                    var ___ret = ___IsContrastDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override double Gamma
            {
                get
                {
                    var ___GetGammaDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 21);
                    var ___ret = ___GetGammaDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetGammaDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 22);
                    ___SetGammaDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Gamma can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic gamma.</para>
            /// </summary>
            public override bool IsGammaDynamic
            {
                get
                {
                    var ___IsGammaDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 23);
                    var ___ret = ___IsGammaDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override double Pivot
            {
                get
                {
                    var ___GetPivotDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 26);
                    var ___ret = ___GetPivotDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetPivotDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 27);
                    ___SetPivotDelegate(__Instance, value);
                }
            }

            public override double LogExposureStep
            {
                get
                {
                    var ___GetLogExposureStepDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 28);
                    var ___ret = ___GetLogExposureStepDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetLogExposureStepDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 29);
                    ___SetLogExposureStepDelegate(__Instance, value);
                }
            }

            public override double LogMidGray
            {
                get
                {
                    var ___GetLogMidGrayDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 30);
                    var ___ret = ___GetLogMidGrayDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetLogMidGrayDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 31);
                    ___SetLogMidGrayDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class FixedFunctionTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal FixedFunctionTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal FixedFunctionTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetParams(ref double @params)
            {
                var ___GetParamsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 12);
                fixed (double* __params0 = &@params)
                {
                    var __arg0 = __params0;
                    ___GetParamsDelegate(__Instance, __arg0);
                }
            }

            /// <summary>Set the parameters (for functions that require them).</summary>
            public override void SetParams(ref double @params, ulong num)
            {
                var ___SetParamsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr_ulong>(0, 13);
                fixed (double* __params0 = &@params)
                {
                    var __arg0 = __params0;
                    ___SetParamsDelegate(__Instance, __arg0, num);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override ulong NumParams
            {
                get
                {
                    var ___GetNumParamsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 11);
                    var ___ret = ___GetNumParamsDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GradingPrimaryTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GradingPrimaryTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GradingPrimaryTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingPrimaryTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void MakeDynamic()
            {
                var ___MakeDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 14);
                ___MakeDynamicDelegate(__Instance);
            }

            public override void MakeNonDynamic()
            {
                var ___MakeNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 15);
                ___MakeNonDynamicDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary Value
            {
                get
                {
                    var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 11);
                    var ___ret = ___GetValueDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingPrimary.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }

                set
                {
                    var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr>(0, 12);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetValueDelegate(__Instance, __arg0);
                }
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingPrimaryTransform only one can have dynamic parameters.</para>
            /// </summary>
            public override bool IsDynamic
            {
                get
                {
                    var ___IsDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 13);
                    var ___ret = ___IsDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GradingRGBCurveTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GradingRGBCurveTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GradingRGBCurveTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingRGBCurveTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>
            /// <para>It is possible to provide a desired slope value for each control point.  The number of slopes is</para>
            /// <para>always the same as the number of control points and so the control points must be set before</para>
            /// <para>setting the slopes.  The slopes are primarily intended for use by config authors looking to match</para>
            /// <para>a specific shape with as few control points as possible, they are not intended to be exposed to</para>
            /// <para>a user interface for direct manipulation.  When a curve is being generated for creative purposes</para>
            /// <para>it is better to let OCIO calculate the slopes automatically.</para>
            /// </summary>
            public override float GetSlope(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index)
            {
                var ___GetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong>(0, 13);
                var ___ret = ___GetSlopeDelegate(__Instance, c, index);
                return ___ret;
            }

            public override void SetSlope(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c, ulong index, float slope)
            {
                var ___SetSlopeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong_float>(0, 14);
                ___SetSlopeDelegate(__Instance, c, index, slope);
            }

            public override bool SlopesAreDefault(global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType c)
            {
                var ___SlopesAreDefaultDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType>(0, 15);
                var ___ret = ___SlopesAreDefaultDelegate(__Instance, c);
                return ___ret;
            }

            public override void MakeDynamic()
            {
                var ___MakeDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 19);
                ___MakeDynamicDelegate(__Instance);
            }

            public override void MakeNonDynamic()
            {
                var ___MakeNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 20);
                ___MakeNonDynamicDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>The scene-linear grading style applies a lin-to-log transform to the pixel</para>
            /// <para>values before going through the curve.  However, in some cases (e.g. drawing curves in a UI)</para>
            /// <para>it may be useful to bypass the lin-to-log. Default value is false.</para>
            /// </summary>
            public override bool BypassLinToLog
            {
                get
                {
                    var ___GetBypassLinToLogDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 16);
                    var ___ret = ___GetBypassLinToLogDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetBypassLinToLogDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 17);
                    ___SetBypassLinToLogDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingRGBCurveTransform only one can have dynamic parameters.</para>
            /// </summary>
            public override bool IsDynamic
            {
                get
                {
                    var ___IsDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 18);
                    var ___ret = ___IsDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GradingToneTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GradingToneTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GradingToneTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.GradingToneTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void MakeDynamic()
            {
                var ___MakeDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 14);
                ___MakeDynamicDelegate(__Instance);
            }

            public override void MakeNonDynamic()
            {
                var ___MakeNonDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 15);
                ___MakeNonDynamicDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr>(0, 9);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle>(0, 10);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.GradingTone Value
            {
                get
                {
                    var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 11);
                    var ___ret = ___GetValueDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.GradingTone.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }

                set
                {
                    var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr___IntPtr>(0, 12);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetValueDelegate(__Instance, __arg0);
                }
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingToneTransform only one can have dynamic parameters.</para>
            /// </summary>
            public override bool IsDynamic
            {
                get
                {
                    var ___IsDynamicDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 13);
                    var ___ret = ___IsDynamicDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class GroupTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.GroupTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GroupTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GroupTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Return number of transforms.</summary>
            public override int NumTransforms
            {
                get
                {
                    var ___GetNumTransformsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_int___IntPtr>(0, 10);
                    var ___ret = ___GetNumTransformsDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformType TransformType
            {
                get
                {
                    var ___GetTransformTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr>(0, 3);
                    var ___ret = ___GetTransformTypeDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class LogAffineTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal LogAffineTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal LogAffineTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogAffineTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetLogSideSlopeValue(double[] values)
            {
                var ___GetLogSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 11);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLogSideSlopeValueDelegate(__Instance, values);
            }

            public override void SetLogSideSlopeValue(double[] values)
            {
                var ___SetLogSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 12);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLogSideSlopeValueDelegate(__Instance, values);
            }

            public override void GetLogSideOffsetValue(double[] values)
            {
                var ___GetLogSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 13);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLogSideOffsetValueDelegate(__Instance, values);
            }

            public override void SetLogSideOffsetValue(double[] values)
            {
                var ___SetLogSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 14);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLogSideOffsetValueDelegate(__Instance, values);
            }

            public override void GetLinSideSlopeValue(double[] values)
            {
                var ___GetLinSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 15);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLinSideSlopeValueDelegate(__Instance, values);
            }

            public override void SetLinSideSlopeValue(double[] values)
            {
                var ___SetLinSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 16);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinSideSlopeValueDelegate(__Instance, values);
            }

            public override void GetLinSideOffsetValue(double[] values)
            {
                var ___GetLinSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 17);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLinSideOffsetValueDelegate(__Instance, values);
            }

            public override void SetLinSideOffsetValue(double[] values)
            {
                var ___SetLinSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 18);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinSideOffsetValueDelegate(__Instance, values);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override double Base
            {
                get
                {
                    var ___GetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 9);
                    var ___ret = ___GetBaseDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 10);
                    ___SetBaseDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class LogCameraTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal LogCameraTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal LogCameraTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogCameraTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Get/Set values for the R, G, B components.</summary>
            public override void GetLogSideSlopeValue(double[] values)
            {
                var ___GetLogSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 11);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLogSideSlopeValueDelegate(__Instance, values);
            }

            public override void SetLogSideSlopeValue(double[] values)
            {
                var ___SetLogSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 12);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLogSideSlopeValueDelegate(__Instance, values);
            }

            public override void GetLogSideOffsetValue(double[] values)
            {
                var ___GetLogSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 13);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLogSideOffsetValueDelegate(__Instance, values);
            }

            public override void SetLogSideOffsetValue(double[] values)
            {
                var ___SetLogSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 14);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLogSideOffsetValueDelegate(__Instance, values);
            }

            public override void GetLinSideSlopeValue(double[] values)
            {
                var ___GetLinSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 15);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLinSideSlopeValueDelegate(__Instance, values);
            }

            public override void SetLinSideSlopeValue(double[] values)
            {
                var ___SetLinSideSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 16);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinSideSlopeValueDelegate(__Instance, values);
            }

            public override void GetLinSideOffsetValue(double[] values)
            {
                var ___GetLinSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 17);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLinSideOffsetValueDelegate(__Instance, values);
            }

            public override void SetLinSideOffsetValue(double[] values)
            {
                var ___SetLinSideOffsetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 18);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinSideOffsetValueDelegate(__Instance, values);
            }

            public override void GetLinSideBreakValue(double[] values)
            {
                var ___GetLinSideBreakValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 19);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___GetLinSideBreakValueDelegate(__Instance, values);
            }

            public override void SetLinSideBreakValue(double[] values)
            {
                var ___SetLinSideBreakValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 20);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinSideBreakValueDelegate(__Instance, values);
            }

            /// <summary>Return true if LinearSlope values were set, false if they were not.</summary>
            public override bool GetLinearSlopeValue(double[] values)
            {
                var ___GetLinearSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr_doubleArray>(0, 21);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                var ___ret = ___GetLinearSlopeValueDelegate(__Instance, values);
                return ___ret;
            }

            /// <summary>Set LinearSlope value.</summary>
            /// <remarks>You must call setLinSideBreakValue before calling this.</remarks>
            public override void SetLinearSlopeValue(double[] values)
            {
                var ___SetLinearSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doubleArray>(0, 22);
                if (values == null || values.Length != 3)
                    throw new ArgumentOutOfRangeException("values", "The dimensions of the provided array don't match the required size.");
                ___SetLinearSlopeValueDelegate(__Instance, values);
            }

            /// <summary>Remove LinearSlope values so that default values are used.</summary>
            public override void UnsetLinearSlopeValue()
            {
                var ___UnsetLinearSlopeValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 23);
                ___UnsetLinearSlopeValueDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override double Base
            {
                get
                {
                    var ___GetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 9);
                    var ___ret = ___GetBaseDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 10);
                    ___SetBaseDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class LogTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.LogTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal LogTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal LogTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.LogTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override double Base
            {
                get
                {
                    var ___GetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 9);
                    var ___ret = ___GetBaseDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetBaseDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 10);
                    ___SetBaseDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class Lut1DTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal Lut1DTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal Lut1DTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.Lut1DTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 10);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetValue(uint index, ref float r, ref float g, ref float b)
            {
                var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_floatPtr_floatPtr_floatPtr>(0, 13);
                fixed (float* __r1 = &r)
                {
                    var __arg1 = __r1;
                    fixed (float* __g2 = &g)
                    {
                        var __arg2 = __g2;
                        fixed (float* __b3 = &b)
                        {
                            var __arg3 = __b3;
                            ___GetValueDelegate(__Instance, index, __arg1, __arg2, __arg3);
                        }
                    }
                }
            }

            /// <summary>
            /// <para>Set the values of a LUT1D.  Will throw if the index</para>
            /// <para>is outside of the range from 0 to (length-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how</para>
            /// <para>the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The</para>
            /// <para>values here are unclamped and may extend outside [0,1].</para>
            /// <para>LUTs in various file formats may only provide values for one</para>
            /// <para>channel where R, G, B are the same. Even in that case, you should</para>
            /// <para>provide three equal values to the setter.</para>
            /// </remarks>
            public override void SetValue(uint index, float r, float g, float b)
            {
                var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_float_float_float>(0, 14);
                ___SetValueDelegate(__Instance, index, r, g, b);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get
                {
                    var ___GetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 6);
                    var ___ret = ___GetFileOutputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 7);
                    ___SetFileOutputBitDepthDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 8);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override uint Length
            {
                get
                {
                    var ___GetLengthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 11);
                    var ___ret = ___GetLengthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetLengthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint>(0, 12);
                    ___SetLengthDelegate(__Instance, value);
                }
            }

            public override bool InputHalfDomain
            {
                get
                {
                    var ___GetInputHalfDomainDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 15);
                    var ___ret = ___GetInputHalfDomainDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetInputHalfDomainDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 16);
                    ___SetInputHalfDomainDelegate(__Instance, value);
                }
            }

            public override bool OutputRawHalfs
            {
                get
                {
                    var ___GetOutputRawHalfsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 17);
                    var ___ret = ___GetOutputRawHalfsDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetOutputRawHalfsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 18);
                    ___SetOutputRawHalfsDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust HueAdjust
            {
                get
                {
                    var ___GetHueAdjustDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust___IntPtr>(0, 19);
                    var ___ret = ___GetHueAdjustDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetHueAdjustDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust>(0, 20);
                    ___SetHueAdjustDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.Interpolation Interpolation
            {
                get
                {
                    var ___GetInterpolationDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr>(0, 21);
                    var ___ret = ___GetInterpolationDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetInterpolationDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation>(0, 22);
                    ___SetInterpolationDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class Lut3DTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal Lut3DTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal Lut3DTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.Lut3DTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 10);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetValue(uint indexR, uint indexG, uint indexB, ref float r, ref float g, ref float b)
            {
                var ___GetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_uint_uint_floatPtr_floatPtr_floatPtr>(0, 13);
                fixed (float* __r3 = &r)
                {
                    var __arg3 = __r3;
                    fixed (float* __g4 = &g)
                    {
                        var __arg4 = __g4;
                        fixed (float* __b5 = &b)
                        {
                            var __arg5 = __b5;
                            ___GetValueDelegate(__Instance, indexR, indexG, indexB, __arg3, __arg4, __arg5);
                        }
                    }
                }
            }

            /// <summary>
            /// <para>Set the values of a 3D-LUT. Will throw if an index is</para>
            /// <para>outside of the range from 0 to (gridSize-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how the</para>
            /// <para>transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The values</para>
            /// <para>here are unclamped and may extend outside [0,1].</para>
            /// </remarks>
            public override void SetValue(uint indexR, uint indexG, uint indexB, float r, float g, float b)
            {
                var ___SetValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint_uint_uint_float_float_float>(0, 14);
                ___SetValueDelegate(__Instance, indexR, indexG, indexB, r, g, b);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get
                {
                    var ___GetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 6);
                    var ___ret = ___GetFileOutputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 7);
                    ___SetFileOutputBitDepthDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 8);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            public override uint GridSize
            {
                get
                {
                    var ___GetGridSizeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_uint___IntPtr>(0, 11);
                    var ___ret = ___GetGridSizeDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetGridSizeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_uint>(0, 12);
                    ___SetGridSizeDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.Interpolation Interpolation
            {
                get
                {
                    var ___GetInterpolationDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr>(0, 15);
                    var ___ret = ___GetInterpolationDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetInterpolationDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation>(0, 16);
                    ___SetInterpolationDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class MatrixTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal MatrixTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal MatrixTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this exactly equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.MatrixTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void GetMatrix(ref double m44)
            {
                var ___GetMatrixDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 9);
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    ___GetMatrixDelegate(__Instance, __arg0);
                }
            }

            /// <summary>
            /// <para>Get or set the values of a Matrix. Expects 16 values,</para>
            /// <para>where the first four are the coefficients to generate the R output</para>
            /// <para>channel from R, G, B, A input channels.</para>
            /// </summary>
            /// <remarks>
            /// <para>The Matrix values are always for the &quot;forward&quot; Matrix, regardless of</para>
            /// <para>how the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example in a CLF file using a &quot;32f&quot;</para>
            /// <para>input depth and &quot;10i&quot; output depth, a value of 1023 in the file</para>
            /// <para>is normalized to 1.0. The values here are unclamped and may</para>
            /// <para>extend outside [0,1].</para>
            /// </remarks>
            public override void SetMatrix(ref double m44)
            {
                var ___SetMatrixDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 10);
                fixed (double* __m440 = &m44)
                {
                    var __arg0 = __m440;
                    ___SetMatrixDelegate(__Instance, __arg0);
                }
            }

            public override void GetOffset(ref double offset4)
            {
                var ___GetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 11);
                fixed (double* __offset40 = &offset4)
                {
                    var __arg0 = __offset40;
                    ___GetOffsetDelegate(__Instance, __arg0);
                }
            }

            /// <summary>
            /// <para>Get or set the R, G, B, A offsets to be applied</para>
            /// <para>after the matrix.</para>
            /// </summary>
            /// <remarks>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example, in a CLF file using a</para>
            /// <para>&quot;10i&quot; output depth, a value of 1023 in the file is normalized</para>
            /// <para>to 1.0. The values here are unclamped and may extend</para>
            /// <para>outside [0,1].</para>
            /// </remarks>
            public override void SetOffset(ref double offset4)
            {
                var ___SetOffsetDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_doublePtr>(0, 12);
                fixed (double* __offset40 = &offset4)
                {
                    var __arg0 = __offset40;
                    ___SetOffsetDelegate(__Instance, __arg0);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 6);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the matrix values read from a</para>
            /// <para>file or set the bit-depths of values to be written to a file</para>
            /// <para>(for file formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            /// <remarks>
            /// <para>In a format such as CLF, the matrix values are scaled to take</para>
            /// <para>pixels at the specified inBitDepth to pixels at the specified</para>
            /// <para>outBitDepth.  This complicates the interpretation of the matrix</para>
            /// <para>values and so this object always holds normalized values and</para>
            /// <para>scaling is done on the way from or to file formats such as CLF.</para>
            /// </remarks>
            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileInputBitDepth
            {
                get
                {
                    var ___GetFileInputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 13);
                    var ___ret = ___GetFileInputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileInputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 14);
                    ___SetFileInputBitDepthDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get
                {
                    var ___GetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 15);
                    var ___ret = ___GetFileOutputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 16);
                    ___SetFileOutputBitDepthDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class RangeTransformInternal : global::OpenColorIO.OpenColorIO_v2_4.RangeTransform, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal RangeTransformInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal RangeTransformInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Checks if this equals other.</summary>
            public override bool Equals(global::OpenColorIO.OpenColorIO_v2_4.RangeTransform other)
            {
                var ___EqualsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr___IntPtr>(0, 10);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var ___ret = ___EqualsDelegate(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Unset the minimum value for the input</summary>
            public override void UnsetMinInValue()
            {
                var ___UnsetMinInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 18);
                ___UnsetMinInValueDelegate(__Instance);
            }

            /// <summary>Unset the maximum value for the input.</summary>
            public override void UnsetMaxInValue()
            {
                var ___UnsetMaxInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 22);
                ___UnsetMaxInValueDelegate(__Instance);
            }

            /// <summary>Unset the minimum value for the output.</summary>
            public override void UnsetMinOutValue()
            {
                var ___UnsetMinOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 26);
                ___UnsetMinOutValueDelegate(__Instance);
            }

            /// <summary>Unset the maximum value for the output.</summary>
            public override void UnsetMaxOutValue()
            {
                var ___UnsetMaxOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 30);
                ___UnsetMaxOutValueDelegate(__Instance);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.RangeStyle Style
            {
                get
                {
                    var ___GetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_RangeStyle___IntPtr>(0, 6);
                    var ___ret = ___GetStyleDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetStyleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RangeStyle>(0, 7);
                    ___SetStyleDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata FormatMetadata
            {
                get
                {
                    var ___GetFormatMetadataDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 8);
                    var ___ret = ___GetFormatMetadataDelegate(__Instance);
                    var __result0 = global::OpenColorIO.OpenColorIO_v2_4.FormatMetadata.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the range values read from a file</para>
            /// <para>or set the bit-depths of values to be written to a file (for file</para>
            /// <para>formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileInputBitDepth
            {
                get
                {
                    var ___GetFileInputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 11);
                    var ___ret = ___GetFileInputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileInputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 12);
                    ___SetFileInputBitDepthDelegate(__Instance, value);
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.BitDepth FileOutputBitDepth
            {
                get
                {
                    var ___GetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr>(0, 13);
                    var ___ret = ___GetFileOutputBitDepthDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetFileOutputBitDepthDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth>(0, 14);
                    ___SetFileOutputBitDepthDelegate(__Instance, value);
                }
            }

            /// <summary>Get the minimum value for the input.</summary>
            /// <remarks>Set the minimum value for the input.</remarks>
            public override double MinInValue
            {
                get
                {
                    var ___GetMinInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 15);
                    var ___ret = ___GetMinInValueDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetMinInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 16);
                    ___SetMinInValueDelegate(__Instance, value);
                }
            }

            /// <summary>Is the minimum value for the input set?</summary>
            public override bool HasMinInValue
            {
                get
                {
                    var ___HasMinInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 17);
                    var ___ret = ___HasMinInValueDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the maximum value for the input.</summary>
            /// <remarks>Set the maximum value for the input.</remarks>
            public override double MaxInValue
            {
                get
                {
                    var ___GetMaxInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 20);
                    var ___ret = ___GetMaxInValueDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetMaxInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 19);
                    ___SetMaxInValueDelegate(__Instance, value);
                }
            }

            /// <summary>Is the maximum value for the input set?</summary>
            public override bool HasMaxInValue
            {
                get
                {
                    var ___HasMaxInValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 21);
                    var ___ret = ___HasMaxInValueDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the minimum value for the output.</summary>
            /// <remarks>Set the minimum value for the output.</remarks>
            public override double MinOutValue
            {
                get
                {
                    var ___GetMinOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 24);
                    var ___ret = ___GetMinOutValueDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetMinOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 23);
                    ___SetMinOutValueDelegate(__Instance, value);
                }
            }

            /// <summary>Is the minimum value for the output set?</summary>
            public override bool HasMinOutValue
            {
                get
                {
                    var ___HasMinOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 25);
                    var ___ret = ___HasMinOutValueDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the maximum value for the output.</summary>
            /// <remarks>Set the maximum value for the output.</remarks>
            public override double MaxOutValue
            {
                get
                {
                    var ___GetMaxOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_double___IntPtr>(0, 28);
                    var ___ret = ___GetMaxOutValueDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetMaxOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_double>(0, 27);
                    ___SetMaxOutValueDelegate(__Instance, value);
                }
            }

            /// <summary>Is the maximum value for the output set?</summary>
            public override bool HasMaxOutValue
            {
                get
                {
                    var ___HasMaxOutValueDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 29);
                    var ___ret = ___HasMaxOutValueDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Direction
            {
                get
                {
                    var ___GetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr>(0, 1);
                    var ___ret = ___GetDirectionDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetDirectionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection>(0, 2);
                    ___SetDirectionDelegate(__Instance, value);
                }
            }
        }
    }

    namespace OpenColorIO_v2_4
    {
        /// <summary>Parameters controlling which color spaces appear in menus.</summary>
        /// <remarks>
        /// <para>The ColorSpaceMenuHelper class is intended to be used by applications to get the list of items</para>
        /// <para>to show in color space menus.</para>
        /// <para>The ColorSpaceMenuParameters class is used to configure the behavior as needed for any given</para>
        /// <para>menu.  Here is the algorithm used to produce a list of &quot;items&quot; (or strings) that will appear in</para>
        /// <para>a menu:</para>
        /// <para>1)  Use setRole to identify a role that controls a given menu.  If the config has this role,</para>
        /// <para>then only that color space is returned.  The name is set to the color space name, the UIName</para>
        /// <para>is presented as &quot;&lt;role name&gt; (&lt;color space name&gt;)&quot;. It may be useful for the application to</para>
        /// <para>then grey-out the menu or otherwise indicate to the user that the value for this menu is not</para>
        /// <para>user selectable since it was pre-determined by the config.  If the config does not have that</para>
        /// <para>role, the algorithm continues to the remaining steps.</para>
        /// <para>2)  The IncludeColorSpaces, SearchReferenceSpaceType, and IncludeNamedTransforms parameters are</para>
        /// <para>used to identify a set of items from the config that are potential candidates for use in the</para>
        /// <para>menu, as follows:</para>
        /// <para>- IncludeColorSpaces: Set to true to include color spaces in the menu.</para>
        /// <para>- SearchReferenceSpaceType: Use this to control whether the menu should include all color</para>
        /// <para>spaces, only display color spaces, or only non-display color spaces.</para>
        /// <para>- IncludeNamedTransforms: Set to true to include named transforms in the menu.</para>
        /// <para>3)  The set of items from step 2 is then filtered in step 3 using the following parameters:</para>
        /// <para>- AppCategories: A list of strings specified by the application based on the purpose of</para>
        /// <para>the menu.  For example, if the menu is used to select a color space for importing an</para>
        /// <para>image, the application might specify the 'file-io' category, whereas if it is to select</para>
        /// <para>a working color space, it might specify the 'working-space' category.  Application</para>
        /// <para>developers should document what strings they are using for each menu so that config</para>
        /// <para>authors know what categories to use in their configs.  Alternatively, an application</para>
        /// <para>could let advanced users customize the string to use for a given menu in the</para>
        /// <para>application.</para>
        /// <para>- Encodings: A list of strings used to further refine the items selected from the</para>
        /// <para>AppCategories.  For example, an application might specify 'working-space' as the</para>
        /// <para>category and then specify 'scene-linear' as the encoding to only use items that have</para>
        /// <para>both of those properties (e.g., only select scene-linear working color spaces).</para>
        /// <para>- UserCategories: A list of strings specified by the end-user of the application.  OCIO</para>
        /// <para>will check for these strings in an environment variable, or they may be passed in from</para>
        /// <para>the application.</para>
        /// <para>Basically the intent is for the filtering to return the intersection of the app categories,</para>
        /// <para>encoding, and user categories.  However, some fall-backs are in place to ensure that the</para>
        /// <para>filtering does not remove all menu items.  Here is the detailed description:</para>
        /// <para>3a) The items from step 2 are filtered to generate a list of appItems containing only the ones</para>
        /// <para>that contain at least one of the AppCategories strings in their &quot;categories&quot; property and</para>
        /// <para>one of the encodings in their &quot;encoding&quot; property.   If this list is empty, an attempt is</para>
        /// <para>made to generate a non-empty appItems list by only filtering by AppCategories.  If that is</para>
        /// <para>empty, an attempt is made to only filter by Encodings.</para>
        /// <para>3b) The items from step 2 are filtered to generate a list of userItems containing only the ones</para>
        /// <para>that have at least one of the UserCategories strings in their &quot;categories&quot; property.</para>
        /// <para>3c) If both appItems and userItems are non-empty, a list of resultItems will be generated as</para>
        /// <para>the intersection of those two lists.</para>
        /// <para>3d) If the resultItems list is empty, the appList will be expanded by only filtering by</para>
        /// <para>AppCategories and not encodings.  The resultItems will be formed again as the intersection</para>
        /// <para>of the appItems and userItems.</para>
        /// <para>3e) If the resultItems is still empty, it will be set to just the appItems from step 3a.</para>
        /// <para>3f) If the resultItems is still empty, it will be set to just the userItems.</para>
        /// <para>3g) If the resultItems is still empty, the items are not filtered and all items from step 2 are</para>
        /// <para>returned.  The rationale is that if step 2 has produced any items, it is not acceptable for</para>
        /// <para>step 3 to remove all of them.  An application usually expects to have a non-zero number of</para>
        /// <para>items to display in the menu.  However, if step 2 produces no items (e.g. the application</para>
        /// <para>requests only named transforms and the config has no named transform), then no items will</para>
        /// <para>be returned.</para>
        /// <para>4)  If IncludeRoles is true, the items from step 3 are extended by including an item for each</para>
        /// <para>role.  The name is set to the role name, the UIName is presented as &quot;name&gt; (</para>
        /// <para>space name&gt;)&quot;, and the family is set to &quot;Roles&quot;.</para>
        /// <para>5)  If AddColorSpace has been used to add any additional items, these are appended to the final</para>
        /// <para>list.</para>
        /// </remarks>
        public unsafe abstract partial class ColorSpaceMenuParameters : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_ColorSpaceMenuParameters;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ColorSpaceMenuParameters@OpenColorIO_v2_4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ColorSpaceMenuParameters@OpenColorIO_v2_4@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ColorSpaceMenuParameters __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ColorSpaceMenuParametersInternal(native.ToPointer(), skipVTables);
            }

            internal static ColorSpaceMenuParameters __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ColorSpaceMenuParameters)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ColorSpaceMenuParameters __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ColorSpaceMenuParameters)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ColorSpaceMenuParameters __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ColorSpaceMenuParametersInternal(native, skipVTables);
            }

            protected ColorSpaceMenuParameters(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ColorSpaceMenuParameters()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters");
            }

            protected ColorSpaceMenuParameters(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Add an additional color space (or named transform) to the menu.</summary>
            /// <remarks>
            /// <para>Note that an additional color space could be:</para>
            /// <para>* an inactive color space,</para>
            /// <para>* an active color space not having at least one of the selected categories,</para>
            /// <para>* a newly created color space.</para>
            /// <para>Will throw when creating the menu if color space is not part of the config. Nothing is done</para>
            /// <para>if it is already part of the menu.</para>
            /// <para>It's ok to call this multiple times with the same color space, it will only be added to the</para>
            /// <para>menu once.  If a role name is passed in, the name in the menu will be the color space name</para>
            /// <para>the role points to.</para>
            /// </remarks>
            public abstract void AddColorSpace(string name);

            public abstract string GetAddedColorSpace(ulong index);

            public abstract void ClearAddedColorSpaces();

            public abstract string Role
            {
                get;

                set;
            }

            public abstract bool IncludeColorSpaces
            {
                get;

                set;
            }

            /// <summary>
            /// <para>Can be used to restrict the search using the ReferenceSpaceType of the color spaces.</para>
            /// <para>It has no effect on roles and named transforms.</para>
            /// </summary>
            public abstract global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType SearchReferenceSpaceType
            {
                get;

                set;
            }

            public abstract bool IncludeNamedTransforms
            {
                get;

                set;
            }

            public abstract string AppCategories
            {
                get;

                set;
            }

            public abstract string Encodings
            {
                get;

                set;
            }

            public abstract string UserCategories
            {
                get;

                set;
            }

            public abstract bool IncludeRoles
            {
                get;

                set;
            }

            public abstract ulong NumAddedColorSpaces
            {
                get;
            }

            #region Virtual table interop

            // void setRole(const char * role) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetRoleDelegateInstance;

            private static void _SetRoleDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string role)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.Role = role;
            }

            // char * getRole() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetRoleDelegateInstance;

            private static __IntPtr _GetRoleDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.Role;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setIncludeColorSpaces(bool include) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetIncludeColorSpacesDelegateInstance;

            private static void _SetIncludeColorSpacesDelegateHook(__IntPtr __instance, bool include)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.IncludeColorSpaces = include;
            }

            // bool getIncludeColorSpaces() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetIncludeColorSpacesDelegateInstance;

            private static bool _GetIncludeColorSpacesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.IncludeColorSpaces;
                return ___ret;
            }

            // SearchReferenceSpaceType getSearchReferenceSpaceType() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType___IntPtr _GetSearchReferenceSpaceTypeDelegateInstance;

            private static global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType _GetSearchReferenceSpaceTypeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.SearchReferenceSpaceType;
                return ___ret;
            }

            // void setSearchReferenceSpaceType(SearchReferenceSpaceType colorSpaceType) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType _SetSearchReferenceSpaceTypeDelegateInstance;

            private static void _SetSearchReferenceSpaceTypeDelegateHook(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType colorSpaceType)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.SearchReferenceSpaceType = colorSpaceType;
            }

            // void setIncludeNamedTransforms(bool include) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetIncludeNamedTransformsDelegateInstance;

            private static void _SetIncludeNamedTransformsDelegateHook(__IntPtr __instance, bool include)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.IncludeNamedTransforms = include;
            }

            // bool getIncludeNamedTransforms() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetIncludeNamedTransformsDelegateInstance;

            private static bool _GetIncludeNamedTransformsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.IncludeNamedTransforms;
                return ___ret;
            }

            // void setAppCategories(const char * appCategories) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetAppCategoriesDelegateInstance;

            private static void _SetAppCategoriesDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string appCategories)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.AppCategories = appCategories;
            }

            // char * getAppCategories() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetAppCategoriesDelegateInstance;

            private static __IntPtr _GetAppCategoriesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.AppCategories;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setEncodings(const char * encodings) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetEncodingsDelegateInstance;

            private static void _SetEncodingsDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string encodings)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.Encodings = encodings;
            }

            // char * getEncodings() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetEncodingsDelegateInstance;

            private static __IntPtr _GetEncodingsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.Encodings;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setUserCategories(const char * userCategories) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetUserCategoriesDelegateInstance;

            private static void _SetUserCategoriesDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string userCategories)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.UserCategories = userCategories;
            }

            // char * getUserCategories() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetUserCategoriesDelegateInstance;

            private static __IntPtr _GetUserCategoriesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.UserCategories;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void setIncludeRoles(bool include) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetIncludeRolesDelegateInstance;

            private static void _SetIncludeRolesDelegateHook(__IntPtr __instance, bool include)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.IncludeRoles = include;
            }

            // bool getIncludeRoles() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetIncludeRolesDelegateInstance;

            private static bool _GetIncludeRolesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.IncludeRoles;
                return ___ret;
            }

            // void addColorSpace(const char * name) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _AddColorSpaceDelegateInstance;

            private static void _AddColorSpaceDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.AddColorSpace(name);
            }

            // size_t getNumAddedColorSpaces() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumAddedColorSpacesDelegateInstance;

            private static ulong _GetNumAddedColorSpacesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.NumAddedColorSpaces;
                return ___ret;
            }

            // char * getAddedColorSpace(size_t index) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetAddedColorSpaceDelegateInstance;

            private static __IntPtr _GetAddedColorSpaceDelegateHook(__IntPtr __instance, ulong index)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                var ___ret = __target.GetAddedColorSpace(index);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // void clearAddedColorSpaces() noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr _ClearAddedColorSpacesDelegateInstance;

            private static void _ClearAddedColorSpacesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.ClearAddedColorSpaces();
            }

            // virtual ~ColorSpaceMenuParameters() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[21];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _SetRoleDelegateInstance += _SetRoleDelegateHook;
                    _GetRoleDelegateInstance += _GetRoleDelegateHook;
                    _SetIncludeColorSpacesDelegateInstance += _SetIncludeColorSpacesDelegateHook;
                    _GetIncludeColorSpacesDelegateInstance += _GetIncludeColorSpacesDelegateHook;
                    _GetSearchReferenceSpaceTypeDelegateInstance += _GetSearchReferenceSpaceTypeDelegateHook;
                    _SetSearchReferenceSpaceTypeDelegateInstance += _SetSearchReferenceSpaceTypeDelegateHook;
                    _SetIncludeNamedTransformsDelegateInstance += _SetIncludeNamedTransformsDelegateHook;
                    _GetIncludeNamedTransformsDelegateInstance += _GetIncludeNamedTransformsDelegateHook;
                    _SetAppCategoriesDelegateInstance += _SetAppCategoriesDelegateHook;
                    _GetAppCategoriesDelegateInstance += _GetAppCategoriesDelegateHook;
                    _SetEncodingsDelegateInstance += _SetEncodingsDelegateHook;
                    _GetEncodingsDelegateInstance += _GetEncodingsDelegateHook;
                    _SetUserCategoriesDelegateInstance += _SetUserCategoriesDelegateHook;
                    _GetUserCategoriesDelegateInstance += _GetUserCategoriesDelegateHook;
                    _SetIncludeRolesDelegateInstance += _SetIncludeRolesDelegateHook;
                    _GetIncludeRolesDelegateInstance += _GetIncludeRolesDelegateHook;
                    _AddColorSpaceDelegateInstance += _AddColorSpaceDelegateHook;
                    _GetNumAddedColorSpacesDelegateInstance += _GetNumAddedColorSpacesDelegateHook;
                    _GetAddedColorSpaceDelegateInstance += _GetAddedColorSpaceDelegateHook;
                    _ClearAddedColorSpacesDelegateInstance += _ClearAddedColorSpacesDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetRoleDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetRoleDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetIncludeColorSpacesDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetIncludeColorSpacesDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetSearchReferenceSpaceTypeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_SetSearchReferenceSpaceTypeDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetIncludeNamedTransformsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetIncludeNamedTransformsDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetAppCategoriesDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetAppCategoriesDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetEncodingsDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetEncodingsDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SetUserCategoriesDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetUserCategoriesDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_SetIncludeRolesDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetIncludeRolesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_AddColorSpaceDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetNumAddedColorSpacesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetAddedColorSpaceDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_ClearAddedColorSpacesDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTablesDtorOnly[0][22] = Thunks[20];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 23, 0);
                                ManagedVTables[0][2] = Thunks[0];
                                ManagedVTables[0][3] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                ManagedVTables[0][5] = Thunks[3];
                                ManagedVTables[0][6] = Thunks[4];
                                ManagedVTables[0][7] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                ManagedVTables[0][16] = Thunks[14];
                                ManagedVTables[0][17] = Thunks[15];
                                ManagedVTables[0][18] = Thunks[16];
                                ManagedVTables[0][19] = Thunks[17];
                                ManagedVTables[0][20] = Thunks[18];
                                ManagedVTables[0][21] = Thunks[19];
                                ManagedVTables[0][22] = Thunks[20];
                                VTables.Methods[0] = new Delegate[23];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Helper class to create menus for the content of a config.</summary>
        /// <remarks>
        /// <para>Menu can list color spaces, roles, named transforms. Each entry has a name, a UI name, a</para>
        /// <para>description, and a family. Family can also be accessed as hierarchy levels; levels are created</para>
        /// <para>by splitting the family using the 'family separator'. Hierarchy levels are meant to be used as</para>
        /// <para>sub-menus.</para>
        /// <para>The UI name is what is intended to be put in application menus seen by the end-user.   However,</para>
        /// <para>please note that the UI name is not guaranteed to remain stable between releases and so if</para>
        /// <para>applications need to save something it should be the 'name' rather than the 'UI name'.</para>
        /// <para>Currently, the only difference between the 'name' and 'UI name' is for roles.</para>
        /// <para>The overall ordering of items is: color spaces, named transforms, roles, and additional color</para>
        /// <para>spaces.  The display color spaces will either come before or after the other color spaces based</para>
        /// <para>on where that block of spaces appears in the config.  The order of items returned by the menu</para>
        /// <para>helper preserves the order of items in the config itself for each type of elements, thus</para>
        /// <para>preserving the intent of the config author.  For example, if you call getName at idx</para>
        /// <para>and idx+1, the name returned at idx+1 will be from farther down in the config than the one at</para>
        /// <para>idx as long as both are of the same type.  (An application may ask for only the items in one</para>
        /// <para>of those blocks if it wants to handle them separately.)  If the application makes use of</para>
        /// <para>hierarchical menus, that will obviously impose a different order on what the user sees in the</para>
        /// <para>menu.  Though even with  hierarchical menus, applications should try to preserve config ordering</para>
        /// <para>(which is equivalent to index ordering) for items within the same sub-menu.</para>
        /// </remarks>
        public unsafe abstract partial class ColorSpaceMenuHelper : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_ColorSpaceMenuHelper;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0ColorSpaceMenuHelper@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ColorSpaceMenuHelper __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ColorSpaceMenuHelperInternal(native.ToPointer(), skipVTables);
            }

            internal static ColorSpaceMenuHelper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ColorSpaceMenuHelper)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ColorSpaceMenuHelper __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ColorSpaceMenuHelper)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ColorSpaceMenuHelper __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ColorSpaceMenuHelperInternal(native, skipVTables);
            }

            protected ColorSpaceMenuHelper(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected ColorSpaceMenuHelper()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get the color space (or role) name used in the config for this menu item.  Will be empty</para>
            /// <para>if the index is out of range.</para>
            /// </summary>
            public abstract string GetName(ulong idx);

            /// <summary>
            /// <para>Get the name to use in the menu UI.  This might be different from the config name, for</para>
            /// <para>example in the case of roles.  Will be empty if the index is out of range.</para>
            /// </summary>
            public abstract string GetUIName(ulong idx);

            /// <summary>
            /// <para>Get the index of the element of a given name. Return (size_t)-1 name if NULL or empty, or if</para>
            /// <para>no element with that name is found.</para>
            /// </summary>
            public abstract ulong GetIndexFromName(string name);

            public abstract ulong GetIndexFromUIName(string name);

            public abstract string GetDescription(ulong idx);

            public abstract string GetFamily(ulong idx);

            /// <summary>
            /// <para>Hierarchy levels are created from the family string. It is split into levels using the</para>
            /// <para>'family separator'.</para>
            /// </summary>
            public abstract ulong GetNumHierarchyLevels(ulong idx);

            public abstract string GetHierarchyLevel(ulong idx, ulong i);

            /// <summary>Get the color space name from the UI name.</summary>
            public abstract string GetNameFromUIName(string uiName);

            /// <summary>Get the color space UI name from the name.</summary>
            public abstract string GetUINameFromName(string name);

            /// <summary>Access to the color spaces (or roles).</summary>
            public abstract ulong NumColorSpaces
            {
                get;
            }

            #region Virtual table interop

            // size_t getNumColorSpaces() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumColorSpacesDelegateInstance;

            private static ulong _GetNumColorSpacesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.NumColorSpaces;
                return ___ret;
            }

            // char * getName(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetNameDelegateInstance;

            private static __IntPtr _GetNameDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetName(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getUIName(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetUINameDelegateInstance;

            private static __IntPtr _GetUINameDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetUIName(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // size_t getIndexFromName(const char * name) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr_string8 _GetIndexFromNameDelegateInstance;

            private static ulong _GetIndexFromNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetIndexFromName(name);
                return ___ret;
            }

            // size_t getIndexFromUIName(const char * name) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr_string8 _GetIndexFromUINameDelegateInstance;

            private static ulong _GetIndexFromUINameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetIndexFromUIName(name);
                return ___ret;
            }

            // char * getDescription(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetDescriptionDelegateInstance;

            private static __IntPtr _GetDescriptionDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetDescription(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getFamily(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetFamilyDelegateInstance;

            private static __IntPtr _GetFamilyDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetFamily(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // size_t getNumHierarchyLevels(size_t idx) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr_ulong _GetNumHierarchyLevelsDelegateInstance;

            private static ulong _GetNumHierarchyLevelsDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetNumHierarchyLevels(idx);
                return ___ret;
            }

            // char * getHierarchyLevel(size_t idx, size_t i) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong_ulong _GetHierarchyLevelDelegateInstance;

            private static __IntPtr _GetHierarchyLevelDelegateHook(__IntPtr __instance, ulong idx, ulong i)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetHierarchyLevel(idx, i);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getNameFromUIName(const char * uiName) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8 _GetNameFromUINameDelegateInstance;

            private static __IntPtr _GetNameFromUINameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uiName)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetNameFromUIName(uiName);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // char * getUINameFromName(const char * name) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8 _GetUINameFromNameDelegateInstance;

            private static __IntPtr _GetUINameFromNameDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                var ___ret = __target.GetUINameFromName(name);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // virtual ~ColorSpaceMenuHelper() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNumColorSpacesDelegateInstance += _GetNumColorSpacesDelegateHook;
                    _GetNameDelegateInstance += _GetNameDelegateHook;
                    _GetUINameDelegateInstance += _GetUINameDelegateHook;
                    _GetIndexFromNameDelegateInstance += _GetIndexFromNameDelegateHook;
                    _GetIndexFromUINameDelegateInstance += _GetIndexFromUINameDelegateHook;
                    _GetDescriptionDelegateInstance += _GetDescriptionDelegateHook;
                    _GetFamilyDelegateInstance += _GetFamilyDelegateHook;
                    _GetNumHierarchyLevelsDelegateInstance += _GetNumHierarchyLevelsDelegateHook;
                    _GetHierarchyLevelDelegateInstance += _GetHierarchyLevelDelegateHook;
                    _GetNameFromUINameDelegateInstance += _GetNameFromUINameDelegateHook;
                    _GetUINameFromNameDelegateInstance += _GetUINameFromNameDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNumColorSpacesDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetUINameDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetIndexFromNameDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetIndexFromUINameDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetDescriptionDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetFamilyDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetNumHierarchyLevelsDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetHierarchyLevelDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetNameFromUINameDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetUINameFromNameDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTablesDtorOnly[0][11] = Thunks[11];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                VTables.Methods[0] = new Delegate[12];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>Whereas the DisplayViewTransform simply applies a specific view from an OCIO display, the</para>
        /// <para>LegacyViewingPipeline provides an example of a complete viewing pipeline of the sort that could</para>
        /// <para>be used to implement a viewport in a typical application.  It therefore adds, around the</para>
        /// <para>DisplayViewTransform, various optional color correction steps and RGBA channel view swizzling.</para>
        /// <para>The direction of the DisplayViewTranform is used as the direction of the pipeline.</para>
        /// <para>Note: The LegacyViewingPipeline class provides the same functionality as the OCIO v1</para>
        /// <para>DisplayTransform.</para>
        /// </summary>
        /// <remarks>
        /// <para>Legacy viewing pipeline:</para>
        /// <para>* Start in display transform input color space.</para>
        /// <para>* If linearCC is provided:</para>
        /// <para>* Go to scene_linear colorspace.</para>
        /// <para>* Apply linearCC transform.</para>
        /// <para>* If colorTimingCC is provided:</para>
        /// <para>* Go to color_timing colorspace.</para>
        /// <para>* Apply colorTimingCC transform.</para>
        /// <para>* Apply looks (from display transform or from looks override).</para>
        /// <para>* Go to first look color space.</para>
        /// <para>* Apply first look transform.</para>
        /// <para>* Iterate for all looks.</para>
        /// <para>* Apply channelView transform.</para>
        /// <para>* Apply display transform (without looks).</para>
        /// <para>* Apply displayCC.</para>
        /// <para>Note that looks are applied even if the display transform involves data color spaces.</para>
        /// </remarks>
        public unsafe abstract partial class LegacyViewingPipeline : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_LegacyViewingPipeline;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0LegacyViewingPipeline@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static LegacyViewingPipeline __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LegacyViewingPipelineInternal(native.ToPointer(), skipVTables);
            }

            internal static LegacyViewingPipeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LegacyViewingPipeline)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static LegacyViewingPipeline __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LegacyViewingPipeline)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LegacyViewingPipeline __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LegacyViewingPipelineInternal(native, skipVTables);
            }

            protected LegacyViewingPipeline(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected LegacyViewingPipeline()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract bool LooksOverrideEnabled
            {
                get;

                set;
            }

            public abstract string LooksOverride
            {
                get;

                set;
            }

            #region Virtual table interop

            // void setLooksOverrideEnabled(bool enable) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_bool _SetLooksOverrideEnabledDelegateInstance;

            private static void _SetLooksOverrideEnabledDelegateHook(__IntPtr __instance, bool enable)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__GetInstance(__instance);
                __target.LooksOverrideEnabled = enable;
            }

            // bool getLooksOverrideEnabled() const = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _GetLooksOverrideEnabledDelegateInstance;

            private static bool _GetLooksOverrideEnabledDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__GetInstance(__instance);
                var ___ret = __target.LooksOverrideEnabled;
                return ___ret;
            }

            // void setLooksOverride(const char * looks) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetLooksOverrideDelegateInstance;

            private static void _SetLooksOverrideDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string looks)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__GetInstance(__instance);
                __target.LooksOverride = looks;
            }

            // char * getLooksOverride() const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetLooksOverrideDelegateInstance;

            private static __IntPtr _GetLooksOverrideDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__GetInstance(__instance);
                var ___ret = __target.LooksOverride;
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // virtual ~LegacyViewingPipeline() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[5];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _SetLooksOverrideEnabledDelegateInstance += _SetLooksOverrideEnabledDelegateHook;
                    _GetLooksOverrideEnabledDelegateInstance += _GetLooksOverrideEnabledDelegateHook;
                    _SetLooksOverrideDelegateInstance += _SetLooksOverrideDelegateHook;
                    _GetLooksOverrideDelegateInstance += _GetLooksOverrideDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetLooksOverrideEnabledDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetLooksOverrideEnabledDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetLooksOverrideDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetLooksOverrideDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTablesDtorOnly[0][16] = Thunks[4];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 17, 0);
                                ManagedVTables[0][10] = Thunks[0];
                                ManagedVTables[0][11] = Thunks[1];
                                ManagedVTables[0][12] = Thunks[2];
                                ManagedVTables[0][13] = Thunks[3];
                                ManagedVTables[0][16] = Thunks[4];
                                VTables.Methods[0] = new Delegate[17];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>The MixingSlider and MixingColorSpaceManager classes are to help applications implement correct</para>
        /// <para>color pickers.  The term &quot;color mixing&quot; is used here to describe what is done in a typical</para>
        /// <para>application &quot;color picker&quot; user interface.</para>
        /// </summary>
        /// <remarks>
        /// <para>A user may want to mix colors in different color spaces.  The two most common mixing space</para>
        /// <para>options are a scene-linear working space or the display space.</para>
        /// <para>Since scene-linear color spaces are not perceptually uniform, it is necessary to compensate UI</para>
        /// <para>widgets such as sliders.  For example, it is nice if mid-gray falls near the center of mixing</para>
        /// <para>controls rather than way over near the black end.  This may be done by using a mapping from</para>
        /// <para>linear into an approximately perceptually uniform space.</para>
        /// <para>Also note that a color picking/mixing UI may want to present a given color space in several</para>
        /// <para>different encodings.  The most common two encodings for color mixing are RGB and HSV.</para>
        /// <para>Note that these helpers anticipate that a user may want to mix colors using values that extend</para>
        /// <para>outside the typical [0,1] domain.</para>
        /// </remarks>
        public unsafe abstract partial class MixingSlider : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_MixingSlider;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0MixingSlider@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.MixingSlider> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.MixingSlider>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.MixingSlider managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.MixingSlider managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixingSlider __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixingSliderInternal(native.ToPointer(), skipVTables);
            }

            internal static MixingSlider __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixingSlider)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixingSlider __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixingSlider)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixingSlider __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MixingSliderInternal(native, skipVTables);
            }

            protected MixingSlider(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected MixingSlider()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.MixingSlider");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Convert from units in distance along the slider to mixing space units.</summary>
            public abstract float SliderToMixing(float sliderUnits);

            /// <summary>Convert from mixing space units to distance along the slider.</summary>
            public abstract float MixingToSlider(float mixingUnits);

            /// <summary>Minimum edge of a UI slider for conversion to mixing space.</summary>
            /// <remarks>Set the minimum edge of a UI slider for conversion to mixing space.</remarks>
            public abstract float SliderMinEdge
            {
                get;

                set;
            }

            /// <summary>Maximum edge of a UI slider for conversion to mixing space.</summary>
            /// <remarks>Set the maximum edge of a UI slider for conversion to mixing space.</remarks>
            public abstract float SliderMaxEdge
            {
                get;

                set;
            }

            #region Virtual table interop

            // void setSliderMinEdge(float sliderMixingMinEdge) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_float _SetSliderMinEdgeDelegateInstance;

            private static void _SetSliderMinEdgeDelegateHook(__IntPtr __instance, float sliderMixingMinEdge)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                __target.SliderMinEdge = sliderMixingMinEdge;
            }

            // float getSliderMinEdge() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr _GetSliderMinEdgeDelegateInstance;

            private static float _GetSliderMinEdgeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                var ___ret = __target.SliderMinEdge;
                return ___ret;
            }

            // void setSliderMaxEdge(float sliderMixingMaxEdge) noexcept = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_float _SetSliderMaxEdgeDelegateInstance;

            private static void _SetSliderMaxEdgeDelegateHook(__IntPtr __instance, float sliderMixingMaxEdge)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                __target.SliderMaxEdge = sliderMixingMaxEdge;
            }

            // float getSliderMaxEdge() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr _GetSliderMaxEdgeDelegateInstance;

            private static float _GetSliderMaxEdgeDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                var ___ret = __target.SliderMaxEdge;
                return ___ret;
            }

            // float sliderToMixing(float sliderUnits) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr_float _SliderToMixingDelegateInstance;

            private static float _SliderToMixingDelegateHook(__IntPtr __instance, float sliderUnits)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                var ___ret = __target.SliderToMixing(sliderUnits);
                return ___ret;
            }

            // float mixingToSlider(float mixingUnits) const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_float___IntPtr_float _MixingToSliderDelegateInstance;

            private static float _MixingToSliderDelegateHook(__IntPtr __instance, float mixingUnits)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                var ___ret = __target.MixingToSlider(mixingUnits);
                return ___ret;
            }

            // virtual ~MixingSlider() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _SetSliderMinEdgeDelegateInstance += _SetSliderMinEdgeDelegateHook;
                    _GetSliderMinEdgeDelegateInstance += _GetSliderMinEdgeDelegateHook;
                    _SetSliderMaxEdgeDelegateInstance += _SetSliderMaxEdgeDelegateHook;
                    _GetSliderMaxEdgeDelegateInstance += _GetSliderMaxEdgeDelegateHook;
                    _SliderToMixingDelegateInstance += _SliderToMixingDelegateHook;
                    _MixingToSliderDelegateInstance += _MixingToSliderDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetSliderMinEdgeDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetSliderMinEdgeDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetSliderMaxEdgeDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSliderMaxEdgeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SliderToMixingDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_MixingToSliderDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][6] = Thunks[6];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Used to mix (or pick/choose) colors.</summary>
        public unsafe abstract partial class MixingColorSpaceManager : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_MixingColorSpaceManager;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenColorIO", EntryPoint = "??0MixingColorSpaceManager@OpenColorIO_v2_4@@IEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixingColorSpaceManager __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixingColorSpaceManagerInternal(native.ToPointer(), skipVTables);
            }

            internal static MixingColorSpaceManager __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixingColorSpaceManager)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixingColorSpaceManager __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixingColorSpaceManager)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixingColorSpaceManager __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MixingColorSpaceManagerInternal(native, skipVTables);
            }

            protected MixingColorSpaceManager(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected MixingColorSpaceManager()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract string GetMixingSpaceUIName(ulong idx);

            public abstract void SetSelectedMixingSpace(string mixingSpace);

            public abstract string GetMixingEncodingName(ulong idx);

            public abstract void SetSelectedMixingEncoding(string mixingEncoding);

            public abstract global::OpenColorIO.OpenColorIO_v2_4.MixingSlider GetSlider();

            public abstract global::OpenColorIO.OpenColorIO_v2_4.MixingSlider GetSlider(float sliderMixingMinEdge, float sliderMixingMaxEdge);

            /// <summary>Access to the mixing spaces.</summary>
            public abstract ulong NumMixingSpaces
            {
                get;
            }

            public abstract ulong SelectedMixingSpaceIdx
            {
                get;

                set;
            }

            public abstract bool IsPerceptuallyUniform
            {
                get;
            }

            /// <summary>Access to the mixing encodings.</summary>
            public abstract ulong NumMixingEncodings
            {
                get;
            }

            public abstract ulong SelectedMixingEncodingIdx
            {
                get;

                set;
            }

            #region Virtual table interop

            // size_t getNumMixingSpaces() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumMixingSpacesDelegateInstance;

            private static ulong _GetNumMixingSpacesDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.NumMixingSpaces;
                return ___ret;
            }

            // char * getMixingSpaceUIName(size_t idx) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetMixingSpaceUINameDelegateInstance;

            private static __IntPtr _GetMixingSpaceUINameDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.GetMixingSpaceUIName(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // size_t getSelectedMixingSpaceIdx() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetSelectedMixingSpaceIdxDelegateInstance;

            private static ulong _GetSelectedMixingSpaceIdxDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.SelectedMixingSpaceIdx;
                return ___ret;
            }

            // void setSelectedMixingSpaceIdx(size_t idx) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_ulong _SetSelectedMixingSpaceIdxDelegateInstance;

            private static void _SetSelectedMixingSpaceIdxDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                __target.SelectedMixingSpaceIdx = idx;
            }

            // void setSelectedMixingSpace(const char * mixingSpace) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetSelectedMixingSpaceDelegateInstance;

            private static void _SetSelectedMixingSpaceDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mixingSpace)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                __target.SetSelectedMixingSpace(mixingSpace);
            }

            // bool isPerceptuallyUniform() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_bool___IntPtr _IsPerceptuallyUniformDelegateInstance;

            private static bool _IsPerceptuallyUniformDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.IsPerceptuallyUniform;
                return ___ret;
            }

            // size_t getNumMixingEncodings() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetNumMixingEncodingsDelegateInstance;

            private static ulong _GetNumMixingEncodingsDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.NumMixingEncodings;
                return ___ret;
            }

            // char * getMixingEncodingName(size_t idx) const = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong _GetMixingEncodingNameDelegateInstance;

            private static __IntPtr _GetMixingEncodingNameDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.GetMixingEncodingName(idx);
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            // size_t getSelectedMixingEncodingIdx() const noexcept = 0
            private static global::OpenColorIO.Delegates.Func_ulong___IntPtr _GetSelectedMixingEncodingIdxDelegateInstance;

            private static ulong _GetSelectedMixingEncodingIdxDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.SelectedMixingEncodingIdx;
                return ___ret;
            }

            // void setSelectedMixingEncodingIdx(size_t idx) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_ulong _SetSelectedMixingEncodingIdxDelegateInstance;

            private static void _SetSelectedMixingEncodingIdxDelegateHook(__IntPtr __instance, ulong idx)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                __target.SelectedMixingEncodingIdx = idx;
            }

            // void setSelectedMixingEncoding(const char * mixingEncoding) = 0
            private static global::OpenColorIO.Delegates.Action___IntPtr_string8 _SetSelectedMixingEncodingDelegateInstance;

            private static void _SetSelectedMixingEncodingDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mixingEncoding)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                __target.SetSelectedMixingEncoding(mixingEncoding);
            }

            // MixingSlider & getSlider(float sliderMixingMinEdge, float sliderMixingMaxEdge) noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_float_float _GetSlider_1DelegateInstance;

            private static __IntPtr _GetSlider_1DelegateHook(__IntPtr __instance, float sliderMixingMinEdge, float sliderMixingMaxEdge)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.GetSlider(sliderMixingMinEdge, sliderMixingMaxEdge);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // MixingSlider & getSlider() noexcept = 0
            private static global::OpenColorIO.Delegates.Func___IntPtr___IntPtr _GetSliderDelegateInstance;

            private static __IntPtr _GetSliderDelegateHook(__IntPtr __instance)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                var ___ret = __target.GetSlider();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // virtual ~MixingColorSpaceManager() = default
            private static global::OpenColorIO.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[14];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _GetNumMixingSpacesDelegateInstance += _GetNumMixingSpacesDelegateHook;
                    _GetMixingSpaceUINameDelegateInstance += _GetMixingSpaceUINameDelegateHook;
                    _GetSelectedMixingSpaceIdxDelegateInstance += _GetSelectedMixingSpaceIdxDelegateHook;
                    _SetSelectedMixingSpaceIdxDelegateInstance += _SetSelectedMixingSpaceIdxDelegateHook;
                    _SetSelectedMixingSpaceDelegateInstance += _SetSelectedMixingSpaceDelegateHook;
                    _IsPerceptuallyUniformDelegateInstance += _IsPerceptuallyUniformDelegateHook;
                    _GetNumMixingEncodingsDelegateInstance += _GetNumMixingEncodingsDelegateHook;
                    _GetMixingEncodingNameDelegateInstance += _GetMixingEncodingNameDelegateHook;
                    _GetSelectedMixingEncodingIdxDelegateInstance += _GetSelectedMixingEncodingIdxDelegateHook;
                    _SetSelectedMixingEncodingIdxDelegateInstance += _SetSelectedMixingEncodingIdxDelegateHook;
                    _SetSelectedMixingEncodingDelegateInstance += _SetSelectedMixingEncodingDelegateHook;
                    _GetSlider_1DelegateInstance += _GetSlider_1DelegateHook;
                    _GetSliderDelegateInstance += _GetSliderDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNumMixingSpacesDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetMixingSpaceUINameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetSelectedMixingSpaceIdxDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetSelectedMixingSpaceIdxDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetSelectedMixingSpaceDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_IsPerceptuallyUniformDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetNumMixingEncodingsDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMixingEncodingNameDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetSelectedMixingEncodingIdxDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_SetSelectedMixingEncodingIdxDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetSelectedMixingEncodingDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetSlider_1DelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_GetSliderDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTablesDtorOnly[0][15] = Thunks[13];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                ManagedVTables[0][14] = Thunks[12];
                                ManagedVTables[0][15] = Thunks[13];
                                VTables.Methods[0] = new Delegate[16];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class ColorSpaceMenuParametersInternal : global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuParameters, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ColorSpaceMenuParametersInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ColorSpaceMenuParametersInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Add an additional color space (or named transform) to the menu.</summary>
            /// <remarks>
            /// <para>Note that an additional color space could be:</para>
            /// <para>* an inactive color space,</para>
            /// <para>* an active color space not having at least one of the selected categories,</para>
            /// <para>* a newly created color space.</para>
            /// <para>Will throw when creating the menu if color space is not part of the config. Nothing is done</para>
            /// <para>if it is already part of the menu.</para>
            /// <para>It's ok to call this multiple times with the same color space, it will only be added to the</para>
            /// <para>menu once.  If a role name is passed in, the name in the menu will be the color space name</para>
            /// <para>the role points to.</para>
            /// </remarks>
            public override void AddColorSpace(string name)
            {
                var ___AddColorSpaceDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 18);
                ___AddColorSpaceDelegate(__Instance, name);
            }

            public override string GetAddedColorSpace(ulong index)
            {
                var ___GetAddedColorSpaceDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 20);
                var ___ret = ___GetAddedColorSpaceDelegate(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public override void ClearAddedColorSpaces()
            {
                var ___ClearAddedColorSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr>(0, 21);
                ___ClearAddedColorSpacesDelegate(__Instance);
            }

            public override string Role
            {
                get
                {
                    var ___GetRoleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetRoleDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetRoleDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 2);
                    ___SetRoleDelegate(__Instance, value);
                }
            }

            public override bool IncludeColorSpaces
            {
                get
                {
                    var ___GetIncludeColorSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 5);
                    var ___ret = ___GetIncludeColorSpacesDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetIncludeColorSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 4);
                    ___SetIncludeColorSpacesDelegate(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Can be used to restrict the search using the ReferenceSpaceType of the color spaces.</para>
            /// <para>It has no effect on roles and named transforms.</para>
            /// </summary>
            public override global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType SearchReferenceSpaceType
            {
                get
                {
                    var ___GetSearchReferenceSpaceTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType___IntPtr>(0, 6);
                    var ___ret = ___GetSearchReferenceSpaceTypeDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSearchReferenceSpaceTypeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType>(0, 7);
                    ___SetSearchReferenceSpaceTypeDelegate(__Instance, value);
                }
            }

            public override bool IncludeNamedTransforms
            {
                get
                {
                    var ___GetIncludeNamedTransformsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___GetIncludeNamedTransformsDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetIncludeNamedTransformsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 8);
                    ___SetIncludeNamedTransformsDelegate(__Instance, value);
                }
            }

            public override string AppCategories
            {
                get
                {
                    var ___GetAppCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 11);
                    var ___ret = ___GetAppCategoriesDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetAppCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 10);
                    ___SetAppCategoriesDelegate(__Instance, value);
                }
            }

            public override string Encodings
            {
                get
                {
                    var ___GetEncodingsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 13);
                    var ___ret = ___GetEncodingsDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetEncodingsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 12);
                    ___SetEncodingsDelegate(__Instance, value);
                }
            }

            public override string UserCategories
            {
                get
                {
                    var ___GetUserCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 15);
                    var ___ret = ___GetUserCategoriesDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetUserCategoriesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 14);
                    ___SetUserCategoriesDelegate(__Instance, value);
                }
            }

            public override bool IncludeRoles
            {
                get
                {
                    var ___GetIncludeRolesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 17);
                    var ___ret = ___GetIncludeRolesDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetIncludeRolesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 16);
                    ___SetIncludeRolesDelegate(__Instance, value);
                }
            }

            public override ulong NumAddedColorSpaces
            {
                get
                {
                    var ___GetNumAddedColorSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 19);
                    var ___ret = ___GetNumAddedColorSpacesDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class ColorSpaceMenuHelperInternal : global::OpenColorIO.OpenColorIO_v2_4.ColorSpaceMenuHelper, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ColorSpaceMenuHelperInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal ColorSpaceMenuHelperInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>
            /// <para>Get the color space (or role) name used in the config for this menu item.  Will be empty</para>
            /// <para>if the index is out of range.</para>
            /// </summary>
            public override string GetName(ulong idx)
            {
                var ___GetNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 1);
                var ___ret = ___GetNameDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get the name to use in the menu UI.  This might be different from the config name, for</para>
            /// <para>example in the case of roles.  Will be empty if the index is out of range.</para>
            /// </summary>
            public override string GetUIName(ulong idx)
            {
                var ___GetUINameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 2);
                var ___ret = ___GetUINameDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Get the index of the element of a given name. Return (size_t)-1 name if NULL or empty, or if</para>
            /// <para>no element with that name is found.</para>
            /// </summary>
            public override ulong GetIndexFromName(string name)
            {
                var ___GetIndexFromNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr_string8>(0, 3);
                var ___ret = ___GetIndexFromNameDelegate(__Instance, name);
                return ___ret;
            }

            public override ulong GetIndexFromUIName(string name)
            {
                var ___GetIndexFromUINameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr_string8>(0, 4);
                var ___ret = ___GetIndexFromUINameDelegate(__Instance, name);
                return ___ret;
            }

            public override string GetDescription(ulong idx)
            {
                var ___GetDescriptionDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 5);
                var ___ret = ___GetDescriptionDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public override string GetFamily(ulong idx)
            {
                var ___GetFamilyDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 6);
                var ___ret = ___GetFamilyDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>
            /// <para>Hierarchy levels are created from the family string. It is split into levels using the</para>
            /// <para>'family separator'.</para>
            /// </summary>
            public override ulong GetNumHierarchyLevels(ulong idx)
            {
                var ___GetNumHierarchyLevelsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr_ulong>(0, 7);
                var ___ret = ___GetNumHierarchyLevelsDelegate(__Instance, idx);
                return ___ret;
            }

            public override string GetHierarchyLevel(ulong idx, ulong i)
            {
                var ___GetHierarchyLevelDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong_ulong>(0, 8);
                var ___ret = ___GetHierarchyLevelDelegate(__Instance, idx, i);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the color space name from the UI name.</summary>
            public override string GetNameFromUIName(string uiName)
            {
                var ___GetNameFromUINameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8>(0, 9);
                var ___ret = ___GetNameFromUINameDelegate(__Instance, uiName);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Get the color space UI name from the name.</summary>
            public override string GetUINameFromName(string name)
            {
                var ___GetUINameFromNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_string8>(0, 10);
                var ___ret = ___GetUINameFromNameDelegate(__Instance, name);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Access to the color spaces (or roles).</summary>
            public override ulong NumColorSpaces
            {
                get
                {
                    var ___GetNumColorSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 0);
                    var ___ret = ___GetNumColorSpacesDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class LegacyViewingPipelineInternal : global::OpenColorIO.OpenColorIO_v2_4.LegacyViewingPipeline, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal LegacyViewingPipelineInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal LegacyViewingPipelineInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override bool LooksOverrideEnabled
            {
                get
                {
                    var ___GetLooksOverrideEnabledDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 11);
                    var ___ret = ___GetLooksOverrideEnabledDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetLooksOverrideEnabledDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_bool>(0, 10);
                    ___SetLooksOverrideEnabledDelegate(__Instance, value);
                }
            }

            public override string LooksOverride
            {
                get
                {
                    var ___GetLooksOverrideDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 13);
                    var ___ret = ___GetLooksOverrideDelegate(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }

                set
                {
                    var ___SetLooksOverrideDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 12);
                    ___SetLooksOverrideDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class MixingSliderInternal : global::OpenColorIO.OpenColorIO_v2_4.MixingSlider, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal MixingSliderInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal MixingSliderInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Convert from units in distance along the slider to mixing space units.</summary>
            public override float SliderToMixing(float sliderUnits)
            {
                var ___SliderToMixingDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr_float>(0, 4);
                var ___ret = ___SliderToMixingDelegate(__Instance, sliderUnits);
                return ___ret;
            }

            /// <summary>Convert from mixing space units to distance along the slider.</summary>
            public override float MixingToSlider(float mixingUnits)
            {
                var ___MixingToSliderDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr_float>(0, 5);
                var ___ret = ___MixingToSliderDelegate(__Instance, mixingUnits);
                return ___ret;
            }

            /// <summary>Minimum edge of a UI slider for conversion to mixing space.</summary>
            /// <remarks>Set the minimum edge of a UI slider for conversion to mixing space.</remarks>
            public override float SliderMinEdge
            {
                get
                {
                    var ___GetSliderMinEdgeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr>(0, 1);
                    var ___ret = ___GetSliderMinEdgeDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSliderMinEdgeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_float>(0, 0);
                    ___SetSliderMinEdgeDelegate(__Instance, value);
                }
            }

            /// <summary>Maximum edge of a UI slider for conversion to mixing space.</summary>
            /// <remarks>Set the maximum edge of a UI slider for conversion to mixing space.</remarks>
            public override float SliderMaxEdge
            {
                get
                {
                    var ___GetSliderMaxEdgeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_float___IntPtr>(0, 3);
                    var ___ret = ___GetSliderMaxEdgeDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSliderMaxEdgeDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_float>(0, 2);
                    ___SetSliderMaxEdgeDelegate(__Instance, value);
                }
            }
        }

        public unsafe partial class MixingColorSpaceManagerInternal : global::OpenColorIO.OpenColorIO_v2_4.MixingColorSpaceManager, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal MixingColorSpaceManagerInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal MixingColorSpaceManagerInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override string GetMixingSpaceUIName(ulong idx)
            {
                var ___GetMixingSpaceUINameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 1);
                var ___ret = ___GetMixingSpaceUINameDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public override void SetSelectedMixingSpace(string mixingSpace)
            {
                var ___SetSelectedMixingSpaceDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 4);
                ___SetSelectedMixingSpaceDelegate(__Instance, mixingSpace);
            }

            public override string GetMixingEncodingName(ulong idx)
            {
                var ___GetMixingEncodingNameDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_ulong>(0, 7);
                var ___ret = ___GetMixingEncodingNameDelegate(__Instance, idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public override void SetSelectedMixingEncoding(string mixingEncoding)
            {
                var ___SetSelectedMixingEncodingDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_string8>(0, 10);
                ___SetSelectedMixingEncodingDelegate(__Instance, mixingEncoding);
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.MixingSlider GetSlider()
            {
                var ___GetSliderDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr>(0, 14);
                var ___ret = ___GetSliderDelegate(__Instance);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            public override global::OpenColorIO.OpenColorIO_v2_4.MixingSlider GetSlider(float sliderMixingMinEdge, float sliderMixingMaxEdge)
            {
                var ___GetSlider_1Delegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func___IntPtr___IntPtr_float_float>(0, 13);
                var ___ret = ___GetSlider_1Delegate(__Instance, sliderMixingMinEdge, sliderMixingMaxEdge);
                var __result0 = global::OpenColorIO.OpenColorIO_v2_4.MixingSlider.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access to the mixing spaces.</summary>
            public override ulong NumMixingSpaces
            {
                get
                {
                    var ___GetNumMixingSpacesDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 0);
                    var ___ret = ___GetNumMixingSpacesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override ulong SelectedMixingSpaceIdx
            {
                get
                {
                    var ___GetSelectedMixingSpaceIdxDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 2);
                    var ___ret = ___GetSelectedMixingSpaceIdxDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSelectedMixingSpaceIdxDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_ulong>(0, 3);
                    ___SetSelectedMixingSpaceIdxDelegate(__Instance, value);
                }
            }

            public override bool IsPerceptuallyUniform
            {
                get
                {
                    var ___IsPerceptuallyUniformDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_bool___IntPtr>(0, 5);
                    var ___ret = ___IsPerceptuallyUniformDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Access to the mixing encodings.</summary>
            public override ulong NumMixingEncodings
            {
                get
                {
                    var ___GetNumMixingEncodingsDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 6);
                    var ___ret = ___GetNumMixingEncodingsDelegate(__Instance);
                    return ___ret;
                }
            }

            public override ulong SelectedMixingEncodingIdx
            {
                get
                {
                    var ___GetSelectedMixingEncodingIdxDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Func_ulong___IntPtr>(0, 8);
                    var ___ret = ___GetSelectedMixingEncodingIdxDelegate(__Instance);
                    return ___ret;
                }

                set
                {
                    var ___SetSelectedMixingEncodingIdxDelegate = __VTables.GetMethodDelegate<global::OpenColorIO.Delegates.Action___IntPtr_ulong>(0, 9);
                    ___SetSelectedMixingEncodingIdxDelegate(__Instance, value);
                }
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.BitDepth Func_OpenColorIO_OpenColorIO_v2_4_BitDepth___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate long Func_long___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.I1)] bool arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8_uint_uint_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureType_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensions_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, uint arg3, uint arg4, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType arg5, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions arg6, global::OpenColorIO.OpenColorIO_v2_4.Interpolation arg7, float* arg8);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8_uint_OpenColorIO_OpenColorIO_v2_4_Interpolation_floatPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, uint arg3, global::OpenColorIO.OpenColorIO_v2_4.Interpolation arg4, float* arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8_string8_string8_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg4, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_uint___IntPtr(__IntPtr __instance, uint arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureTypePtr_OpenColorIO_OpenColorIO_v2_4_GpuShaderCreator_TextureDimensionsPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr(__IntPtr __instance, uint arg1, string arg2, string arg3, uint* arg4, uint* arg5, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureType* arg6, global::OpenColorIO.OpenColorIO_v2_4.GpuShaderCreator.TextureDimensions* arg7, global::OpenColorIO.OpenColorIO_v2_4.Interpolation* arg8);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_floatPtrPtr(__IntPtr __instance, uint arg1, float** arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_sbytePtrPtr_sbytePtrPtr_uintPtr_OpenColorIO_OpenColorIO_v2_4_InterpolationPtr(__IntPtr __instance, uint arg1, string arg2, string arg3, uint* arg4, global::OpenColorIO.OpenColorIO_v2_4.Interpolation* arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_string8(__IntPtr __instance, __IntPtr arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.TransformDirection Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.TransformDirection arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.TransformType Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.CDLStyle Func_OpenColorIO_OpenColorIO_v2_4_CDLStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_CDLStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.CDLStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_doublePtr(__IntPtr __instance, double* arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_double(__IntPtr __instance, double arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong_float(__IntPtr __instance, ulong arg1, float arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.DynamicPropertyType Func_OpenColorIO_OpenColorIO_v2_4_DynamicPropertyType___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_doubleArray(__IntPtr __instance, double[] arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.NegativeStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle Func_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.ExposureContrastStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle Func_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.FixedFunctionStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_doublePtr_ulong(__IntPtr __instance, double* arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.GradingStyle Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.GradingStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong_float(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType arg1, ulong arg2, float arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RGBCurveType arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_doubleArray(__IntPtr __instance, double[] arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.BitDepth arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_floatPtr_floatPtr_floatPtr(__IntPtr __instance, uint arg1, float* arg2, float* arg3, float* arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_float_float_float(__IntPtr __instance, uint arg1, float arg2, float arg3, float arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust Func_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Lut1DHueAdjust arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.Interpolation Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.Interpolation arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_uint_uint_floatPtr_floatPtr_floatPtr(__IntPtr __instance, uint arg1, uint arg2, uint arg3, float* arg4, float* arg5, float* arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_uint_uint_float_float_float(__IntPtr __instance, uint arg1, uint arg2, uint arg3, float arg4, float arg5, float arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.RangeStyle Func_OpenColorIO_OpenColorIO_v2_4_RangeStyle___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RangeStyle(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.RangeStyle arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType Func_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_SearchReferenceSpaceType(__IntPtr __instance, global::OpenColorIO.OpenColorIO_v2_4.SearchReferenceSpaceType arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulong_ulong(__IntPtr __instance, ulong arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_float(__IntPtr __instance, float arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float___IntPtr_float(__IntPtr __instance, float arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_float_float(__IntPtr __instance, float arg1, float arg2);
    }
}
namespace OpenColorIO.__Symbols
{
    internal class OpenColorIO
    {
        public static IntPtr _DefaultRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB { get; }
        public static IntPtr _FilePathSearchRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB { get; }
        public static IntPtr _OCIO_CONFIG_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_ACTIVE_DISPLAYS_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_ACTIVE_VIEWS_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_INACTIVE_COLORSPACES_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_OPTIMIZATION_FLAGS_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_USER_CATEGORIES_ENVVAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_DEFAULT_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_REFERENCE_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_DATA_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_COLOR_PICKING_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_SCENE_LINEAR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_COMPOSITING_LOG_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_COLOR_TIMING_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_TEXTURE_PAINT_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_MATTE_PAINT_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_RENDERING_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_INTERCHANGE_SCENE_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _ROLE_INTERCHANGE_DISPLAY_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_VIEW_USE_DISPLAY_NAME_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_DESCRIPTION_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_INFO_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_INPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_OUTPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_NAME_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _METADATA_ID_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_DISABLE_ALL_CACHES_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_DISABLE_PROCESSOR_CACHES_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_DISABLE_CACHE_FALLBACK_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_CONFIG_DEFAULT_NAME_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_CONFIG_DEFAULT_FILE_EXT_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_CONFIG_ARCHIVE_FILE_EXT_OpenColorIO_v2_4__3PEBDEB { get; }
        public static IntPtr _OCIO_BUILTIN_URI_PREFIX_OpenColorIO_v2_4__3PEBDEB { get; }
        static OpenColorIO()
        {
            var path = "OpenColorIO";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _DefaultRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?DefaultRuleName@FileRules@OpenColorIO_v2_4@@2PEBDEB");
            _FilePathSearchRuleName_FileRules_OpenColorIO_v2_4__2PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?FilePathSearchRuleName@FileRules@OpenColorIO_v2_4@@2PEBDEB");
            _OCIO_CONFIG_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_CONFIG_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_ACTIVE_DISPLAYS_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_ACTIVE_DISPLAYS_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_ACTIVE_VIEWS_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_ACTIVE_VIEWS_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_INACTIVE_COLORSPACES_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_INACTIVE_COLORSPACES_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_OPTIMIZATION_FLAGS_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_OPTIMIZATION_FLAGS_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_USER_CATEGORIES_ENVVAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_USER_CATEGORIES_ENVVAR@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_DEFAULT_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_DEFAULT@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_REFERENCE_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_REFERENCE@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_DATA_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_DATA@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_COLOR_PICKING_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_COLOR_PICKING@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_SCENE_LINEAR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_SCENE_LINEAR@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_COMPOSITING_LOG_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_COMPOSITING_LOG@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_COLOR_TIMING_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_COLOR_TIMING@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_TEXTURE_PAINT_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_TEXTURE_PAINT@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_MATTE_PAINT_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_MATTE_PAINT@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_RENDERING_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_RENDERING@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_INTERCHANGE_SCENE_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_INTERCHANGE_SCENE@OpenColorIO_v2_4@@3PEBDEB");
            _ROLE_INTERCHANGE_DISPLAY_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?ROLE_INTERCHANGE_DISPLAY@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_VIEW_USE_DISPLAY_NAME_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_VIEW_USE_DISPLAY_NAME@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_DESCRIPTION_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_DESCRIPTION@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_INFO_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_INFO@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_INPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_INPUT_DESCRIPTOR@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_OUTPUT_DESCRIPTOR_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_OUTPUT_DESCRIPTOR@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_NAME_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_NAME@OpenColorIO_v2_4@@3PEBDEB");
            _METADATA_ID_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?METADATA_ID@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_DISABLE_ALL_CACHES_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_DISABLE_ALL_CACHES@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_DISABLE_PROCESSOR_CACHES_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_DISABLE_PROCESSOR_CACHES@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_DISABLE_CACHE_FALLBACK_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_DISABLE_CACHE_FALLBACK@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_CONFIG_DEFAULT_NAME_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_CONFIG_DEFAULT_NAME@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_CONFIG_DEFAULT_FILE_EXT_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_CONFIG_DEFAULT_FILE_EXT@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_CONFIG_ARCHIVE_FILE_EXT_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_CONFIG_ARCHIVE_FILE_EXT@OpenColorIO_v2_4@@3PEBDEB");
            _OCIO_BUILTIN_URI_PREFIX_OpenColorIO_v2_4__3PEBDEB = CppSharp.SymbolResolver.ResolveSymbol(image, "?OCIO_BUILTIN_URI_PREFIX@OpenColorIO_v2_4@@3PEBDEB");
        }
    }
}

