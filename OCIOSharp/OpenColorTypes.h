// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma once

#include "CppSharp.h"
#include <OpenColorTypes.h>

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        enum class Allocation;
        enum class BitDepth;
        enum class CDLStyle;
        enum class ChannelOrdering;
        enum class ColorSpaceDirection;
        enum class ColorSpaceVisibility;
        enum class DynamicPropertyType;
        enum class EnvironmentMode;
        enum class ExposureContrastStyle;
        enum class FixedFunctionStyle;
        enum class GpuLanguage;
        enum class GradingStyle;
        enum class Interpolation;
        enum class LoggingLevel;
        enum class Lut1DHueAdjust;
        enum class NamedTransformVisibility;
        enum class NegativeStyle;
        enum class OptimizationFlags : unsigned long;
        enum class ProcessorCacheFlags : unsigned int;
        enum class RGBCurveType;
        enum class RangeStyle;
        enum class ReferenceSpaceType;
        enum class SearchReferenceSpaceType;
        enum class TransformDirection;
        enum class TransformType;
        enum class UniformDataType;
        enum class ViewTransformDirection;
        enum class ViewType;
        ref class AllocationTransform;
        ref class Baker;
        ref class BuiltinTransform;
        ref class BuiltinTransformRegistry;
        ref class CDLTransform;
        ref class CPUProcessor;
        ref class ColorSpace;
        ref class ColorSpaceMenuHelper;
        ref class ColorSpaceMenuParameters;
        ref class ColorSpaceSet;
        ref class ColorSpaceTransform;
        ref class Config;
        ref class ConfigIOProxy;
        ref class Context;
        ref class DisplayViewTransform;
        ref class DynamicProperty;
        ref class DynamicPropertyDouble;
        ref class DynamicPropertyGradingPrimary;
        ref class DynamicPropertyGradingRGBCurve;
        ref class DynamicPropertyGradingTone;
        ref class ExponentTransform;
        ref class ExponentWithLinearTransform;
        ref class ExposureContrastTransform;
        ref class FileRules;
        ref class FileTransform;
        ref class FixedFunctionTransform;
        ref class GPUProcessor;
        ref class GpuShaderCreator;
        ref class GpuShaderDesc;
        ref class GradingBSplineCurve;
        ref class GradingPrimaryTransform;
        ref class GradingRGBCurve;
        ref class GradingRGBCurveTransform;
        ref class GradingToneTransform;
        ref class GroupTransform;
        ref class ImageDesc;
        ref class LegacyViewingPipeline;
        ref class LogAffineTransform;
        ref class LogCameraTransform;
        ref class LogTransform;
        ref class Look;
        ref class LookTransform;
        ref class Lut1DTransform;
        ref class Lut3DTransform;
        ref class MatrixTransform;
        ref class MixingColorSpaceManager;
        ref class NamedTransform;
        ref class Processor;
        ref class ProcessorMetadata;
        ref class RangeTransform;
        ref class SystemMonitors;
        ref class Transform;
        ref class ViewTransform;
        ref class ViewingRules;
    }
}

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        /// <summary>Controls which environment variables are loaded into a Context object.</summary>
        public enum class EnvironmentMode
        {
            ENV_ENVIRONMENT_UNKNOWN = 0,
            /// <summary>Only load vars in the config's environment section</summary>
            ENV_ENVIRONMENT_LOAD_PREDEFINED = 1,
            /// <summary>Load all env. vars (note: may reduce performance)</summary>
            ENV_ENVIRONMENT_LOAD_ALL = 2
        };

        /// <summary>
        /// <para>OCIO does not mandate the image state of the main reference space and it is not</para>
        /// <para>required to be scene-referred.  This enum is used in connection with the display color space</para>
        /// <para>and view transform features which do assume that the main reference space is scene-referred</para>
        /// <para>and the display reference space is display-referred.  If a config used a non-scene-referred</para>
        /// <para>reference space, presumably it would not use either display color spaces or view transforms,</para>
        /// <para>so this enum becomes irrelevant.</para>
        /// </summary>
        public enum class ReferenceSpaceType
        {
            /// <summary>the main scene reference space</summary>
            REFERENCE_SPACE_SCENE = 0,
            /// <summary>the reference space for display color spaces</summary>
            REFERENCE_SPACE_DISPLAY = 1
        };

        /// <summary>
        /// <para>Used in a configuration file to indicate the bit-depth of a color space,</para>
        /// <para>and by theto specify the input and output bit-depths of</para>
        /// <para>images to process.</para>
        /// <para>Note thatonly supports: UINT8, UINT10, UINT12, UINT16, F16 and F32.</para>
        /// </summary>
        public enum class BitDepth
        {
            BIT_DEPTH_UNKNOWN = 0,
            BIT_DEPTH_UINT8 = 1,
            BIT_DEPTH_UINT10 = 2,
            BIT_DEPTH_UINT12 = 3,
            BIT_DEPTH_UINT14 = 4,
            BIT_DEPTH_UINT16 = 5,
            /// <summary>Here for historical reason but that's not supported.</summary>
            BIT_DEPTH_UINT32 = 6,
            BIT_DEPTH_F16 = 7,
            BIT_DEPTH_F32 = 8
        };

        public enum class Allocation
        {
            ALLOCATION_UNKNOWN = 0,
            ALLOCATION_UNIFORM = 1,
            ALLOCATION_LG2 = 2
        };

        public enum class TransformDirection
        {
            TRANSFORM_DIR_FORWARD = 0,
            TRANSFORM_DIR_INVERSE = 1
        };

        public enum class TransformType
        {
            TRANSFORM_TYPE_ALLOCATION = 0,
            TRANSFORM_TYPE_BUILTIN = 1,
            TRANSFORM_TYPE_CDL = 2,
            TRANSFORM_TYPE_COLORSPACE = 3,
            TRANSFORM_TYPE_DISPLAY_VIEW = 4,
            TRANSFORM_TYPE_EXPONENT = 5,
            TRANSFORM_TYPE_EXPONENT_WITH_LINEAR = 6,
            TRANSFORM_TYPE_EXPOSURE_CONTRAST = 7,
            TRANSFORM_TYPE_FILE = 8,
            TRANSFORM_TYPE_FIXED_FUNCTION = 9,
            TRANSFORM_TYPE_GRADING_PRIMARY = 10,
            TRANSFORM_TYPE_GRADING_RGB_CURVE = 11,
            TRANSFORM_TYPE_GRADING_TONE = 12,
            TRANSFORM_TYPE_GROUP = 13,
            TRANSFORM_TYPE_LOG_AFFINE = 14,
            TRANSFORM_TYPE_LOG_CAMERA = 15,
            TRANSFORM_TYPE_LOG = 16,
            TRANSFORM_TYPE_LOOK = 17,
            TRANSFORM_TYPE_LUT1D = 18,
            TRANSFORM_TYPE_LUT3D = 19,
            TRANSFORM_TYPE_MATRIX = 20,
            TRANSFORM_TYPE_RANGE = 21
        };

        public enum class ColorSpaceDirection
        {
            COLORSPACE_DIR_TO_REFERENCE = 0,
            COLORSPACE_DIR_FROM_REFERENCE = 1
        };

        public enum class SearchReferenceSpaceType
        {
            SEARCH_REFERENCE_SPACE_SCENE = 0,
            SEARCH_REFERENCE_SPACE_DISPLAY = 1,
            SEARCH_REFERENCE_SPACE_ALL = 2
        };

        public enum class ColorSpaceVisibility
        {
            COLORSPACE_ACTIVE = 0,
            COLORSPACE_INACTIVE = 1,
            COLORSPACE_ALL = 2
        };

        public enum class ViewType
        {
            VIEW_SHARED = 0,
            VIEW_DISPLAY_DEFINED = 1
        };

        public enum class ViewTransformDirection
        {
            VIEWTRANSFORM_DIR_TO_REFERENCE = 0,
            VIEWTRANSFORM_DIR_FROM_REFERENCE = 1
        };

        public enum class NamedTransformVisibility
        {
            NAMEDTRANSFORM_ACTIVE = 0,
            NAMEDTRANSFORM_INACTIVE = 1,
            NAMEDTRANSFORM_ALL = 2
        };

        /// <summary>Types for dynamic properties.</summary>
        public enum class DynamicPropertyType
        {
            /// <summary>Image exposure value (double floating point value)</summary>
            DYNAMIC_PROPERTY_EXPOSURE = 0,
            /// <summary>Image contrast value (double floating point value)</summary>
            DYNAMIC_PROPERTY_CONTRAST = 1,
            /// <summary>Image gamma value (double floating point value)</summary>
            DYNAMIC_PROPERTY_GAMMA = 2,
            /// <summary>Used by GradingPrimaryTransform</summary>
            DYNAMIC_PROPERTY_GRADING_PRIMARY = 3,
            /// <summary>Used by GradingRGBCurveTransform</summary>
            DYNAMIC_PROPERTY_GRADING_RGBCURVE = 4,
            /// <summary>Used by GradingToneTransform</summary>
            DYNAMIC_PROPERTY_GRADING_TONE = 5
        };

        /// <summary>Provides control over how the ops in a Processor are combined in order to improve performance.</summary>
        public enum class OptimizationFlags : unsigned long
        {
            /// <summary>Do not optimize.</summary>
            OPTIMIZATION_NONE = 0x0,
            /// <summary>Replace identity ops (other than gamma).</summary>
            OPTIMIZATION_IDENTITY = 0x1,
            /// <summary>Replace identity gamma ops.</summary>
            OPTIMIZATION_IDENTITY_GAMMA = 0x2,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_CDL = 0x40,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_EXPOSURE_CONTRAST = 0x80,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_FIXED_FUNCTION = 0x100,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_GAMMA = 0x200,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LUT1D = 0x400,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LUT3D = 0x800,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_LOG = 0x1000,
            /// <summary>Replace a pair of ops where one is the inverse of the other.</summary>
            OPTIMIZATION_PAIR_IDENTITY_GRADING = 0x2000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_EXPONENT = 0x40000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_GAMMA = 0x80000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_MATRIX = 0x100000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_LUT1D = 0x200000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_LUT3D = 0x400000,
            /// <summary>Compose a pair of ops into a single op.</summary>
            OPTIMIZATION_COMP_RANGE = 0x800000,
            /// <summary>
            /// <para>For integer and half bit-depths only, replace separable ops (i.e. no channel crosstalk</para>
            /// <para>ops) by a single 1D LUT of input bit-depth domain.</para>
            /// </summary>
            OPTIMIZATION_COMP_SEPARABLE_PREFIX = 0x1000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_LUT_INV_FAST = 0x2000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_FAST_LOG_EXP_POW = 0x4000000,
            /// <summary>
            /// <para>Implement inverse Lut1D and Lut3D evaluations using a a forward LUT (faster but less</para>
            /// <para>accurate).  Note that GPU evals always do FAST.</para>
            /// </summary>
            OPTIMIZATION_SIMPLIFY_OPS = 0x8000000,
            /// <summary>
            /// <para>Turn off dynamic control of any ops that offer adjustment of parameter values after</para>
            /// <para>finalization (e.g. ExposureContrast).</para>
            /// </summary>
            OPTIMIZATION_NO_DYNAMIC_PROPERTIES = 0x10000000,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_ALL = 0xffffffff,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_LOSSLESS = 144457667,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_VERY_GOOD = 263995331,
            /// <summary>Apply all possible optimizations.</summary>
            OPTIMIZATION_GOOD = 268189635,
            /// <summary>For quite lossy optimizations.</summary>
            OPTIMIZATION_DRAFT = 4294967295,
            /// <summary>For quite lossy optimizations.</summary>
            OPTIMIZATION_DEFAULT = 263995331
        };

        /// <summary>Used when there is a choice of hardware shader language.</summary>
        public enum class GpuLanguage
        {
            /// <summary>Nvidia Cg shader</summary>
            GPU_LANGUAGE_CG = 0,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_1_2 = 1,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_1_3 = 2,
            /// <summary>OpenGL Shading Language</summary>
            GPU_LANGUAGE_GLSL_4_0 = 3,
            /// <summary>DirectX Shading Language</summary>
            GPU_LANGUAGE_HLSL_DX11 = 4,
            /// <summary>Open Shading Language</summary>
            LANGUAGE_OSL_1 = 5,
            /// <summary>OpenGL ES Shading Language</summary>
            GPU_LANGUAGE_GLSL_ES_1_0 = 6,
            /// <summary>OpenGL ES Shading Language</summary>
            GPU_LANGUAGE_GLSL_ES_3_0 = 7,
            /// <summary>Metal Shading Language</summary>
            GPU_LANGUAGE_MSL_2_0 = 8
        };

        /// <summary>
        /// <para>Specify the interpolation type to use</para>
        /// <para>If the specified interpolation type is not supported in the requested</para>
        /// <para>context (for example, using tetrahedral interpolationon 1D LUTs)</para>
        /// <para>an exception will be thrown.</para>
        /// </summary>
        /// <remarks>
        /// <para>INTERP_DEFAULT will choose the default interpolation type for the requested</para>
        /// <para>context:</para>
        /// <para>1D LUT INTERP_DEFAULT: LINEAR</para>
        /// <para>3D LUT INTERP_DEFAULT: LINEAR</para>
        /// <para>INTERP_BEST will choose the best interpolation type for the requested</para>
        /// <para>context:</para>
        /// <para>1D LUT INTERP_BEST: LINEAR</para>
        /// <para>3D LUT INTERP_BEST: TETRAHEDRAL</para>
        /// <para>Note: INTERP_BEST and INTERP_DEFAULT are subject to change in minor</para>
        /// <para>releases, so if you care about locking off on a specific interpolation</para>
        /// <para>type, we'd recommend directly specifying it.</para>
        /// </remarks>
        public enum class Interpolation
        {
            INTERP_UNKNOWN = 0,
            /// <summary>nearest neighbor</summary>
            INTERP_NEAREST = 1,
            /// <summary>linear interpolation (trilinear for Lut3D)</summary>
            INTERP_LINEAR = 2,
            /// <summary>tetrahedral interpolation (Lut3D only)</summary>
            INTERP_TETRAHEDRAL = 3,
            /// <summary>cubic interpolation (not supported)</summary>
            INTERP_CUBIC = 4,
            /// <summary>the default interpolation type</summary>
            INTERP_DEFAULT = 254,
            /// <summary>the 'best' suitable interpolation type</summary>
            INTERP_BEST = 255
        };

        /// <summary>Types for uniform data.</summary>
        public enum class UniformDataType
        {
            UNIFORM_DOUBLE = 0,
            UNIFORM_BOOL = 1,
            /// <summary>Array of 3 floats.</summary>
            UNIFORM_FLOAT3 = 2,
            /// <summary>Vector of floats (size is set by uniform).</summary>
            UNIFORM_VECTOR_FLOAT = 3,
            /// <summary>Vector of int pairs (size is set by uniform).</summary>
            UNIFORM_VECTOR_INT = 4,
            UNIFORM_UNKNOWN = 5
        };

        /// <summary>cpp:type:: Enum to control the behavior of the internal caches e.g. the processor cache in</summary>
        public enum class ProcessorCacheFlags : unsigned int
        {
            PROCESSOR_CACHE_OFF = 0x0,
            PROCESSOR_CACHE_ENABLED = 0x1,
            PROCESSOR_CACHE_SHARE_DYN_PROPERTIES = 0x2,
            PROCESSOR_CACHE_DEFAULT = 3
        };

        /// <summary>Styles for grading transforms.</summary>
        public enum class GradingStyle
        {
            /// <summary>Algorithms for Logarithmic color spaces.</summary>
            GRADING_LOG = 0,
            /// <summary>Algorithms for Scene Linear color spaces.</summary>
            GRADING_LIN = 1,
            /// <summary>Algorithms for Video color spaces.</summary>
            GRADING_VIDEO = 2
        };

        /// <summary>Types for GradingRGBCurve.</summary>
        public enum class RGBCurveType
        {
            RGB_RED = 0,
            RGB_GREEN = 1,
            RGB_BLUE = 2,
            RGB_MASTER = 3,
            RGB_NUM_CURVES = 4
        };

        /// <summary>Enumeration of the :cpp:class:`CDLTransform` transform algorithms.</summary>
        /// <remarks>
        /// <para>The default for reading .cc/.ccc/.cdl files, config file YAML, and CDLTransform is no-clamp,</para>
        /// <para>since that is what is primarily desired in VFX.  However, the CLF format default is ASC.</para>
        /// </remarks>
        public enum class CDLStyle
        {
            /// <summary>ASC CDL specification v1.2</summary>
            CDL_ASC = 0,
            /// <summary>CDL that does not clamp</summary>
            CDL_NO_CLAMP = 1,
            CDL_TRANSFORM_DEFAULT = 1
        };

        /// <summary>
        /// <para>Negative values handling style forand</para>
        /// <para>transform algorithms.</para>
        /// </summary>
        public enum class NegativeStyle
        {
            /// <summary>Clamp negative values</summary>
            NEGATIVE_CLAMP = 0,
            /// <summary>Positive curve is rotated 180 degrees around the origin to handle negatives.</summary>
            NEGATIVE_MIRROR = 1,
            /// <summary>Negative values are passed through unchanged.</summary>
            NEGATIVE_PASS_THRU = 2,
            /// <summary>Linearly extrapolate the curve for negative values.</summary>
            NEGATIVE_LINEAR = 3
        };

        /// <summary>Enumeration of the :cpp:class:`ExposureContrastTransform` transform algorithms.</summary>
        public enum class ExposureContrastStyle
        {
            /// <summary>E/C to be applied to a linear space image</summary>
            EXPOSURE_CONTRAST_LINEAR = 0,
            /// <summary>E/C to be applied to a video space image</summary>
            EXPOSURE_CONTRAST_VIDEO = 1,
            /// <summary>E/C to be applied to a log space image</summary>
            EXPOSURE_CONTRAST_LOGARITHMIC = 2
        };

        /// <summary>Enumeration of the :cpp:class:`FixedFunctionTransform` transform algorithms.</summary>
        public enum class FixedFunctionStyle
        {
            /// <summary>Red modifier (ACES 0.3/0.7)</summary>
            FIXED_FUNCTION_ACES_RED_MOD_03 = 0,
            /// <summary>Red modifier (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_RED_MOD_10 = 1,
            /// <summary>Glow function (ACES 0.3/0.7)</summary>
            FIXED_FUNCTION_ACES_GLOW_03 = 2,
            /// <summary>Glow function (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_GLOW_10 = 3,
            /// <summary>Dark to dim surround correction (ACES 1.0)</summary>
            FIXED_FUNCTION_ACES_DARK_TO_DIM_10 = 4,
            /// <summary>Rec.2100 surround correction (takes one double for the gamma param)</summary>
            FIXED_FUNCTION_REC2100SURROUND = 5,
            /// <summary>Classic RGB to HSV function</summary>
            FIXED_FUNCTION_RGB_TO_HSV = 6,
            /// <summary>CIE XYZ to 1931 xy chromaticity coordinates</summary>
            FIXED_FUNCTION_XYZ_TO_xyY = 7,
            /// <summary>CIE XYZ to 1976 u'v' chromaticity coordinates</summary>
            FIXED_FUNCTION_XYZ_TO_uvY = 8,
            /// <summary>CIE XYZ to 1976 CIELUV colour space (D65 white)</summary>
            FIXED_FUNCTION_XYZ_TO_LUV = 9,
            /// <summary>ACES 0.2 Gamut clamping algorithm -- NOT IMPLEMENTED YET</summary>
            FIXED_FUNCTION_ACES_GAMUTMAP_02 = 10,
            /// <summary>ACES 0.7 Gamut clamping algorithm -- NOT IMPLEMENTED YET</summary>
            FIXED_FUNCTION_ACES_GAMUTMAP_07 = 11,
            /// <summary>ACES 1.3 Parametric Gamut Compression (expects ACEScg values)</summary>
            FIXED_FUNCTION_ACES_GAMUT_COMP_13 = 12,
            /// <summary>SMPTE ST-2084 OETF, scaled with 100 nits at 1.0 (neg vals mirrored)</summary>
            FIXED_FUNCTION_LIN_TO_PQ = 13,
            /// <summary>Parametrized gamma and log segments with mirroring</summary>
            FIXED_FUNCTION_LIN_TO_GAMMA_LOG = 14,
            /// <summary>Two parameterized LogAffineTransforms with a middle linear segment</summary>
            FIXED_FUNCTION_LIN_TO_DOUBLE_LOG = 15,
            /// <summary>ACES 2.0 Display Rendering -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_OUTPUT_TRANSFORM_20 = 16,
            /// <summary>ACES 2.0 RGB to JMh -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_RGB_TO_JMH_20 = 17,
            /// <summary>ACES 2.0 Tonescale and chroma compression -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_TONESCALE_COMPRESS_20 = 18,
            /// <summary>ACES 2.0 Gamut compression -- EXPERIMENTAL</summary>
            FIXED_FUNCTION_ACES_GAMUT_COMPRESS_20 = 19
        };

        /// <summary>Used by :cpp:class`Lut1DTransform` to control optional hue restoration algorithm.</summary>
        public enum class Lut1DHueAdjust
        {
            /// <summary>No adjustment.</summary>
            HUE_NONE = 0,
            /// <summary>Algorithm used in ACES Output Transforms through v0.7.</summary>
            HUE_DW3 = 1,
            /// <summary>Weighted Yellow Power Norm -- NOT IMPLEMENTED YET</summary>
            HUE_WYPN = 2
        };

        /// <summary>A RangeTransform may be set to clamp the values, or not.</summary>
        public enum class RangeStyle
        {
            RANGE_NO_CLAMP = 0,
            RANGE_CLAMP = 1
        };

        public enum class LoggingLevel
        {
            LOGGING_LEVEL_NONE = 0,
            LOGGING_LEVEL_WARNING = 1,
            LOGGING_LEVEL_INFO = 2,
            LOGGING_LEVEL_DEBUG = 3,
            LOGGING_LEVEL_UNKNOWN = 255,
            LOGGING_LEVEL_DEFAULT = 2
        };

        /// <summary>Used byto indicate the channel ordering of the image to process.</summary>
        public enum class ChannelOrdering
        {
            CHANNEL_ORDERING_RGBA = 0,
            CHANNEL_ORDERING_BGRA = 1,
            CHANNEL_ORDERING_ABGR = 2,
            CHANNEL_ORDERING_RGB = 3,
            CHANNEL_ORDERING_BGR = 4
        };

        public ref class OpenColorTypes
        {
        public:
            static ::System::String^ BoolToString(bool val);
            static bool BoolFromString(::System::String^ s);
            static ::System::String^ LoggingLevelToString(OpenColorIO::OpenColorIO_v2_4::LoggingLevel level);
            static OpenColorIO::OpenColorIO_v2_4::LoggingLevel LoggingLevelFromString(::System::String^ s);
            static ::System::String^ TransformDirectionToString(OpenColorIO::OpenColorIO_v2_4::TransformDirection dir);
            /// <summary>Will throw if string is not recognized.</summary>
            static OpenColorIO::OpenColorIO_v2_4::TransformDirection TransformDirectionFromString(::System::String^ s);
            static OpenColorIO::OpenColorIO_v2_4::TransformDirection GetInverseTransformDirection(OpenColorIO::OpenColorIO_v2_4::TransformDirection dir);
            static OpenColorIO::OpenColorIO_v2_4::TransformDirection CombineTransformDirections(OpenColorIO::OpenColorIO_v2_4::TransformDirection d1, OpenColorIO::OpenColorIO_v2_4::TransformDirection d2);
            static ::System::String^ BitDepthToString(OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth);
            static OpenColorIO::OpenColorIO_v2_4::BitDepth BitDepthFromString(::System::String^ s);
            static bool BitDepthIsFloat(OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth);
            static int BitDepthToInt(OpenColorIO::OpenColorIO_v2_4::BitDepth bitDepth);
            static ::System::String^ AllocationToString(OpenColorIO::OpenColorIO_v2_4::Allocation allocation);
            static OpenColorIO::OpenColorIO_v2_4::Allocation AllocationFromString(::System::String^ s);
            static ::System::String^ InterpolationToString(OpenColorIO::OpenColorIO_v2_4::Interpolation interp);
            static OpenColorIO::OpenColorIO_v2_4::Interpolation InterpolationFromString(::System::String^ s);
            static ::System::String^ GpuLanguageToString(OpenColorIO::OpenColorIO_v2_4::GpuLanguage language);
            static OpenColorIO::OpenColorIO_v2_4::GpuLanguage GpuLanguageFromString(::System::String^ s);
            static ::System::String^ EnvironmentModeToString(OpenColorIO::OpenColorIO_v2_4::EnvironmentMode mode);
            static OpenColorIO::OpenColorIO_v2_4::EnvironmentMode EnvironmentModeFromString(::System::String^ s);
            static ::System::String^ CDLStyleToString(OpenColorIO::OpenColorIO_v2_4::CDLStyle style);
            static OpenColorIO::OpenColorIO_v2_4::CDLStyle CDLStyleFromString(::System::String^ style);
            static ::System::String^ RangeStyleToString(OpenColorIO::OpenColorIO_v2_4::RangeStyle style);
            static OpenColorIO::OpenColorIO_v2_4::RangeStyle RangeStyleFromString(::System::String^ style);
            static ::System::String^ FixedFunctionStyleToString(OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle style);
            static OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle FixedFunctionStyleFromString(::System::String^ style);
            static ::System::String^ GradingStyleToString(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);
            static OpenColorIO::OpenColorIO_v2_4::GradingStyle GradingStyleFromString(::System::String^ s);
            static ::System::String^ ExposureContrastStyleToString(OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle style);
            static OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle ExposureContrastStyleFromString(::System::String^ style);
            static ::System::String^ NegativeStyleToString(OpenColorIO::OpenColorIO_v2_4::NegativeStyle style);
            static OpenColorIO::OpenColorIO_v2_4::NegativeStyle NegativeStyleFromString(::System::String^ style);
        };
    }
}
