// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma once

#include "CppSharp.h"
#include <OpenColorTransforms.h>
#include "OpenColorTypes.h"

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        enum class Allocation;
        enum class BitDepth;
        enum class CDLStyle;
        enum class DynamicPropertyType;
        enum class ExposureContrastStyle;
        enum class FixedFunctionStyle;
        enum class Interpolation;
        enum class Lut1DHueAdjust;
        enum class NegativeStyle;
        enum class RGBCurveType;
        enum class RangeStyle;
        enum class TransformDirection;
        enum class TransformType;
        ref class AllocationTransform;
        ref class BuiltinTransform;
        ref class CDLTransform;
        ref class ColorSpaceTransform;
        ref class DisplayViewTransform;
        ref class DynamicProperty;
        ref class DynamicPropertyDouble;
        ref class DynamicPropertyGradingPrimary;
        ref class DynamicPropertyGradingRGBCurve;
        ref class DynamicPropertyGradingTone;
        ref class ExponentTransform;
        ref class ExponentWithLinearTransform;
        ref class ExposureContrastTransform;
        ref class FileTransform;
        ref class FixedFunctionTransform;
        ref class FormatMetadata;
        ref class GradingBSplineCurve;
        ref class GradingControlPoint;
        ref class GradingPrimary;
        ref class GradingPrimaryTransform;
        ref class GradingRGBCurve;
        ref class GradingRGBCurveTransform;
        ref class GradingRGBM;
        ref class GradingRGBMSW;
        ref class GradingTone;
        ref class GradingToneTransform;
        ref class GroupTransform;
        ref class LogAffineTransform;
        ref class LogCameraTransform;
        ref class LogTransform;
        ref class LookTransform;
        ref class Lut1DTransform;
        ref class Lut3DTransform;
        ref class MatrixTransform;
        ref class RangeTransform;
        ref class Transform;
    }
}

namespace OpenColorIO
{
    namespace OpenColorIO_v2_4
    {
        /// <summary>
        /// <para>The FormatMetadata class is intended to be a generic container to hold metadata from various</para>
        /// <para>file formats.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class provides a hierarchical metadata container. A metadata object is similar to an</para>
        /// <para>element in XML. The top level element is named &quot;ROOT&quot; and can't be renamed. Several transforms</para>
        /// <para>have a FormatMetadata.</para>
        /// <para>The root element and all of the sub-elements may contain:</para>
        /// <para>* A name string (e.g. &quot;ROOT&quot;, &quot;Description&quot;...). Name can't be empty.</para>
        /// <para>* A value string (e.g. &quot;updated viewing LUT&quot;). Value can be empty.</para>
        /// <para>* A list of attributes (name, value) string pairs (e.g. &quot;version&quot;, &quot;1.5&quot;). There are helper</para>
        /// <para>functions to get and set &quot;id&quot; and &quot;name&quot; attributes. Attribute names are unique.</para>
        /// <para>* And a list of child sub-elements, which are also objects implementing FormatMetadata. There</para>
        /// <para>can be several sub-elements with the same name.</para>
        /// </remarks>
        public ref class FormatMetadata : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_string8_string8(::System::IntPtr __instance, ::System::String^ arg1, ::System::String^ arg2);

            property class ::OpenColorIO_v2_4::FormatMetadata* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            FormatMetadata(class ::OpenColorIO_v2_4::FormatMetadata* native);
            FormatMetadata(class ::OpenColorIO_v2_4::FormatMetadata* native, bool ownNativeInstance);
            static FormatMetadata^ __CreateInstance(::System::IntPtr native);
            static FormatMetadata^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~FormatMetadata();

            property ::System::String^ ElementName
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ ElementValue
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property int NumAttributes
            {
                int get();
            }

            property int NumChildrenElements
            {
                int get();
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'name' attribute.  This corresponds to the</para>
            /// <para>ProcessNode name attribute from a CLF / CTF file or the name key of a transform in the</para>
            /// <para>config YAML.</para>
            /// </summary>
            property ::System::String^ Name
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>
            /// <para>Convenience method to easily get/set the 'id' attribute.  This corresponds to the</para>
            /// <para>ProcessNode id attribute from a CLF/CTF file or the ColorCorrection id attribute from a</para>
            /// <para>CC/CCC/CDL file.</para>
            /// </summary>
            property ::System::String^ ID
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Get the name of a attribute (&quot;&quot; if attribute does not exist).</summary>
            virtual ::System::String^ GetAttributeName(int i);

            /// <summary>Get the value of a attribute (&quot;&quot; if attribute does not exist).</summary>
            virtual ::System::String^ GetAttributeValue(int i);

            /// <summary>Get the value of a attribute of a given name (&quot;&quot; if attribute does not exist).</summary>
            virtual ::System::String^ GetAttributeValue(::System::String^ name);

            /// <summary>
            /// <para>Add an attribute with a given name and value. If an attribute with the same name already</para>
            /// <para>exists, its value is replaced. Throw if name is NULL or empty.</para>
            /// </summary>
            virtual void AddAttribute(::System::String^ name, ::System::String^ value);

            virtual OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ GetChildElement(int i);

            /// <summary>Add a child element with a given name and value.</summary>
            /// <remarks>
            /// <para>Name has to be non-empty. Value may be empty, particularly if this element will have</para>
            /// <para>children. Element is added after all existing children. Use</para>
            /// <para>getChildElement(getNumChildrenElements()-1) to access the added element.</para>
            /// </remarks>
            virtual void AddChildElement(::System::String^ name, ::System::String^ value);

            /// <summary>Remove all children, all attributes and the value.</summary>
            virtual void Clear();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Base class for all the transform classes</summary>
        public ref class Transform : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::TransformDirection Func_OpenColorIO_OpenColorIO_v2_4_TransformDirection___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_TransformDirection(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::TransformDirection arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::TransformType Func_OpenColorIO_OpenColorIO_v2_4_TransformType___IntPtr(::System::IntPtr __instance);

            property class ::OpenColorIO_v2_4::Transform* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            Transform(class ::OpenColorIO_v2_4::Transform* native);
            Transform(class ::OpenColorIO_v2_4::Transform* native, bool ownNativeInstance);
            static Transform^ __CreateInstance(::System::IntPtr native);
            static Transform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Transform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            /// <summary>Will throw if data is not valid.</summary>
            virtual void Validate();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>Forward direction wraps the 'expanded' range into the</para>
        /// <para>specified, often compressed, range.</para>
        /// </summary>
        public ref class AllocationTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            AllocationTransform(class ::OpenColorIO_v2_4::AllocationTransform* native);
            AllocationTransform(class ::OpenColorIO_v2_4::AllocationTransform* native, bool ownNativeInstance);
            static AllocationTransform^ __CreateInstance(::System::IntPtr native);
            static AllocationTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~AllocationTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::Allocation Allocation
            {
                OpenColorIO::OpenColorIO_v2_4::Allocation get();
                void set(OpenColorIO::OpenColorIO_v2_4::Allocation);
            }

            property int NumVars
            {
                int get();
            }

            /// <summary>Will throw if data is not valid.</summary>
            virtual void Validate() override;

            void GetVars([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% vars);

            void SetVars(int numvars, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% vars);
        };

        /// <summary>
        /// <para>A built-in transform is similar to a FileTransform, but without the file.</para>
        /// <para>OCIO knows how to build a set of commonly used transforms on-demand, thus avoiding the need</para>
        /// <para>for external files and simplifying config authoring.</para>
        /// </summary>
        public ref class BuiltinTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            BuiltinTransform(class ::OpenColorIO_v2_4::BuiltinTransform* native);
            BuiltinTransform(class ::OpenColorIO_v2_4::BuiltinTransform* native, bool ownNativeInstance);
            static BuiltinTransform^ __CreateInstance(::System::IntPtr native);
            static BuiltinTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~BuiltinTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property ::System::String^ Style
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Description
            {
                ::System::String^ get();
            }
        };

        /// <summary>
        /// <para>An implementation of the ASC Color Decision List (CDL), based on the ASC v1.2</para>
        /// <para>specification.</para>
        /// </summary>
        /// <remarks>
        /// <para>**ASC_SOP**</para>
        /// <para>Slope, offset, power::</para>
        /// <para>out = clamp( (in * slope) + offset ) ^ power</para>
        /// <para>​</para>
        /// <para>If the config version is 1, negative values are clamped if the power is not 1.0.</para>
        /// <para>For config version 2 and higher, the negative handling is controlled by the CDL style.</para>
        /// </remarks>
        public ref class CDLTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr___IntPtr(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::CDLTransform^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::CDLStyle Func_OpenColorIO_OpenColorIO_v2_4_CDLStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_CDLStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::CDLStyle arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_doublePtr(::System::IntPtr __instance, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate double Func_double___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_double(::System::IntPtr __instance, double arg1);

            CDLTransform(class ::OpenColorIO_v2_4::CDLTransform* native);
            CDLTransform(class ::OpenColorIO_v2_4::CDLTransform* native, bool ownNativeInstance);
            static CDLTransform^ __CreateInstance(::System::IntPtr native);
            static CDLTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~CDLTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property OpenColorIO::OpenColorIO_v2_4::CDLStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::CDLStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::CDLStyle);
            }

            property double Sat
            {
                double get();
                void set(double);
            }

            /// <summary>
            /// <para>The get/setID methods are now deprecated. The preferred way of interacting with the ID is</para>
            /// <para>now via the transform's formatMetadata.</para>
            /// </summary>
            property ::System::String^ ID
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ FirstSOPDescription
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::CDLTransform^ other);

            virtual void GetSlope([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void SetSlope([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void GetOffset([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void SetOffset([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void GetPower([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void SetPower([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);

            virtual void GetSOP([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% vec9);

            virtual void SetSOP([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% vec9);

            /// <summary>These are hard-coded, by spec, to r709.</summary>
            virtual void GetSatLumaCoefs([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgb);
        };

        public ref class ColorSpaceTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            ColorSpaceTransform(class ::OpenColorIO_v2_4::ColorSpaceTransform* native);
            ColorSpaceTransform(class ::OpenColorIO_v2_4::ColorSpaceTransform* native, bool ownNativeInstance);
            static ColorSpaceTransform^ __CreateInstance(::System::IntPtr native);
            static ColorSpaceTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ColorSpaceTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property ::System::String^ Src
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Dst
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>Data color spaces do not get processed when true (which is the default).</summary>
            property bool DataBypass
            {
                bool get();
                void set(bool);
            }

            virtual void Validate() override;
        };

        public ref class DisplayViewTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            DisplayViewTransform(class ::OpenColorIO_v2_4::DisplayViewTransform* native);
            DisplayViewTransform(class ::OpenColorIO_v2_4::DisplayViewTransform* native, bool ownNativeInstance);
            static DisplayViewTransform^ __CreateInstance(::System::IntPtr native);
            static DisplayViewTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DisplayViewTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property ::System::String^ Src
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Display
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ View
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property bool LooksBypass
            {
                bool get();
                void set(bool);
            }

            property bool DataBypass
            {
                bool get();
                void set(bool);
            }

            /// <summary>Will throw if data is not valid.</summary>
            virtual void Validate() override;
        };

        /// <summary>
        /// <para>Used by the grading transforms to hold the red, green, blue, and master components</para>
        /// <para>of a single parameter.  The master component affects all three channels (RGB).</para>
        /// </summary>
        public ref class GradingRGBM : ICppInstance
        {
        public:

            property struct ::OpenColorIO_v2_4::GradingRGBM* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingRGBM(struct ::OpenColorIO_v2_4::GradingRGBM* native);
            GradingRGBM(struct ::OpenColorIO_v2_4::GradingRGBM* native, bool ownNativeInstance);
            static GradingRGBM^ __CreateInstance(::System::IntPtr native);
            static GradingRGBM^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingRGBM();

            GradingRGBM(double red, double green, double blue, double master);

            GradingRGBM(cli::array<double>^ rgbm);

            GradingRGBM(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ _0);

            ~GradingRGBM();

            property double MRed
            {
                double get();
                void set(double);
            }

            property double MGreen
            {
                double get();
                void set(double);
            }

            property double MBlue
            {
                double get();
                void set(double);
            }

            property double MMaster
            {
                double get();
                void set(double);
            }

            static operator OpenColorIO::OpenColorIO_v2_4::GradingRGBM^(cli::array<double>^ rgbm);

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Grading primary values.</summary>
        public ref class GradingPrimary : ICppInstance
        {
        public:

            property struct ::OpenColorIO_v2_4::GradingPrimary* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingPrimary(struct ::OpenColorIO_v2_4::GradingPrimary* native);
            GradingPrimary(struct ::OpenColorIO_v2_4::GradingPrimary* native, bool ownNativeInstance);
            static GradingPrimary^ __CreateInstance(::System::IntPtr native);
            static GradingPrimary^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingPrimary();

            GradingPrimary(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);

            GradingPrimary(OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ _0);

            ~GradingPrimary();

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MBrightness
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MContrast
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MGamma
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MOffset
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MExposure
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MLift
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ MGain
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBM^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBM^);
            }

            property double MSaturation
            {
                double get();
                void set(double);
            }

            property double MPivot
            {
                double get();
                void set(double);
            }

            property double MPivotBlack
            {
                double get();
                void set(double);
            }

            property double MPivotWhite
            {
                double get();
                void set(double);
            }

            property double MClampBlack
            {
                double get();
                void set(double);
            }

            property double MClampWhite
            {
                double get();
                void set(double);
            }

            static property double NoClampBlack
            {
                double get();
            }

            static property double NoClampWhite
            {
                double get();
            }

            /// <summary>The valid range for each parameter varies.</summary>
            void Validate(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);

            static explicit operator OpenColorIO::OpenColorIO_v2_4::GradingPrimary^(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>2D control point used by</summary>
        public ref class GradingControlPoint : ICppInstance
        {
        public:

            property struct ::OpenColorIO_v2_4::GradingControlPoint* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingControlPoint(struct ::OpenColorIO_v2_4::GradingControlPoint* native);
            GradingControlPoint(struct ::OpenColorIO_v2_4::GradingControlPoint* native, bool ownNativeInstance);
            static GradingControlPoint^ __CreateInstance(::System::IntPtr native);
            static GradingControlPoint^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingControlPoint();

            GradingControlPoint(float x, float y);

            GradingControlPoint(OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ _0);

            ~GradingControlPoint();

            property float MX
            {
                float get();
                void set(float);
            }

            property float MY
            {
                float get();
                void set(float);
            }

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>A BSpline curve defined with</summary>
        public ref class GradingBSplineCurve : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_ulong(::System::IntPtr __instance, unsigned long long arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate float Func_float___IntPtr_ulong(::System::IntPtr __instance, unsigned long long arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_ulong_float(::System::IntPtr __instance, unsigned long long arg1, float arg2);

            property class ::OpenColorIO_v2_4::GradingBSplineCurve* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingBSplineCurve(class ::OpenColorIO_v2_4::GradingBSplineCurve* native);
            GradingBSplineCurve(class ::OpenColorIO_v2_4::GradingBSplineCurve* native, bool ownNativeInstance);
            static GradingBSplineCurve^ __CreateInstance(::System::IntPtr native);
            static GradingBSplineCurve^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GradingBSplineCurve();

            property unsigned long long NumControlPoints
            {
                unsigned long long get();
                void set(unsigned long long);
            }

            property bool SlopesAreDefault
            {
                bool get();
            }

            virtual OpenColorIO::OpenColorIO_v2_4::GradingControlPoint^ GetControlPoint(unsigned long long index);

            virtual float GetSlope(unsigned long long index);

            virtual void SetSlope(unsigned long long index, float slope);

            virtual void Validate();

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingBSplineCurve^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingBSplineCurve^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingBSplineCurve^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingBSplineCurve^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>A set of red, green, blue and master curves. It is used by RGBCurveTransform and can be used as</para>
        /// <para>a dynamic property (see</para>
        /// </summary>
        public ref class GradingRGBCurve : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::GradingRGBCurve* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingRGBCurve(class ::OpenColorIO_v2_4::GradingRGBCurve* native);
            GradingRGBCurve(class ::OpenColorIO_v2_4::GradingRGBCurve* native, bool ownNativeInstance);
            static GradingRGBCurve^ __CreateInstance(::System::IntPtr native);
            static GradingRGBCurve^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingRGBCurve(OpenColorIO::OpenColorIO_v2_4::GradingRGBCurve^ _0);

            ~GradingRGBCurve();

            property bool IsIdentity
            {
                bool get();
            }

            virtual void Validate();

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingRGBCurve^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBCurve^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingRGBCurve^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBCurve^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>Used by the grading tone transforms to hold the red, green, blue, master, start,</para>
        /// <para>and width components of a single parameter.  The master component affects all three channels</para>
        /// <para>(RGB).  The start and width components control the range of tones affected. Although this</para>
        /// <para>struct simply uses &quot;start&quot; and &quot;width&quot; for all the range values, the actual user-facing name</para>
        /// <para>changes based on the parameter.</para>
        /// </summary>
        public ref class GradingRGBMSW : ICppInstance
        {
        public:

            property struct ::OpenColorIO_v2_4::GradingRGBMSW* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingRGBMSW(struct ::OpenColorIO_v2_4::GradingRGBMSW* native);
            GradingRGBMSW(struct ::OpenColorIO_v2_4::GradingRGBMSW* native, bool ownNativeInstance);
            static GradingRGBMSW^ __CreateInstance(::System::IntPtr native);
            static GradingRGBMSW^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingRGBMSW();

            GradingRGBMSW(double red, double green, double blue, double master, double start, double width);

            GradingRGBMSW(cli::array<double>^ rgbmsw);

            GradingRGBMSW(double start, double width);

            GradingRGBMSW(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ _0);

            ~GradingRGBMSW();

            property double MRed
            {
                double get();
                void set(double);
            }

            property double MGreen
            {
                double get();
                void set(double);
            }

            property double MBlue
            {
                double get();
                void set(double);
            }

            property double MMaster
            {
                double get();
                void set(double);
            }

            property double MStart
            {
                double get();
                void set(double);
            }

            property double MWidth
            {
                double get();
                void set(double);
            }

            static operator OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^(cli::array<double>^ rgbmsw);

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Grading tone values.</summary>
        public ref class GradingTone : ICppInstance
        {
        public:

            property struct ::OpenColorIO_v2_4::GradingTone* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            GradingTone(struct ::OpenColorIO_v2_4::GradingTone* native);
            GradingTone(struct ::OpenColorIO_v2_4::GradingTone* native, bool ownNativeInstance);
            static GradingTone^ __CreateInstance(::System::IntPtr native);
            static GradingTone^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            GradingTone();

            GradingTone(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);

            GradingTone(OpenColorIO::OpenColorIO_v2_4::GradingTone^ _0);

            ~GradingTone();

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ MBlacks
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ MShadows
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ MMidtones
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ MHighlights
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ MWhites
            {
                OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingRGBMSW^);
            }

            property double MScontrast
            {
                double get();
                void set(double);
            }

            /// <summary>
            /// <para>The valid range for each parameter varies. The client is expected to enforce</para>
            /// <para>these bounds in the UI.</para>
            /// </summary>
            void Validate();

            static explicit operator OpenColorIO::OpenColorIO_v2_4::GradingTone^(OpenColorIO::OpenColorIO_v2_4::GradingStyle style);

            static bool operator==(OpenColorIO::OpenColorIO_v2_4::GradingTone^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingTone^ rhs);

            virtual bool Equals(::System::Object^ obj) override;

            static bool operator!=(OpenColorIO::OpenColorIO_v2_4::GradingTone^ lhs, OpenColorIO::OpenColorIO_v2_4::GradingTone^ rhs);

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>Allows transform parameter values to be set on-the-fly (after finalization).  For</para>
        /// <para>example, to modify the exposure in a viewport.  Dynamic properties can be accessed from the</para>
        /// <para>`CPUProcessor` or `GpuShaderCreator` to change values between processing.</para>
        /// </summary>
        public ref class DynamicProperty : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType Func_OpenColorIO_OpenColorIO_v2_4_DynamicPropertyType___IntPtr(::System::IntPtr __instance);

            property class ::OpenColorIO_v2_4::DynamicProperty* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            DynamicProperty(class ::OpenColorIO_v2_4::DynamicProperty* native);
            DynamicProperty(class ::OpenColorIO_v2_4::DynamicProperty* native, bool ownNativeInstance);
            static DynamicProperty^ __CreateInstance(::System::IntPtr native);
            static DynamicProperty^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DynamicProperty();

            property OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType Type
            {
                OpenColorIO::OpenColorIO_v2_4::DynamicPropertyType get();
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Interface used to access dynamic property double value.</summary>
        public ref class DynamicPropertyDouble : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::DynamicPropertyDouble* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            DynamicPropertyDouble(class ::OpenColorIO_v2_4::DynamicPropertyDouble* native);
            DynamicPropertyDouble(class ::OpenColorIO_v2_4::DynamicPropertyDouble* native, bool ownNativeInstance);
            static DynamicPropertyDouble^ __CreateInstance(::System::IntPtr native);
            static DynamicPropertyDouble^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DynamicPropertyDouble();

            property double Value
            {
                double get();
                void set(double);
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Interface used to access dynamic property GradingPrimary value.</summary>
        public ref class DynamicPropertyGradingPrimary : ICppInstance
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr___IntPtr(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ arg1);

            property class ::OpenColorIO_v2_4::DynamicPropertyGradingPrimary* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            DynamicPropertyGradingPrimary(class ::OpenColorIO_v2_4::DynamicPropertyGradingPrimary* native);
            DynamicPropertyGradingPrimary(class ::OpenColorIO_v2_4::DynamicPropertyGradingPrimary* native, bool ownNativeInstance);
            static DynamicPropertyGradingPrimary^ __CreateInstance(::System::IntPtr native);
            static DynamicPropertyGradingPrimary^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DynamicPropertyGradingPrimary();

            property OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ Value
            {
                OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingPrimary^);
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Interface used to access dynamic property ConstGradingRGBCurveRcPtr value.</summary>
        public ref class DynamicPropertyGradingRGBCurve : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::DynamicPropertyGradingRGBCurve* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            DynamicPropertyGradingRGBCurve(class ::OpenColorIO_v2_4::DynamicPropertyGradingRGBCurve* native);
            DynamicPropertyGradingRGBCurve(class ::OpenColorIO_v2_4::DynamicPropertyGradingRGBCurve* native, bool ownNativeInstance);
            static DynamicPropertyGradingRGBCurve^ __CreateInstance(::System::IntPtr native);
            static DynamicPropertyGradingRGBCurve^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DynamicPropertyGradingRGBCurve();

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Interface used to access dynamic property GradingTone value.</summary>
        public ref class DynamicPropertyGradingTone : ICppInstance
        {
        public:

            property class ::OpenColorIO_v2_4::DynamicPropertyGradingTone* NativePtr;
            property ::System::IntPtr __Instance
            {
                virtual ::System::IntPtr get();
                virtual void set(::System::IntPtr instance);
            }

            DynamicPropertyGradingTone(class ::OpenColorIO_v2_4::DynamicPropertyGradingTone* native);
            DynamicPropertyGradingTone(class ::OpenColorIO_v2_4::DynamicPropertyGradingTone* native, bool ownNativeInstance);
            static DynamicPropertyGradingTone^ __CreateInstance(::System::IntPtr native);
            static DynamicPropertyGradingTone^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~DynamicPropertyGradingTone();

            property OpenColorIO::OpenColorIO_v2_4::GradingTone^ Value
            {
                OpenColorIO::OpenColorIO_v2_4::GradingTone^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingTone^);
            }

        protected:

            bool __ownsNativeInstance;
        };

        /// <summary>Represents exponent transform: pow( clamp(color), value ).</summary>
        /// <remarks>
        /// <para>For configs with version == 1: Negative style is ignored and if the exponent is 1.0,</para>
        /// <para>this will not clamp. Otherwise, the input color will be clamped between [0.0, inf].</para>
        /// <para>For configs with version &gt; 1: Negative value handling may be specified via setNegativeStyle.</para>
        /// </remarks>
        public ref class ExponentTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_doubleArray(::System::IntPtr __instance, cli::array<double>^ arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::NegativeStyle Func_OpenColorIO_OpenColorIO_v2_4_NegativeStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_NegativeStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::NegativeStyle arg1);

            ExponentTransform(class ::OpenColorIO_v2_4::ExponentTransform* native);
            ExponentTransform(class ::OpenColorIO_v2_4::ExponentTransform* native, bool ownNativeInstance);
            static ExponentTransform^ __CreateInstance(::System::IntPtr native);
            static ExponentTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ExponentTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_CLAMP -- Clamp negative values (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// <para>* NEGATIVE_PASS_THRU -- Negative values are passed through unchanged.</para>
            /// </remarks>
            property OpenColorIO::OpenColorIO_v2_4::NegativeStyle NegativeStyle
            {
                OpenColorIO::OpenColorIO_v2_4::NegativeStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::NegativeStyle);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::ExponentTransform^ other);

            virtual void GetValue(cli::array<double>^ vec4);

            virtual void SetValue(cli::array<double>^ vec4);
        };

        /// <summary>
        /// <para>Represents power functions with a linear section in the shadows</para>
        /// <para>such as sRGB and L*.</para>
        /// </summary>
        /// <remarks>
        /// <para>The basic formula is::</para>
        /// <para>pow( (x + offset)/(1 + offset), gamma )</para>
        /// <para>with the breakpoint at offset/(gamma - 1).</para>
        /// <para>Negative values are never clamped.</para>
        /// </remarks>
        public ref class ExponentWithLinearTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            ExponentWithLinearTransform(class ::OpenColorIO_v2_4::ExponentWithLinearTransform* native);
            ExponentWithLinearTransform(class ::OpenColorIO_v2_4::ExponentWithLinearTransform* native, bool ownNativeInstance);
            static ExponentWithLinearTransform^ __CreateInstance(::System::IntPtr native);
            static ExponentWithLinearTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ExponentWithLinearTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Specifies how negative values are handled. Legal values:</summary>
            /// <remarks>
            /// <para>* NEGATIVE_LINEAR -- Linear segment continues into negatives (default).</para>
            /// <para>* NEGATIVE_MIRROR -- Positive curve is rotated 180 degrees around the origin to</para>
            /// <para>handle negatives.</para>
            /// </remarks>
            property OpenColorIO::OpenColorIO_v2_4::NegativeStyle NegativeStyle
            {
                OpenColorIO::OpenColorIO_v2_4::NegativeStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::NegativeStyle);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::ExponentWithLinearTransform^ other);

            virtual void GetGamma(cli::array<double>^ values);

            /// <summary>Set the exponent value for the power function for R, G, B, A.</summary>
            /// <remarks>
            /// <para>The gamma values must be in the range of [1, 10]. Set the transform direction</para>
            /// <para>to inverse to obtain the effect of values less than 1.</para>
            /// </remarks>
            virtual void SetGamma(cli::array<double>^ values);

            virtual void GetOffset(cli::array<double>^ values);

            /// <summary>Set the offset value for the power function for R, G, B, A.</summary>
            /// <remarks>The offset values must be in the range [0, 0.9].</remarks>
            virtual void SetOffset(cli::array<double>^ values);
        };

        /// <summary>
        /// <para>Applies exposure, gamma, and pivoted contrast adjustments.</para>
        /// <para>Adjusts the math to be appropriate for linear, logarithmic, or video</para>
        /// <para>color spaces.</para>
        /// </summary>
        public ref class ExposureContrastTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle Func_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_ExposureContrastStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle arg1);

            ExposureContrastTransform(class ::OpenColorIO_v2_4::ExposureContrastTransform* native);
            ExposureContrastTransform(class ::OpenColorIO_v2_4::ExposureContrastTransform* native, bool ownNativeInstance);
            static ExposureContrastTransform^ __CreateInstance(::System::IntPtr native);
            static ExposureContrastTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~ExposureContrastTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::ExposureContrastStyle);
            }

            property double Exposure
            {
                double get();
                void set(double);
            }

            /// <summary>
            /// <para>Exposure can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic exposure.</para>
            /// </summary>
            property bool IsExposureDynamic
            {
                bool get();
            }

            property double Contrast
            {
                double get();
                void set(double);
            }

            /// <summary>
            /// <para>Contrast can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic contrast.</para>
            /// </summary>
            property bool IsContrastDynamic
            {
                bool get();
            }

            property double Gamma
            {
                double get();
                void set(double);
            }

            /// <summary>
            /// <para>Gamma can be made dynamic so the value can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several ExposureContrastTransform only one can have a dynamic gamma.</para>
            /// </summary>
            property bool IsGammaDynamic
            {
                bool get();
            }

            property double Pivot
            {
                double get();
                void set(double);
            }

            property double LogExposureStep
            {
                double get();
                void set(double);
            }

            property double LogMidGray
            {
                double get();
                void set(double);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::ExposureContrastTransform^ other);

            virtual void MakeExposureDynamic();

            virtual void MakeExposureNonDynamic();

            virtual void MakeContrastDynamic();

            virtual void MakeContrastNonDynamic();

            virtual void MakeGammaDynamic();

            virtual void MakeGammaNonDynamic();
        };

        public ref class FileTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            FileTransform(class ::OpenColorIO_v2_4::FileTransform* native);
            FileTransform(class ::OpenColorIO_v2_4::FileTransform* native, bool ownNativeInstance);
            static FileTransform^ __CreateInstance(::System::IntPtr native);
            static FileTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~FileTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property ::System::String^ Src
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            /// <summary>
            /// <para>The cccid can be the ID of a CDL or the index of the CDL (as string). If cccid is NULL or</para>
            /// <para>empty the first CDL is returned.  The cccid is case-sensitive.</para>
            /// </summary>
            property ::System::String^ CCCId
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property OpenColorIO::OpenColorIO_v2_4::CDLStyle CDLStyle
            {
                OpenColorIO::OpenColorIO_v2_4::CDLStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::CDLStyle);
            }

            /// <summary>
            /// <para>The file parsers that care about interpolation (LUTs) will try to make use of the requested</para>
            /// <para>interpolation method when loading the file.  In these cases, if the requested method could</para>
            /// <para>not be used, a warning is logged.  If no method is provided, or a method cannot be used,</para>
            /// <para>INTERP_DEFAULT is used.</para>
            /// </summary>
            property OpenColorIO::OpenColorIO_v2_4::Interpolation Interpolation
            {
                OpenColorIO::OpenColorIO_v2_4::Interpolation get();
                void set(OpenColorIO::OpenColorIO_v2_4::Interpolation);
            }

            /// <summary>Get the number of LUT readers.</summary>
            static property int NumFormats
            {
                int get();
            }

            /// <summary>Will throw if data is not valid.</summary>
            virtual void Validate() override;

            /// <summary>Get the LUT readers at index, return empty string if an invalid index is specified.</summary>
            static ::System::String^ GetFormatNameByIndex(int index);

            /// <summary>Get the LUT reader extension at index, return empty string if an invalid index is specified.</summary>
            static ::System::String^ GetFormatExtensionByIndex(int index);

            /// <summary>
            /// <para>Returns true if the extension corresponds to a format supported by FileTransform.</para>
            /// <para>The argument is case-insensitive, and a leading dot, if present, is ignored.</para>
            /// <para>Note that FileTransform will attempt all format readers on a given file until it is</para>
            /// <para>successful, even files that contain an unsupported extension or no extension.</para>
            /// <para>However, this function is useful for applications that want to know which files are likely</para>
            /// <para>to be LUT files, based on their extension.</para>
            /// </summary>
            static bool IsFormatExtensionSupported(::System::String^ extension);
        };

        /// <summary>
        /// <para>Provides a set of hard-coded algorithmic building blocks</para>
        /// <para>that are needed to accurately implement various common color transformations.</para>
        /// </summary>
        public ref class FixedFunctionTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle Func_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_FixedFunctionStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_doublePtr_ulong(::System::IntPtr __instance, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% arg1, unsigned long long arg2);

            FixedFunctionTransform(class ::OpenColorIO_v2_4::FixedFunctionTransform* native);
            FixedFunctionTransform(class ::OpenColorIO_v2_4::FixedFunctionTransform* native, bool ownNativeInstance);
            static FixedFunctionTransform^ __CreateInstance(::System::IntPtr native);
            static FixedFunctionTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~FixedFunctionTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::FixedFunctionStyle);
            }

            property unsigned long long NumParams
            {
                unsigned long long get();
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::FixedFunctionTransform^ other);

            virtual void GetParams([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% params);

            /// <summary>Set the parameters (for functions that require them).</summary>
            virtual void SetParams([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% params, unsigned long long num);
        };

        /// <summary>Primary color correction controls.</summary>
        /// <remarks>
        /// <para>This transform is for making basic color correction adjustments to an image such as brightness,</para>
        /// <para>contrast, or saturation.</para>
        /// <para>The controls are customized for linear, logarithmic, and video color encodings.</para>
        /// <para>* Linear controls: Exposure, Contrast, Pivot, Offset, Saturation, Black Clip, White Clip.</para>
        /// <para>* Log controls: Brightness, Contrast, Pivot, Log Gamma, Saturation, Black Clip, White Clip,</para>
        /// <para>Black Pivot White Pivot.</para>
        /// <para>* Video controls : Lift, Gamma, Gain, Offset, Saturation, Black Clip, White Clip,</para>
        /// <para>Black Pivot White Pivot.</para>
        /// <para>The controls are dynamic, so they may be adjusted even after the Transform has been included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public ref class GradingPrimaryTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::GradingStyle Func_OpenColorIO_OpenColorIO_v2_4_GradingStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_GradingStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::GradingStyle arg1);

            GradingPrimaryTransform(class ::OpenColorIO_v2_4::GradingPrimaryTransform* native);
            GradingPrimaryTransform(class ::OpenColorIO_v2_4::GradingPrimaryTransform* native, bool ownNativeInstance);
            static GradingPrimaryTransform^ __CreateInstance(::System::IntPtr native);
            static GradingPrimaryTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GradingPrimaryTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            property OpenColorIO::OpenColorIO_v2_4::GradingStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::GradingStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingStyle);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ Value
            {
                OpenColorIO::OpenColorIO_v2_4::GradingPrimary^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingPrimary^);
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingPrimaryTransform only one can have dynamic parameters.</para>
            /// </summary>
            property bool IsDynamic
            {
                bool get();
            }

            /// <summary>Checks if this equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::GradingPrimaryTransform^ other);

            virtual void MakeDynamic();

            virtual void MakeNonDynamic();
        };

        /// <summary>RGB curve color correction controls.</summary>
        /// <remarks>
        /// <para>This transform allows for modifying tone reproduction via B-spline curves.</para>
        /// <para>There is an R, G, and B curve along with a Master curve (that applies to R, G, and B).  Each</para>
        /// <para>curve is specified via the x and y coordinates of its control points.  A monotonic spline is</para>
        /// <para>fit to the control points.  The x coordinates must be non-decreasing. When the grading style</para>
        /// <para>is linear, the units for the control points are photographic stops relative to 0.18.</para>
        /// <para>The control points are dynamic, so they may be adjusted even after the Transform is included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public ref class GradingRGBCurveTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate float Func_float___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::RGBCurveType arg1, unsigned long long arg2);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType_ulong_float(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::RGBCurveType arg1, unsigned long long arg2, float arg3);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr_OpenColorIO_OpenColorIO_v2_4_RGBCurveType(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::RGBCurveType arg1);

            GradingRGBCurveTransform(class ::OpenColorIO_v2_4::GradingRGBCurveTransform* native);
            GradingRGBCurveTransform(class ::OpenColorIO_v2_4::GradingRGBCurveTransform* native, bool ownNativeInstance);
            static GradingRGBCurveTransform^ __CreateInstance(::System::IntPtr native);
            static GradingRGBCurveTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GradingRGBCurveTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            property OpenColorIO::OpenColorIO_v2_4::GradingStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::GradingStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingStyle);
            }

            /// <summary>
            /// <para>The scene-linear grading style applies a lin-to-log transform to the pixel</para>
            /// <para>values before going through the curve.  However, in some cases (e.g. drawing curves in a UI)</para>
            /// <para>it may be useful to bypass the lin-to-log. Default value is false.</para>
            /// </summary>
            property bool BypassLinToLog
            {
                bool get();
                void set(bool);
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingRGBCurveTransform only one can have dynamic parameters.</para>
            /// </summary>
            property bool IsDynamic
            {
                bool get();
            }

            /// <summary>Checks if this equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::GradingRGBCurveTransform^ other);

            /// <summary>
            /// <para>It is possible to provide a desired slope value for each control point.  The number of slopes is</para>
            /// <para>always the same as the number of control points and so the control points must be set before</para>
            /// <para>setting the slopes.  The slopes are primarily intended for use by config authors looking to match</para>
            /// <para>a specific shape with as few control points as possible, they are not intended to be exposed to</para>
            /// <para>a user interface for direct manipulation.  When a curve is being generated for creative purposes</para>
            /// <para>it is better to let OCIO calculate the slopes automatically.</para>
            /// </summary>
            virtual float GetSlope(OpenColorIO::OpenColorIO_v2_4::RGBCurveType c, unsigned long long index);

            virtual void SetSlope(OpenColorIO::OpenColorIO_v2_4::RGBCurveType c, unsigned long long index, float slope);

            virtual bool SlopesAreDefault(OpenColorIO::OpenColorIO_v2_4::RGBCurveType c);

            virtual void MakeDynamic();

            virtual void MakeNonDynamic();
        };

        /// <summary>Tonal color correction controls.</summary>
        /// <remarks>
        /// <para>This transform is for making fine adjustments to tone reproduction in specific tonal ranges.</para>
        /// <para>There are five tonal controls and each one has two parameters to control its range:</para>
        /// <para>* Blacks (start, width)</para>
        /// <para>* Shadows(start, pivot)</para>
        /// <para>* Midtones(center, width)</para>
        /// <para>* Highlights(start, pivot)</para>
        /// <para>* Whites(start, width)</para>
        /// <para>The transform has three styles that adjust the response and default ranges for linear,</para>
        /// <para>logarithimic, and video color encodings. The defaults vary based on the style.  When the</para>
        /// <para>style is linear, the units for start/width/etc. are photographic stops relative to 0.18.</para>
        /// <para>Each control allows R, G, B adjustments and a Master adjustment.</para>
        /// <para>There is also an S-contrast control for imparting an S-shape curve.</para>
        /// <para>The controls are dynamic, so they may be adjusted even after the Transform has been included</para>
        /// <para>in a Processor.</para>
        /// </remarks>
        public ref class GradingToneTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            GradingToneTransform(class ::OpenColorIO_v2_4::GradingToneTransform* native);
            GradingToneTransform(class ::OpenColorIO_v2_4::GradingToneTransform* native, bool ownNativeInstance);
            static GradingToneTransform^ __CreateInstance(::System::IntPtr native);
            static GradingToneTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GradingToneTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Adjusts the behavior of the transform for log, linear, or video color space encodings.</summary>
            /// <remarks>Will reset value to style's defaults if style is not the current style.</remarks>
            property OpenColorIO::OpenColorIO_v2_4::GradingStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::GradingStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingStyle);
            }

            property OpenColorIO::OpenColorIO_v2_4::GradingTone^ Value
            {
                OpenColorIO::OpenColorIO_v2_4::GradingTone^ get();
                void set(OpenColorIO::OpenColorIO_v2_4::GradingTone^);
            }

            /// <summary>
            /// <para>Parameters can be made dynamic so the values can be changed through the CPU or GPU processor,</para>
            /// <para>but if there are several GradingToneTransform only one can have dynamic parameters.</para>
            /// </summary>
            property bool IsDynamic
            {
                bool get();
            }

            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::GradingToneTransform^ other);

            virtual void MakeDynamic();

            virtual void MakeNonDynamic();
        };

        public ref class GroupTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            GroupTransform(class ::OpenColorIO_v2_4::GroupTransform* native);
            GroupTransform(class ::OpenColorIO_v2_4::GroupTransform* native, bool ownNativeInstance);
            static GroupTransform^ __CreateInstance(::System::IntPtr native);
            static GroupTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~GroupTransform();

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>Return number of transforms.</summary>
            property int NumTransforms
            {
                int get();
            }

            /// <summary>Get the number of writers.</summary>
            static property int NumWriteFormats
            {
                int get();
            }

            /// <summary>Get the writer at index, return empty string if an invalid index is specified.</summary>
            static ::System::String^ GetFormatNameByIndex(int index);

            static ::System::String^ GetFormatExtensionByIndex(int index);
        };

        /// <summary>
        /// <para>Applies a logarithm with an affine transform before and after.</para>
        /// <para>Represents the Cineon lin-to-log type transforms::</para>
        /// </summary>
        /// <remarks>
        /// <para>logSideSlope * log( linSideSlope * color + linSideOffset, base) + logSideOffset</para>
        /// <para>* Default values are: 1. * log( 1. * color + 0., 2.) + 0.</para>
        /// <para>* The alpha channel is not affected.</para>
        /// </remarks>
        public ref class LogAffineTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            LogAffineTransform(class ::OpenColorIO_v2_4::LogAffineTransform* native);
            LogAffineTransform(class ::OpenColorIO_v2_4::LogAffineTransform* native, bool ownNativeInstance);
            static LogAffineTransform^ __CreateInstance(::System::IntPtr native);
            static LogAffineTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~LogAffineTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property double Base
            {
                double get();
                void set(double);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::LogAffineTransform^ other);

            virtual void GetLogSideSlopeValue(cli::array<double>^ values);

            virtual void SetLogSideSlopeValue(cli::array<double>^ values);

            virtual void GetLogSideOffsetValue(cli::array<double>^ values);

            virtual void SetLogSideOffsetValue(cli::array<double>^ values);

            virtual void GetLinSideSlopeValue(cli::array<double>^ values);

            virtual void SetLinSideSlopeValue(cli::array<double>^ values);

            virtual void GetLinSideOffsetValue(cli::array<double>^ values);

            virtual void SetLinSideOffsetValue(cli::array<double>^ values);
        };

        /// <summary>
        /// <para>Same as LogAffineTransform but with the addition of a linear segment near black. This formula</para>
        /// <para>is used for many camera logs (e.g., LogC) as well as ACEScct.</para>
        /// </summary>
        /// <remarks>
        /// <para>* The linSideBreak specifies the point on the linear axis where the log and linear</para>
        /// <para>segments meet.  It must be set (there is no default).</para>
        /// <para>* The linearSlope specifies the slope of the linear segment of the forward (linToLog)</para>
        /// <para>transform.  By default it is set equal to the slope of the log curve at the break point.</para>
        /// </remarks>
        public ref class LogCameraTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate bool Func_bool___IntPtr_doubleArray(::System::IntPtr __instance, cli::array<double>^ arg1);

            LogCameraTransform(class ::OpenColorIO_v2_4::LogCameraTransform* native);
            LogCameraTransform(class ::OpenColorIO_v2_4::LogCameraTransform* native, bool ownNativeInstance);
            static LogCameraTransform^ __CreateInstance(::System::IntPtr native);
            static LogCameraTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~LogCameraTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property double Base
            {
                double get();
                void set(double);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::LogCameraTransform^ other);

            /// <summary>Get/Set values for the R, G, B components.</summary>
            virtual void GetLogSideSlopeValue(cli::array<double>^ values);

            virtual void SetLogSideSlopeValue(cli::array<double>^ values);

            virtual void GetLogSideOffsetValue(cli::array<double>^ values);

            virtual void SetLogSideOffsetValue(cli::array<double>^ values);

            virtual void GetLinSideSlopeValue(cli::array<double>^ values);

            virtual void SetLinSideSlopeValue(cli::array<double>^ values);

            virtual void GetLinSideOffsetValue(cli::array<double>^ values);

            virtual void SetLinSideOffsetValue(cli::array<double>^ values);

            virtual void GetLinSideBreakValue(cli::array<double>^ values);

            virtual void SetLinSideBreakValue(cli::array<double>^ values);

            /// <summary>Return true if LinearSlope values were set, false if they were not.</summary>
            virtual bool GetLinearSlopeValue(cli::array<double>^ values);

            /// <summary>Set LinearSlope value.</summary>
            /// <remarks>You must call setLinSideBreakValue before calling this.</remarks>
            virtual void SetLinearSlopeValue(cli::array<double>^ values);

            /// <summary>Remove LinearSlope values so that default values are used.</summary>
            virtual void UnsetLinearSlopeValue();
        };

        /// <summary>Represents log transform: log(color, base)</summary>
        /// <remarks>
        /// <para>* The input will be clamped for negative numbers.</para>
        /// <para>* Default base is 2.0.</para>
        /// <para>* The alpha channel is not affected.</para>
        /// </remarks>
        public ref class LogTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            LogTransform(class ::OpenColorIO_v2_4::LogTransform* native);
            LogTransform(class ::OpenColorIO_v2_4::LogTransform* native, bool ownNativeInstance);
            static LogTransform^ __CreateInstance(::System::IntPtr native);
            static LogTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~LogTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property double Base
            {
                double get();
                void set(double);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::LogTransform^ other);
        };

        public ref class LookTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            LookTransform(class ::OpenColorIO_v2_4::LookTransform* native);
            LookTransform(class ::OpenColorIO_v2_4::LookTransform* native, bool ownNativeInstance);
            static LookTransform^ __CreateInstance(::System::IntPtr native);
            static LookTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~LookTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformDirection Direction
            {
                OpenColorIO::OpenColorIO_v2_4::TransformDirection get();
                void set(OpenColorIO::OpenColorIO_v2_4::TransformDirection);
            }

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property ::System::String^ Src
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Dst
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property ::System::String^ Looks
            {
                ::System::String^ get();
                void set(::System::String^);
            }

            property bool SkipColorSpaceConversion
            {
                bool get();
                void set(bool);
            }

            /// <summary>Will throw if data is not valid.</summary>
            virtual void Validate() override;
        };

        /// <summary>Represents a 1D-LUT transform.</summary>
        public ref class Lut1DTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_BitDepth(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::BitDepth arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_floatPtr_floatPtr_floatPtr(::System::IntPtr __instance, unsigned long arg1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg2, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg3, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg4);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_float_float_float(::System::IntPtr __instance, unsigned long arg1, float arg2, float arg3, float arg4);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::Lut1DHueAdjust Func_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Lut1DHueAdjust(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::Lut1DHueAdjust arg1);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::Interpolation Func_OpenColorIO_OpenColorIO_v2_4_Interpolation___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_Interpolation(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::Interpolation arg1);

            Lut1DTransform(class ::OpenColorIO_v2_4::Lut1DTransform* native);
            Lut1DTransform(class ::OpenColorIO_v2_4::Lut1DTransform* native, bool ownNativeInstance);
            static Lut1DTransform^ __CreateInstance(::System::IntPtr native);
            static Lut1DTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Lut1DTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileOutputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property unsigned long Length
            {
                unsigned long get();
                void set(unsigned long);
            }

            property bool InputHalfDomain
            {
                bool get();
                void set(bool);
            }

            property bool OutputRawHalfs
            {
                bool get();
                void set(bool);
            }

            property OpenColorIO::OpenColorIO_v2_4::Lut1DHueAdjust HueAdjust
            {
                OpenColorIO::OpenColorIO_v2_4::Lut1DHueAdjust get();
                void set(OpenColorIO::OpenColorIO_v2_4::Lut1DHueAdjust);
            }

            property OpenColorIO::OpenColorIO_v2_4::Interpolation Interpolation
            {
                OpenColorIO::OpenColorIO_v2_4::Interpolation get();
                void set(OpenColorIO::OpenColorIO_v2_4::Interpolation);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::Lut1DTransform^ other);

            virtual void GetValue(unsigned long index, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% r, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% g, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% b);

            /// <summary>
            /// <para>Set the values of a LUT1D.  Will throw if the index</para>
            /// <para>is outside of the range from 0 to (length-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how</para>
            /// <para>the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The</para>
            /// <para>values here are unclamped and may extend outside [0,1].</para>
            /// <para>LUTs in various file formats may only provide values for one</para>
            /// <para>channel where R, G, B are the same. Even in that case, you should</para>
            /// <para>provide three equal values to the setter.</para>
            /// </remarks>
            virtual void SetValue(unsigned long index, float r, float g, float b);
        };

        /// <summary>Represents a 3D-LUT transform.</summary>
        public ref class Lut3DTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_uint_uint_floatPtr_floatPtr_floatPtr(::System::IntPtr __instance, unsigned long arg1, unsigned long arg2, unsigned long arg3, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg5, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% arg6);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_uint_uint_uint_float_float_float(::System::IntPtr __instance, unsigned long arg1, unsigned long arg2, unsigned long arg3, float arg4, float arg5, float arg6);

            Lut3DTransform(class ::OpenColorIO_v2_4::Lut3DTransform* native);
            Lut3DTransform(class ::OpenColorIO_v2_4::Lut3DTransform* native, bool ownNativeInstance);
            static Lut3DTransform^ __CreateInstance(::System::IntPtr native);
            static Lut3DTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~Lut3DTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileOutputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            property unsigned long GridSize
            {
                unsigned long get();
                void set(unsigned long);
            }

            property OpenColorIO::OpenColorIO_v2_4::Interpolation Interpolation
            {
                OpenColorIO::OpenColorIO_v2_4::Interpolation get();
                void set(OpenColorIO::OpenColorIO_v2_4::Interpolation);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::Lut3DTransform^ other);

            virtual void GetValue(unsigned long indexR, unsigned long indexG, unsigned long indexB, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% r, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% g, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% b);

            /// <summary>
            /// <para>Set the values of a 3D-LUT. Will throw if an index is</para>
            /// <para>outside of the range from 0 to (gridSize-1).</para>
            /// </summary>
            /// <remarks>
            /// <para>The LUT values are always for the &quot;forward&quot; LUT, regardless of how the</para>
            /// <para>transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in any</para>
            /// <para>given LUT files. For example in a CLF file using a &quot;10i&quot; output</para>
            /// <para>depth, a value of 1023 in the file is normalized to 1.0. The values</para>
            /// <para>here are unclamped and may extend outside [0,1].</para>
            /// </remarks>
            virtual void SetValue(unsigned long indexR, unsigned long indexG, unsigned long indexB, float r, float g, float b);
        };

        /// <summary>Represents an MX+B Matrix transform.</summary>
        /// <remarks>For singular matrices, an inverse direction will throw an exception during finalization.</remarks>
        public ref class MatrixTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            MatrixTransform(class ::OpenColorIO_v2_4::MatrixTransform* native);
            MatrixTransform(class ::OpenColorIO_v2_4::MatrixTransform* native, bool ownNativeInstance);
            static MatrixTransform^ __CreateInstance(::System::IntPtr native);
            static MatrixTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~MatrixTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the matrix values read from a</para>
            /// <para>file or set the bit-depths of values to be written to a file</para>
            /// <para>(for file formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            /// <remarks>
            /// <para>In a format such as CLF, the matrix values are scaled to take</para>
            /// <para>pixels at the specified inBitDepth to pixels at the specified</para>
            /// <para>outBitDepth.  This complicates the interpretation of the matrix</para>
            /// <para>values and so this object always holds normalized values and</para>
            /// <para>scaling is done on the way from or to file formats such as CLF.</para>
            /// </remarks>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileInputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileOutputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            /// <summary>Checks if this exactly equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::MatrixTransform^ other);

            virtual void GetMatrix([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44);

            /// <summary>
            /// <para>Get or set the values of a Matrix. Expects 16 values,</para>
            /// <para>where the first four are the coefficients to generate the R output</para>
            /// <para>channel from R, G, B, A input channels.</para>
            /// </summary>
            /// <remarks>
            /// <para>The Matrix values are always for the &quot;forward&quot; Matrix, regardless of</para>
            /// <para>how the transform direction is set.</para>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example in a CLF file using a &quot;32f&quot;</para>
            /// <para>input depth and &quot;10i&quot; output depth, a value of 1023 in the file</para>
            /// <para>is normalized to 1.0. The values here are unclamped and may</para>
            /// <para>extend outside [0,1].</para>
            /// </remarks>
            virtual void SetMatrix([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44);

            virtual void GetOffset([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4);

            /// <summary>
            /// <para>Get or set the R, G, B, A offsets to be applied</para>
            /// <para>after the matrix.</para>
            /// </summary>
            /// <remarks>
            /// <para>These values are normalized relative to what may be stored in</para>
            /// <para>file formats such as CLF. For example, in a CLF file using a</para>
            /// <para>&quot;10i&quot; output depth, a value of 1023 in the file is normalized</para>
            /// <para>to 1.0. The values here are unclamped and may extend</para>
            /// <para>outside [0,1].</para>
            /// </remarks>
            virtual void SetOffset([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4);

            /// <summary>**Convenience functions**</summary>
            /// <remarks>
            /// <para>Build the matrix and offset corresponding to higher-level concepts.</para>
            /// <para>These can throw an exception if for any component</para>
            /// <para>``oldmin == oldmax. (divide by 0)``</para>
            /// </remarks>
            static void Fit([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% oldmin4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% oldmax4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% newmin4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% newmax4);

            static void Identity([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4);

            static void Sat([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4, double sat, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% lumaCoef3);

            static void Scale([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% scale4);

            static void View([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% m44, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% offset4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% channelHot4, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% lumaCoef3);
        };

        /// <summary>Represents a range transform</summary>
        /// <remarks>
        /// <para>The Range is used to apply an affine transform (scale&amp;offset) and</para>
        /// <para>clamps values to min/max bounds on all color components except the alpha.</para>
        /// <para>The scale and offset values are computed from the input and output bounds.</para>
        /// <para>Refer to section 7.2.4 in specification S-2014-006 &quot;A Common File Format</para>
        /// <para>for Look-Up Tables&quot; from the Academy of Motion Picture Arts and Sciences</para>
        /// <para>and the American Society of Cinematographers.</para>
        /// <para>The &quot;noClamp&quot; style described in the specification S-2014-006 becomes a</para>
        /// <para>MatrixOp at the processor level.</para>
        /// <para>Changing the transform direction does not modify the in/out values --</para>
        /// <para>they are always specified with respect to the &quot;forward&quot; direction.</para>
        /// </remarks>
        public ref class RangeTransform : OpenColorIO::OpenColorIO_v2_4::Transform
        {
        public:

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate OpenColorIO::OpenColorIO_v2_4::RangeStyle Func_OpenColorIO_OpenColorIO_v2_4_RangeStyle___IntPtr(::System::IntPtr __instance);

            [::System::Runtime::InteropServices::UnmanagedFunctionPointer(::System::Runtime::InteropServices::CallingConvention::Cdecl)] 
            delegate void Action___IntPtr_OpenColorIO_OpenColorIO_v2_4_RangeStyle(::System::IntPtr __instance, OpenColorIO::OpenColorIO_v2_4::RangeStyle arg1);

            RangeTransform(class ::OpenColorIO_v2_4::RangeTransform* native);
            RangeTransform(class ::OpenColorIO_v2_4::RangeTransform* native, bool ownNativeInstance);
            static RangeTransform^ __CreateInstance(::System::IntPtr native);
            static RangeTransform^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
            ~RangeTransform();

            property OpenColorIO::OpenColorIO_v2_4::TransformType TransformType
            {
                OpenColorIO::OpenColorIO_v2_4::TransformType get();
            }

            property OpenColorIO::OpenColorIO_v2_4::RangeStyle Style
            {
                OpenColorIO::OpenColorIO_v2_4::RangeStyle get();
                void set(OpenColorIO::OpenColorIO_v2_4::RangeStyle);
            }

            property OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ FormatMetadata
            {
                OpenColorIO::OpenColorIO_v2_4::FormatMetadata^ get();
            }

            /// <summary>
            /// <para>Get the bit-depths associated with the range values read from a file</para>
            /// <para>or set the bit-depths of values to be written to a file (for file</para>
            /// <para>formats such as CLF that support multiple bit-depths).</para>
            /// </summary>
            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileInputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            property OpenColorIO::OpenColorIO_v2_4::BitDepth FileOutputBitDepth
            {
                OpenColorIO::OpenColorIO_v2_4::BitDepth get();
                void set(OpenColorIO::OpenColorIO_v2_4::BitDepth);
            }

            /// <summary>Get the minimum value for the input.</summary>
            /// <remarks>Set the minimum value for the input.</remarks>
            property double MinInValue
            {
                double get();
                void set(double);
            }

            /// <summary>Is the minimum value for the input set?</summary>
            property bool HasMinInValue
            {
                bool get();
            }

            /// <summary>Get the maximum value for the input.</summary>
            /// <remarks>Set the maximum value for the input.</remarks>
            property double MaxInValue
            {
                double get();
                void set(double);
            }

            /// <summary>Is the maximum value for the input set?</summary>
            property bool HasMaxInValue
            {
                bool get();
            }

            /// <summary>Get the minimum value for the output.</summary>
            /// <remarks>Set the minimum value for the output.</remarks>
            property double MinOutValue
            {
                double get();
                void set(double);
            }

            /// <summary>Is the minimum value for the output set?</summary>
            property bool HasMinOutValue
            {
                bool get();
            }

            /// <summary>Get the maximum value for the output.</summary>
            /// <remarks>Set the maximum value for the output.</remarks>
            property double MaxOutValue
            {
                double get();
                void set(double);
            }

            /// <summary>Is the maximum value for the output set?</summary>
            property bool HasMaxOutValue
            {
                bool get();
            }

            /// <summary>Checks if this equals other.</summary>
            virtual bool Equals(OpenColorIO::OpenColorIO_v2_4::RangeTransform^ other);

            /// <summary>Unset the minimum value for the input</summary>
            virtual void UnsetMinInValue();

            /// <summary>Unset the maximum value for the input.</summary>
            virtual void UnsetMaxInValue();

            /// <summary>Unset the minimum value for the output.</summary>
            virtual void UnsetMinOutValue();

            /// <summary>Unset the maximum value for the output.</summary>
            virtual void UnsetMaxOutValue();
        };

        namespace DynamicPropertyValue
        {
        }
    }
}
